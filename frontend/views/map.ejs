<!DOCTYPE html>
<html>
<head>
  <title>PFVTT - Campaign Manager</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
    }
    
    .campaign-interface {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    
    /* Left Sidebar */
    .left-sidebar {
      width: 280px;
      background: #2c2c2c;
      border-right: 1px solid #444;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .campaign-header {
      padding: 15px;
      background: #333;
      border-bottom: 1px solid #444;
    }
    
    .campaign-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .campaign-system {
      font-size: 12px;
      color: #aaa;
    }
    
    .sidebar-tabs {
      display: flex;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
    }
    
    .sidebar-tab {
      flex: 1;
      padding: 10px 5px;
      text-align: center;
      background: #2a2a2a;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 11px;
      border-right: 1px solid #444;
    }
    
    .sidebar-tab:last-child {
      border-right: none;
    }
    
    .sidebar-tab.active {
      background: #0066cc;
      color: white;
    }
    
    .sidebar-tab:hover:not(.active) {
      background: #333;
    }
    
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    
    .content-section {
      display: none;
    }
    
    .content-section.active {
      display: block;
    }
    
    /* Main Canvas Area */
    .main-canvas {
      flex: 1;
      position: relative;
      background: #1a1a1a;
      overflow: hidden;
    }
    
    .canvas-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: flex;
      gap: 5px;
    }
    
    .tool-group {
      display: flex;
      background: rgba(44, 44, 44, 0.9);
      border-radius: 5px;
      padding: 5px;
      gap: 2px;
    }
    
    .tool-btn {
      width: 35px;
      height: 35px;
      background: #444;
      border: none;
      border-radius: 3px;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .tool-btn:hover {
      background: #555;
    }
    
    .tool-btn.active {
      background: #0066cc;
      color: white;
    }
    
    .map-ui-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      pointer-events: none;
      z-index: 10;
    }
    
    .zoom-indicator, .coordinates-indicator, .help-toggle {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        margin-bottom: 5px;
        font-family: monospace;
      }
      
      .help-toggle {
        cursor: pointer;
        pointer-events: auto;
        text-align: center;
        width: 20px;
        font-weight: bold;
      }
      
      .help-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }
      
      .help-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        border-radius: 8px;
        padding: 0;
        max-width: 300px;
        z-index: 20;
        border: 1px solid #555;
      }
      
      .help-header {
        background: #333;
        padding: 10px;
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: bold;
      }
      
      .help-header button {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
        width: 20px;
        height: 20px;
      }
      
      .help-content {
        padding: 15px;
      }
      
      .help-section {
        margin-bottom: 15px;
      }
      
      .help-section:last-child {
        margin-bottom: 0;
      }
      
      .help-section h4 {
        margin: 0 0 8px 0;
        color: #4a90e2;
        font-size: 14px;
      }
      
      .help-section ul {
        margin: 0;
        padding-left: 15px;
        font-size: 12px;
        line-height: 1.4;
      }
      
      .help-section li {
        margin-bottom: 4px;
      }
    
    .map-viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background: #1a1a1a;
      cursor: default;
      user-select: none;
      min-height: 600px;
    }
    
    .map-grid {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2000px;
      height: 2000px;
      margin-left: -1000px;
      margin-top: -1000px;
      background-color: #2a2a2a;
      background-image: 
        linear-gradient(rgba(255,255,255,0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.15) 1px, transparent 1px);
      background-size: 50px 50px;
      transform-origin: 0 0;
    }
    
    /* Map Layers System */
    .map-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .map-layer.active {
      pointer-events: auto;
    }
    
    #map-layer {
      z-index: 1;
    }
    
    #walls-layer {
      z-index: 2;
    }
    
    #tokens-layer {
      z-index: 3;
    }
    
    #gm-layer {
      z-index: 4;
      opacity: 0.7;
    }

    #audio-layer {
      z-index: 5;
      opacity: 0.8;
    }

    #props-layer {
      z-index: 6;
      opacity: 0.9;
    }

    .layer-hidden {
      display: none !important;
    }
    
    /* Map Assets */
    .map-asset {
      user-select: none;
      transition: all 0.2s ease;
    }
    
    .map-asset:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    /* Drag and Drop Visual Feedback */
    .map-viewport.drag-over {
      background-color: rgba(0, 123, 255, 0.1);
      border: 2px dashed #007bff;
    }
    
    /* Asset List Items Draggable */
    .assets-list .item[draggable="true"] {
      cursor: grab;
    }
    
    .assets-list .item[draggable="true"]:active {
      cursor: grabbing;
    }
    
    /* Layer Controls */
    .layer-controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(44, 44, 44, 0.9);
      border-radius: 5px;
      padding: 8px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    
    .layer-btn {
      width: 30px;
      height: 30px;
      background: #444;
      border: none;
      border-radius: 3px;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      position: relative;
    }
    
    .layer-btn:hover {
      background: #555;
    }
    
    .layer-btn.active {
      background: #0066cc;
      color: white;
      border: 2px solid #4da6ff;
      box-shadow: 0 0 8px rgba(77, 166, 255, 0.5);
      transform: scale(1.1);
    }

    .layer-btn.hidden {
      opacity: 0.3;
    }

    .layer-btn {
      transition: all 0.2s ease;
    }
    
    .layer-btn::after {
      content: attr(data-layer);
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    
    .layer-btn:hover::after {
      opacity: 1;
    }
    
    /* Right Panel */
    .right-panel {
      width: 300px;
      background: #2c2c2c;
      border-left: 1px solid #444;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .panel-tabs {
      display: flex;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
    }
    
    .panel-tab {
      flex: 1;
      padding: 10px 5px;
      text-align: center;
      background: #2a2a2a;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 11px;
      border-right: 1px solid #444;
    }
    
    .panel-tab:last-child {
      border-right: none;
    }
    
    .panel-tab.active {
      background: #0066cc;
      color: white;
    }
    
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    
    .panel-section {
      display: none;
    }
    
    .panel-section.active {
      display: block;
    }
    
    /* Common Elements */
    .item-list {
      list-style: none;
    }
    
    .item {
      background: #333;
      margin: 5px 0;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .item:hover {
      background: #3a3a3a;
      border-color: #555;
    }
    
    .item.selected {
      border-color: #0066cc;
      background: #2a4a6a;
    }
    
    .item.selected {
      background: #4a90e2;
      color: white;
    }
    
    .item-name {
      font-weight: bold;
      margin-bottom: 3px;
    }
    
    .item-details {
      font-size: 11px;
      color: #999;
    }
    
    .item-actions {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }
    
    .item-actions button {
      background: #444;
      border: none;
      color: #ccc;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .item-actions button:hover {
      background: #555;
    }
    
    .btn {
      background: #444;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      margin: 2px;
    }
    
    .btn:hover {
      background: #555;
    }
    
    .btn.primary {
      background: #0066cc;
    }
    
    .btn.primary:hover {
      background: #0077dd;
    }
    
    .btn.danger {
      background: #cc3333;
    }
    
    .btn.danger:hover {
      background: #dd4444;
    }
    
    .input-group {
      margin: 10px 0;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
      color: #ccc;
    }
    
    .input-group input, .input-group select, .input-group textarea {
      width: 100%;
      padding: 6px;
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      color: white;
      font-size: 12px;
    }
    
    .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
      outline: none;
      border-color: #0066cc;
    }
    
    .back-button {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
      background: rgba(102, 102, 102, 0.9);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .back-button:hover {
      background: rgba(119, 119, 119, 0.9);
    }
    
    .search-box {
      width: 100%;
      padding: 6px;
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      color: white;
      font-size: 12px;
      margin-bottom: 10px;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #444;
    }
    
    .section-title {
      font-size: 14px;
      font-weight: bold;
    }
    
    .add-btn {
      background: #0066cc;
      color: white;
      border: none;
      width: 20px;
      height: 20px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .add-btn:hover {
      background: #0077dd;
    }
  </style>
</head>
<body>
  <div class="campaign-interface">
    <!-- Left Sidebar -->
    <div class="left-sidebar">
      <div class="campaign-header">
        <div class="campaign-title" id="campaign-name">Loading...</div>
        <div class="campaign-system" id="campaign-system">Loading system...</div>
      </div>
      
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="maps">Maps</button>
        <button class="sidebar-tab" data-tab="assets">Assets</button>
        <button class="sidebar-tab" data-tab="settings">Settings</button>
      </div>
      
      <div class="sidebar-content">
        <!-- Maps Section -->
        <div class="content-section active" id="maps-section">
          <div class="section-header">
            <span class="section-title">Maps</span>
            <button class="add-btn" onclick="createNewMap()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search maps..." id="maps-search">
          <ul class="item-list" id="maps-list">
            <!-- Maps will be loaded here -->
          </ul>
        </div>
        
        
        <!-- Assets Section -->
        <div class="content-section" id="assets-section">
          <div class="section-header">
            <span class="section-title">Assets</span>
            <button class="add-btn" onclick="uploadAsset()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search assets...">
          <div class="input-group">
            <label>Asset Categories</label>
            <select id="asset-category-select">
              <option value="all">All</option>
              <option value="tokens">Tokens</option>
              <option value="background">Backgrounds</option>
              <option value="props">Props</option>
              <option value="audio">Audio</option>
            </select>
          </div>
          <ul class="item-list">
            <li class="item">
              <div class="item-name">Goblin Token</div>
              <div class="item-details">32x32px</div>
            </li>
            <li class="item">
              <div class="item-name">Dungeon Tiles</div>
              <div class="item-details">Tileset</div>
            </li>
          </ul>
        </div>
        
        <!-- Settings Section -->
        <div class="content-section" id="settings-section">
          <div class="section-header">
            <span class="section-title">Campaign Settings</span>
          </div>
          <div class="input-group">
            <label>Grid Size</label>
            <select id="grid-size">
              <option value="25">25px</option>
              <option value="50" selected>50px</option>
              <option value="75">75px</option>
              <option value="100">100px</option>
            </select>
          </div>
          <div class="input-group">
            <label>Grid Color</label>
            <input type="color" value="#ffffff" id="grid-color">
          </div>
          <div class="input-group">
            <label>Grid Opacity</label>
            <input type="range" min="0" max="100" value="10" id="grid-opacity">
          </div>
          <button class="btn primary" onclick="saveSettings()">Save Settings</button>
        </div>
      </div>
    </div>
    
    <!-- Main Canvas -->
    <div class="main-canvas">
      <button class="back-button" onclick="window.location.href='/campaigns'">← Back to Campaigns</button>
      
      <div class="canvas-toolbar">
        <div class="tool-group">
          <button class="tool-btn active" data-tool="select" title="Select">⚬</button>
          <button class="tool-btn" data-tool="move" title="Move">✋</button>
          <button class="tool-btn" data-tool="draw" title="Draw">✏</button>
          <button class="tool-btn" data-tool="measure" title="Measure">📏</button>
        </div>
        
        <div class="tool-group">
          <button class="tool-btn" data-tool="token" title="Add Token">👤</button>
          <button class="tool-btn" data-tool="light" title="Lighting">💡</button>
          <button class="tool-btn" data-tool="fog" title="Fog of War">🌫</button>
        </div>
        
        <div class="tool-group">
          <button class="tool-btn" data-tool="zoom-in" title="Zoom In">+</button>
          <button class="tool-btn" data-tool="zoom-out" title="Zoom Out">-</button>
          <button class="tool-btn" data-tool="zoom-fit" title="Fit to Screen">⚏</button>
        </div>
      </div>
      
      <div class="map-viewport" id="map-viewport">
        <div class="map-grid" id="map-grid">
          <!-- Layer system like Roll20 -->
          <div class="map-layer" id="map-layer" data-layer="map">
            <!-- Background images and map content -->
          </div>
          <div class="map-layer" id="walls-layer" data-layer="walls">
            <!-- Walls, doors, and lighting objects -->
          </div>
          <div class="map-layer" id="tokens-layer" data-layer="tokens">
            <!-- Player tokens and NPCs -->
          </div>
          <div class="map-layer" id="gm-layer" data-layer="gm">
            <!-- GM-only content, notes, hidden objects -->
          </div>
          <div class="map-layer" id="audio-layer" data-layer="audio">
            <!-- Audio sources and ambient sounds -->
          </div>
          <div class="map-layer" id="props-layer" data-layer="props">
            <!-- Props and decorative objects -->
          </div>
        </div>
        
        <!-- Layer Controls -->
         <div class="layer-controls">
           <button class="layer-btn active" data-layer="Map" data-target="map-layer" title="Map Layer">🗺️</button>
           <button class="layer-btn active" data-layer="Walls" data-target="walls-layer" title="Walls & Lighting">🧱</button>
           <button class="layer-btn active" data-layer="Tokens" data-target="tokens-layer" title="Tokens Layer">👤</button>
           <button class="layer-btn active" data-layer="GM" data-target="gm-layer" title="GM Layer">👁️</button>
           <button class="layer-btn active" data-layer="Audio" data-target="audio-layer" title="Audio Layer">🔊</button>
           <button class="layer-btn active" data-layer="Props" data-target="props-layer" title="Props Layer">🎭</button>
         </div>
        
        <!-- Map UI Overlays -->
        <div class="map-ui-overlay">
          <div class="zoom-indicator" id="zoom-indicator">100%</div>
          <div class="coordinates-indicator" id="coordinates-indicator">X: 0, Y: 0</div>
          <div class="selection-info" id="selection-info" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;"></div>
          <div class="help-toggle" id="help-toggle" onclick="toggleHelp()">?</div>
        </div>
        
        <!-- Help Panel -->
        <div class="help-panel" id="help-panel" style="display: none;">
          <div class="help-header">
            <span>Navigation Help</span>
            <button onclick="toggleHelp()">×</button>
          </div>
          <div class="help-content">
            <div class="help-section">
               <h4>Mouse Controls (Roll20 Style):</h4>
               <ul>
                 <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
                 <li><strong>Right Click + Drag:</strong> Pan map</li>
                 <li><strong>Left Click:</strong> Select/interact with elements</li>
               </ul>
             </div>
            <div class="help-section">
              <h4>Keyboard Shortcuts:</h4>
              <ul>
                <li><strong>+ / =:</strong> Zoom in</li>
                <li><strong>-:</strong> Zoom out</li>
                <li><strong>0:</strong> Fit to screen</li>
                <li><strong>Space:</strong> Select tool</li>
                <li><strong>1:</strong> Select Map layer</li>
                <li><strong>2:</strong> Select Walls layer</li>
                <li><strong>3:</strong> Select Tokens layer</li>
                <li><strong>4:</strong> Select GM layer</li>
                <li><strong>5:</strong> Select Audio layer</li>
                <li><strong>6:</strong> Select Props layer</li>
              </ul>
            </div>
            <div class="help-section">
              <h4>Layer System (Roll20 Style):</h4>
              <ul>
                <li><strong>🗺️ Map:</strong> Background images and terrain</li>
                <li><strong>🧱 Walls:</strong> Walls, doors, and lighting</li>
                <li><strong>👤 Tokens:</strong> Player characters and NPCs</li>
                <li><strong>👁️ GM:</strong> GM-only notes and objects</li>
                <li><strong>🔊 Audio:</strong> Sound effects and ambient audio</li>
                <li><strong>🎭 Props:</strong> Decorative objects and props</li>
                <li><strong>Left Click:</strong> Select active layer (exclusive)</li>
                <li><strong>Right Click:</strong> Toggle layer visibility</li>
                <li><strong>Keys 1-6:</strong> Quick layer selection</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Right Panel -->
    <div class="right-panel">
      <div class="panel-tabs">
        <button class="panel-tab active" data-panel="tokens">Tokens</button>
        <button class="panel-tab" data-panel="journal">Journal</button>
        <button class="panel-tab" data-panel="chat">Chat</button>
      </div>
      
      <div class="panel-content">
        <!-- Tokens Panel -->
        <div class="panel-section active" id="tokens-panel">
          <div class="section-header">
            <span class="section-title">Active Tokens</span>
          </div>
          <input type="text" class="search-box" placeholder="Search active tokens...">
          <ul class="item-list" id="tokens-list">
            <!-- Active tokens on the map will appear here dynamically -->
          </ul>
          <!-- Token Sheet Modal -->
          <div id="token-sheet-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; color:white; border-radius:8px; box-shadow:0 4px 24px rgba(0,0,0,0.7); z-index:10001; min-width:400px; max-width:600px; max-height:80vh; overflow-y:auto; padding:24px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
              <span id="token-sheet-modal-title" style="font-size:18px; font-weight:bold;">Token Sheet</span>
              <button onclick="closeTokenSheetModal()" style="background:none; border:none; color:white; font-size:20px; cursor:pointer;">×</button>
            </div>
            <form id="token-sheet-form" onsubmit="saveTokenSheet(event)">
              <input type="hidden" id="token-sheet-id">
              <input type="hidden" id="token-sheet-token-id">
              <div class="input-group">
                <label for="token-sheet-name">Name</label>
                <input type="text" id="token-sheet-name" required style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px;">
              </div>
              <!-- Dynamic content will be inserted here -->
              <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:18px;">
                <button type="button" onclick="deleteTokenSheet()" id="token-sheet-delete-btn" style="background:#c0392b; color:white; border:none; border-radius:3px; padding:6px 14px; display:none;">Delete</button>
                <button type="submit" style="background:#0066cc; color:white; border:none; border-radius:3px; padding:6px 14px;">Save</button>
              </div>
            </form>
          </div>
        </div>
        
        <!-- Journal Panel -->
        <div class="panel-section" id="journal-panel">
          <div class="section-header">
            <span class="section-title">Journal</span>
            <button class="add-btn" onclick="addJournalEntry()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search journal...">
          <ul class="item-list">
            <li class="item">
              <div class="item-name">Session Notes</div>
              <div class="item-details">Last updated: Today</div>
            </li>
            <li class="item">
              <div class="item-name">NPC: Tavern Keeper</div>
              <div class="item-details">Character sheet</div>
            </li>
          </ul>
        </div>
        
        <!-- Chat Panel -->
        <div class="panel-section" id="chat-panel">
          <div class="section-header">
            <span class="section-title">Chat</span>
          </div>
          <div id="chat-messages" style="height: 300px; overflow-y: auto; background: #1a1a1a; padding: 10px; border-radius: 3px; margin-bottom: 10px;">
            <div style="margin-bottom: 10px; padding: 5px; background: #333; border-radius: 3px;">
              <strong>GM:</strong> Welcome to the campaign!
            </div>
            <div style="margin-bottom: 10px; padding: 5px; background: #2a4a2a; border-radius: 3px;">
              <strong>Player1:</strong> Ready to start!
            </div>
          </div>
          <div style="display: flex; gap: 5px;">
            <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 6px; background: #333; border: 1px solid #555; border-radius: 3px; color: white;">
            <button class="btn primary" onclick="sendChatMessage()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // ===== PFVTT MAP SYSTEM - ENHANCED VERSION =====
    // Robust error handling and validation
    // ===== TOKEN SHEET LOGIC =====
    async function loadActiveTokensAndSheets() {
      const mapId = MapState.getCurrentMapId();
      if (!mapId) {
        Logger.warn('No map ID available for loading tokens');
        return;
      }
      
      try {
        Logger.info(`Loading tokens for map ID: ${mapId}`);
        
        // Load tokens
        const tokensRes = await fetch(`/api/map-tokens?map_id=${encodeURIComponent(mapId)}`);
        if (!tokensRes.ok) {
          throw new Error(`Failed to fetch tokens: ${tokensRes.status} ${tokensRes.statusText}`);
        }
        
        const tokensText = await tokensRes.text();
        Logger.debug('Tokens response text:', tokensText);
        
        let tokensData;
        try {
          tokensData = JSON.parse(tokensText);
        } catch (parseError) {
          Logger.error('Failed to parse tokens JSON response', parseError);
          Logger.error('Response text was:', tokensText);
          throw new Error('Invalid JSON response from tokens endpoint');
        }
        
        const tokens = tokensData.tokens || [];
        Logger.info(`Loaded ${tokens.length} tokens`);
        
        // Load token sheets
        const sheetsRes = await fetch(`/api/token-sheets?map_id=${encodeURIComponent(mapId)}`);
        if (!sheetsRes.ok) {
          throw new Error(`Failed to fetch token sheets: ${sheetsRes.status} ${sheetsRes.statusText}`);
        }
        
        const sheetsText = await sheetsRes.text();
        Logger.debug('Sheets response text:', sheetsText);
        
        let sheetsData;
        try {
          sheetsData = JSON.parse(sheetsText);
        } catch (parseError) {
          Logger.error('Failed to parse sheets JSON response', parseError);
          Logger.error('Response text was:', sheetsText);
          throw new Error('Invalid JSON response from token sheets endpoint');
        }
        
        const sheets = sheetsData.sheets || [];
        Logger.info(`Loaded ${sheets.length} token sheets`);
        
        // Update UI
        const list = document.getElementById('tokens-list');
        if (!list) {
          Logger.error('tokens-list element not found');
          return;
        }
        
        list.innerHTML = '';
        
        if (tokens.length === 0) {
          const li = document.createElement('li');
          li.className = 'item';
          li.innerHTML = `<div class='item-name' style='color: #999; font-style: italic;'>No tokens on this map</div>`;
          list.appendChild(li);
        } else {
          tokens.forEach(token => {
            const li = document.createElement('li');
            li.className = 'item';
            const tokenSheet = sheets.find(s => s.map_token_id === token.id) || null;
            li.innerHTML = `<div class='item-name'>${escapeHtml(token.name||'Token')}</div><div class='item-details'><button style='background:#444; color:white; border:none; border-radius:3px; padding:2px 8px; cursor:pointer;' onclick='openTokenSheetModal(${JSON.stringify(token)}, ${JSON.stringify(tokenSheet)})'>Sheet</button></div>`;
            list.appendChild(li);
          });
        }
        
        Logger.info('Tokens and sheets loaded successfully');
        
      } catch (e) { 
        Logger.error('Failed to load tokens or sheets', e);
        
        // Show user-friendly message in the tokens list
        const list = document.getElementById('tokens-list');
        if (list) {
          list.innerHTML = `<li class='item'><div class='item-name' style='color: #dc3545;'>Error loading tokens</div><div class='item-details' style='color: #999; font-size: 11px;'>${escapeHtml(e.message)}</div></li>`;
        }
      }
    }
    async function openTokenSheetModal(token, sheet) {
      // If no sheet exists, auto-create one based on campaign game rules
      if (!sheet) {
        try {
          Logger.info(`Auto-creating sheet for token ${token.id} (${token.name})`);
          
          const response = await fetch('/api/token-sheets/auto-create', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              map_token_id: token.id,
              token_name: token.name || 'Token'
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.success) {
              Logger.info(`Auto-created sheet with ID ${result.id} for system: ${result.system}`);
              
              // Create a sheet object with the new data
              sheet = {
                id: result.id,
                map_token_id: token.id,
                sheet_json: result.sheet_json,
                system: result.system
              };
              
              // Refresh the tokens list to show the new sheet
              loadActiveTokensAndSheets();
            } else {
              Logger.error('Failed to auto-create sheet:', result.error);
              alert('Failed to create character sheet: ' + result.error);
              return;
            }
          } else if (response.status === 409) {
            // Sheet already exists, reload and try again
            Logger.info('Sheet already exists, reloading...');
            await loadActiveTokensAndSheets();
            return;
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          Logger.error('Error auto-creating sheet:', error);
          alert('Failed to create character sheet: ' + error.message);
          return;
        }
      }
      
      document.getElementById('token-sheet-modal').style.display = 'block';
      document.getElementById('token-sheet-modal-title').textContent = sheet ? 'Edit Token Sheet' : 'Create Token Sheet';
      document.getElementById('token-sheet-id').value = sheet ? sheet.id : '';
      document.getElementById('token-sheet-token-id').value = token.id;
      
      // Parse sheet_json if it exists
      let sheetData = {};
      if (sheet && sheet.sheet_json) {
        try {
          sheetData = typeof sheet.sheet_json === 'string' ? JSON.parse(sheet.sheet_json) : sheet.sheet_json;
        } catch (e) {
          Logger.warn('Failed to parse sheet JSON', e);
        }
      }
      
      // Display the sheet in a more user-friendly format
      displayDynamicSheet(sheetData, token, sheet ? sheet.system : null);
      
      document.getElementById('token-sheet-delete-btn').style.display = sheet ? 'inline-block' : 'none';
    }
    function closeTokenSheetModal() {
      document.getElementById('token-sheet-modal').style.display = 'none';
    }
    async function saveTokenSheet(e) {
      e.preventDefault();
      const id = document.getElementById('token-sheet-id').value;
      const token_id = document.getElementById('token-sheet-token-id').value;
      const name = document.getElementById('token-sheet-name').value;
      const map_id = MapState.getCurrentMapId();
      
      // Collect data from dynamic form fields
      const sheetJson = { name: name };
      
      // Check if we have dynamic fields (system-specific sheet)
      const dynamicContainer = document.querySelector('.dynamic-sheet-content');
      if (dynamicContainer) {
        // Collect all data-field inputs
        const fieldInputs = dynamicContainer.querySelectorAll('[data-field]');
        
        fieldInputs.forEach(input => {
          const fieldPath = input.getAttribute('data-field');
          const value = input.type === 'number' ? (parseFloat(input.value) || 0) : input.value;
          
          // Set nested object properties (e.g., "attributes.strength")
          const pathParts = fieldPath.split('.');
          let current = sheetJson;
          
          for (let i = 0; i < pathParts.length - 1; i++) {
            if (!current[pathParts[i]]) {
              current[pathParts[i]] = {};
            }
            current = current[pathParts[i]];
          }
          
          current[pathParts[pathParts.length - 1]] = value;
        });
      } else {
        // Fallback to content field for generic sheets
        const contentField = document.getElementById('token-sheet-content');
        if (contentField) {
          sheetJson.content = contentField.value;
        }
      }
      
      try {
        if (id) {
          await fetch(`/api/token-sheets/${id}`, {method:'PUT', headers:{'Content-Type':'application/json'}, body:JSON.stringify({sheet_json: sheetJson, actor_id: null})});
        } else {
          await fetch(`/api/token-sheets`, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({map_token_id: token_id, actor_id: null, sheet_json: sheetJson})});
        }
        closeTokenSheetModal();
        loadActiveTokensAndSheets();
      } catch (e) { Logger.error('Failed to save token sheet', e); }
    }
    async function deleteTokenSheet() {
      const id = document.getElementById('token-sheet-id').value;
      if (!id) return;
      if (!confirm('Delete this token sheet?')) return;
      try {
        await fetch(`/api/token-sheets/${id}`, {method:'DELETE'});
        closeTokenSheetModal();
        loadActiveTokensAndSheets();
      } catch (e) { Logger.error('Failed to delete token sheet', e); }
    }
    function escapeHtml(str) {
      return String(str).replace(/[&<>\"]/g, function(s) { return ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'})[s]; });
    }
    
    function displayDynamicSheet(sheetData, token, system) {
      const nameField = document.getElementById('token-sheet-name');
      const contentField = document.getElementById('token-sheet-content');
      
      // Set the character name
      nameField.value = sheetData.name || token.name || 'Token';
      
      // Create dynamic form based on system
      const formContainer = document.getElementById('token-sheet-form');
      
      // Remove existing dynamic content (keep hidden fields and name field)
      const existingDynamic = formContainer.querySelector('.dynamic-sheet-content');
      if (existingDynamic) {
        existingDynamic.remove();
      }
      
      // Create dynamic content container
      const dynamicContainer = document.createElement('div');
      dynamicContainer.className = 'dynamic-sheet-content';
      
      if (system && sheetData.attributes) {
        // Display system-specific fields
        dynamicContainer.innerHTML = createSystemSpecificForm(sheetData, system);
      } else {
        // Fallback to generic content field
        dynamicContainer.innerHTML = `
          <div class="input-group">
            <label for="token-sheet-content">Content</label>
            <textarea id="token-sheet-content" rows="8" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px;">${escapeHtml(sheetData.content || '')}</textarea>
          </div>
        `;
      }
      
      // Insert dynamic content after the name field
      const nameGroup = nameField.closest('.input-group');
      nameGroup.parentNode.insertBefore(dynamicContainer, nameGroup.nextSibling);
    }
    
    function createSystemSpecificForm(sheetData, system) {
      let html = '';
      
      // Add system indicator
      html += `<div style="margin-bottom: 12px; padding: 6px; background: #444; border-radius: 3px; font-size: 12px; color: #ccc;">System: ${escapeHtml(system)}</div>`;
      
      if (sheetData.attributes) {
        // Core attributes section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Attributes</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">';
        
        Object.entries(sheetData.attributes).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1);
          html += `
            <div class="input-group" style="margin-bottom: 4px;">
              <label style="font-size: 12px; color: #ccc;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="attributes.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:4px; font-size: 12px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      if (sheetData.skills && Object.keys(sheetData.skills).length > 0) {
        // Skills section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Skills</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">';
        
        Object.entries(sheetData.skills).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
          html += `
            <div style="display: flex; align-items: center; gap: 4px;">
              <label style="font-size: 11px; color: #ccc; flex: 1;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="skills.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:50px; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:2px; font-size: 11px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      if (sheetData.combat) {
        // Combat stats section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Combat</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">';
        
        Object.entries(sheetData.combat).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
          html += `
            <div class="input-group" style="margin-bottom: 4px;">
              <label style="font-size: 12px; color: #ccc;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="combat.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:4px; font-size: 12px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      // Notes section
      html += `
        <div class="input-group">
          <label style="font-size: 12px; color: #ccc;">Notes</label>
          <textarea data-field="notes" rows="4" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px; font-size: 12px;">${escapeHtml(sheetData.notes || '')}</textarea>
        </div>
      `;
      
      return html;
    }

    
    // Global state management with validation
    const MapState = {
      campaignId: null,
      currentMapId: null,
      currentTool: 'select',
      currentLayer: 'tokens',
      zoom: 1,
      pan: { x: 0, y: 0 },
      isDragging: false,
      lastMouse: { x: 0, y: 0 },
      gridSize: 50,
      assets: [],
      campaignSettings: {},
      
      // Validation methods
      isValidCampaignId(id) {
        return id && typeof id === 'string' && id.trim().length > 0;
      },
      
      isValidCoordinates(x, y) {
        return typeof x === 'number' && typeof y === 'number' && 
               !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y);
      },
      
      isValidZoom(zoom) {
        return typeof zoom === 'number' && zoom >= 0.1 && zoom <= 5;
      },
      
      // Safe getters with fallbacks
      getCampaignId() {
        if (!this.campaignId) {
          this.campaignId = sessionStorage.getItem('current_campaign_id') || 
                           new URLSearchParams(window.location.search).get('campaign_id');
        }
        return this.campaignId;
      },
      
      getCurrentMapId() {
        if (!this.currentMapId) {
          this.currentMapId = sessionStorage.getItem('current_map_id');
        }
        return this.currentMapId;
      }
    };
    
    // Enhanced error handling and logging
    const Logger = {
      error(message, error = null) {
        console.error(`[PFVTT Map Error] ${message}`, error);
        this.showUserError(message);
      },
      
      warn(message) {
        console.warn(`[PFVTT Map Warning] ${message}`);
      },
      
      info(message) {
        console.info(`[PFVTT Map Info] ${message}`);
      },
      
      debug(message, data = null) {
        if (window.DEBUG_MODE) {
          console.log(`[PFVTT Map Debug] ${message}`, data);
        }
      },
      
      showUserError(message) {
        // Create a non-blocking error notification
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed; top: 20px; right: 20px; z-index: 10000;
          background: #dc3545; color: white; padding: 12px 16px;
          border-radius: 4px; max-width: 300px; font-size: 14px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 5000);
      }
    };
    
    // Initialize and validate campaign
    function initializeCampaign() {
      try {
        const campaignId = MapState.getCampaignId();
        
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('No valid campaign selected');
          window.location.href = '/campaigns';
          return false;
        }
        
        Logger.info(`Initializing campaign: ${campaignId}`);
        return true;
      } catch (error) {
        Logger.error('Failed to initialize campaign', error);
        return false;
      }
    }
    
    // Initialize campaign on load
    if (!initializeCampaign()) {
      // Stop execution if campaign initialization fails
      throw new Error('Campaign initialization failed');
    }
    
    // Tab switching for sidebar
    document.querySelectorAll('.sidebar-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Remove active class from all tabs and sections
        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding section
        this.classList.add('active');
        document.getElementById(this.dataset.tab + '-section').classList.add('active');
      });
    });
    
    // Tab switching for right panel
    document.querySelectorAll('.panel-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Remove active class from all tabs and sections
        document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding section
        this.classList.add('active');
        document.getElementById(this.dataset.panel + '-panel').classList.add('active');
      });
    });
    
    // ===== ENHANCED TOOL MANAGEMENT SYSTEM =====
    
    const ToolManager = {
      currentTool: 'select',
      validTools: ['select', 'move', 'measure', 'draw', 'erase', 'token'],
      zoomTools: ['zoom-in', 'zoom-out', 'zoom-fit'],
      toolCursors: {
        'select': 'grab',
        'move': 'move',
        'measure': 'crosshair',
        'draw': 'crosshair',
        'erase': 'crosshair',
        'token': 'pointer'
      },
      
      isValidTool(tool) {
        return this.validTools.includes(tool) || this.zoomTools.includes(tool);
      },
      
      isZoomTool(tool) {
        return this.zoomTools.includes(tool);
      },
      
      selectTool(tool) {
        try {
          if (!this.isValidTool(tool)) {
            Logger.warn(`Invalid tool: ${tool}`);
            return false;
          }
          
          // Handle zoom tools separately
          if (this.isZoomTool(tool)) {
            this.handleZoomTool(tool);
            return true;
          }
          
          // Remove active class from all tools
          document.querySelectorAll('.tool-btn').forEach(btn => {
            try {
              btn.classList.remove('active');
            } catch (error) {
              Logger.warn('Error removing active class from tool button', error);
            }
          });
          
          // Add active class to selected tool
          const selectedTool = document.querySelector(`[data-tool="${tool}"]`);
          if (selectedTool) {
            selectedTool.classList.add('active');
          }
          
          // Update current tool in all places for compatibility
          this.currentTool = tool;
          MapState.currentTool = tool;
          window.currentTool = tool; // Legacy compatibility
          
          // Update cursor
          this.updateCursor();
          
          // Tool-specific initialization
          this.onToolChange(tool);
          
          // Save current tool in session
          try {
            sessionStorage.setItem('current_map_tool', tool);
          } catch (error) {
            Logger.warn('Failed to save tool to session storage', error);
          }
          
          Logger.debug(`Selected tool: ${tool}`);
          return true;
          
        } catch (error) {
          Logger.error(`Failed to select tool: ${tool}`, error);
          return false;
        }
      },
      
      handleZoomTool(tool) {
        try {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            Logger.error('Map viewport not found');
            return false;
          }
          
          const rect = viewport.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          handleZoom(tool, centerX, centerY);
          return true;
        } catch (error) {
          Logger.error(`Failed to handle zoom tool: ${tool}`, error);
          return false;
        }
      },
      
      updateCursor() {
        try {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            Logger.warn('Map viewport not found for cursor update');
            return;
          }
          
          const cursor = this.toolCursors[this.currentTool] || 'grab';
          viewport.style.cursor = cursor;
        } catch (error) {
          Logger.warn('Failed to update cursor', error);
        }
      },
      
      onToolChange(tool) {
        // Tool-specific logic
        switch(tool) {
          case 'measure':
            this.initializeMeasureTool();
            break;
          case 'draw':
            this.initializeDrawTool();
            break;
          case 'erase':
            this.initializeEraseTool();
            break;
          case 'token':
            this.initializeTokenTool();
            break;
        }
      },
      
      initializeMeasureTool() {
        Logger.debug('Initializing measure tool');
        // Clear any existing measurements
        this.clearMeasurements();
      },
      
      initializeDrawTool() {
        Logger.debug('Initializing draw tool');
        // Set up drawing context
      },
      
      initializeEraseTool() {
        Logger.debug('Initializing erase tool');
        // Set up erase mode
      },
      
      initializeTokenTool() {
        Logger.debug('Initializing token tool');
        // Set up token placement mode
      },
      
      clearMeasurements() {
        try {
          // Remove any existing measurement overlays
          document.querySelectorAll('.measurement-line').forEach(line => {
            line.remove();
          });
        } catch (error) {
          Logger.warn('Failed to clear measurements', error);
        }
      },
      
      // Load saved tool from session
      loadSavedTool() {
        try {
          const savedTool = sessionStorage.getItem('current_map_tool');
          if (savedTool && this.isValidTool(savedTool) && !this.isZoomTool(savedTool)) {
            this.selectTool(savedTool);
          } else {
            this.selectTool('select'); // Default tool
          }
        } catch (error) {
          Logger.warn('Failed to load saved tool, using default', error);
          this.selectTool('select');
        }
      }
    };
    
    // Enhanced tool selection event listeners
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const tool = this.dataset.tool;
        ToolManager.selectTool(tool);
      });
    });
    
    // Legacy function wrapper for backward compatibility
    function updateCursor() {
      ToolManager.updateCursor();
    }
    
    // ===== ENHANCED MAP NAVIGATION SYSTEM =====
    
    // Enhanced map state with validation
    const MapNavigation = {
      currentZoom: 1,
      panX: 0,
      panY: 0,
      isDragging: false,
      lastMouseX: 0,
      lastMouseY: 0,
      minZoom: 0.1,
      maxZoom: 5,
      zoomStep: 1.2,
      
      // Validation methods
      isValidZoom(zoom) {
        return typeof zoom === 'number' && zoom >= this.minZoom && zoom <= this.maxZoom && !isNaN(zoom) && isFinite(zoom);
      },
      
      isValidPan(x, y) {
        return typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y);
      },
      
      // Safe setters with validation
      setZoom(zoom) {
        if (this.isValidZoom(zoom)) {
          this.currentZoom = zoom;
          MapState.zoom = zoom;
          return true;
        }
        Logger.warn(`Invalid zoom value: ${zoom}`);
        return false;
      },
      
      setPan(x, y) {
        if (this.isValidPan(x, y)) {
          this.panX = x;
          this.panY = y;
          MapState.pan.x = x;
          MapState.pan.y = y;
          return true;
        }
        Logger.warn(`Invalid pan values: (${x}, ${y})`);
        return false;
      },
      
      // Enhanced zoom handling with error checking
      handleZoom(action, mouseX = null, mouseY = null) {
        try {
          const mapGrid = document.getElementById('map-grid');
          const viewport = document.getElementById('map-viewport');
          
          if (!mapGrid || !viewport) {
            Logger.error('Map elements not found for zoom operation');
            return false;
          }
          
          const oldZoom = this.currentZoom;
          let newZoom = oldZoom;
          
          switch(action) {
            case 'zoom-in':
              newZoom = Math.min(oldZoom * this.zoomStep, this.maxZoom);
              break;
            case 'zoom-out':
              newZoom = Math.max(oldZoom / this.zoomStep, this.minZoom);
              break;
            case 'zoom-fit':
              newZoom = 1;
              this.setPan(0, 0);
              break;
            default:
              Logger.warn(`Unknown zoom action: ${action}`);
              return false;
          }
          
          if (!this.setZoom(newZoom)) {
            return false;
          }
          
          // Zoom towards mouse position if provided
          if (mouseX !== null && mouseY !== null && action !== 'zoom-fit') {
            try {
              const rect = viewport.getBoundingClientRect();
              const centerX = rect.width / 2;
              const centerY = rect.height / 2;
              
              const zoomFactor = newZoom / oldZoom;
              const newPanX = (this.panX - (mouseX - centerX)) * zoomFactor + (mouseX - centerX);
              const newPanY = (this.panY - (mouseY - centerY)) * zoomFactor + (mouseY - centerY);
              
              this.setPan(newPanX, newPanY);
            } catch (error) {
              Logger.warn('Failed to calculate zoom-to-point, using center zoom', error);
            }
          }
          
          this.updateMapTransform();
          Logger.debug(`Zoom changed from ${oldZoom.toFixed(2)} to ${newZoom.toFixed(2)}`);
          return true;
          
        } catch (error) {
          Logger.error(`Failed to handle zoom: ${action}`, error);
          return false;
        }
      },
      
      // Enhanced transform update with error handling
      updateMapTransform() {
        try {
          const mapGrid = document.getElementById('map-grid');
          if (!mapGrid) {
            Logger.error('Map grid not found for transform update');
            return false;
          }
          
          // Validate current values before applying
          if (!this.isValidZoom(this.currentZoom) || !this.isValidPan(this.panX, this.panY)) {
            Logger.error('Invalid transform values, resetting to defaults');
            this.currentZoom = 1;
            this.panX = 0;
            this.panY = 0;
          }
          
          mapGrid.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.currentZoom})`;
          
          // Update zoom indicator
          this.updateZoomIndicator();
          
          // Update coordinates indicator if mouse is over viewport
          this.updateCoordinatesIndicator();
          
          return true;
          
        } catch (error) {
          Logger.error('Failed to update map transform', error);
          return false;
        }
      },
      
      updateZoomIndicator() {
        try {
          const zoomIndicator = document.getElementById('zoom-indicator');
          if (zoomIndicator) {
            zoomIndicator.textContent = Math.round(this.currentZoom * 100) + '%';
          }
        } catch (error) {
          Logger.warn('Failed to update zoom indicator', error);
        }
      },
      
      updateCoordinatesIndicator() {
        try {
          const coordsIndicator = document.getElementById('coordinates-indicator');
          if (coordsIndicator && coordsIndicator.dataset.lastMouseX) {
            const mouseX = parseFloat(coordsIndicator.dataset.lastMouseX);
            const mouseY = parseFloat(coordsIndicator.dataset.lastMouseY);
            
            if (!isNaN(mouseX) && !isNaN(mouseY)) {
              const mapCoords = screenToMapCoordinates(mouseX, mouseY);
              const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
              
              coordsIndicator.textContent = `Map: ${Math.round(mapCoords.x)}, ${Math.round(mapCoords.y)} | Grid: ${gridCoords.x}, ${gridCoords.y}`;
            }
          }
        } catch (error) {
          Logger.warn('Failed to update coordinates indicator', error);
        }
      },
      
      // Pan handling with validation
      startDrag(mouseX, mouseY) {
        if (this.isValidPan(mouseX, mouseY)) {
          this.isDragging = true;
          this.lastMouseX = mouseX;
          this.lastMouseY = mouseY;
          MapState.isDragging = true;
          MapState.lastMouse.x = mouseX;
          MapState.lastMouse.y = mouseY;
          return true;
        }
        return false;
      },
      
      updateDrag(mouseX, mouseY) {
        if (!this.isDragging || !this.isValidPan(mouseX, mouseY)) {
          return false;
        }
        
        try {
          const deltaX = mouseX - this.lastMouseX;
          const deltaY = mouseY - this.lastMouseY;
          
          const newPanX = this.panX + deltaX;
          const newPanY = this.panY + deltaY;
          
          if (this.setPan(newPanX, newPanY)) {
            this.updateMapTransform();
            this.lastMouseX = mouseX;
            this.lastMouseY = mouseY;
            return true;
          }
        } catch (error) {
          Logger.warn('Failed to update drag', error);
        }
        
        return false;
      },
      
      endDrag() {
        this.isDragging = false;
        MapState.isDragging = false;
      },
      
      // Reset to default state
      reset() {
        this.setZoom(1);
        this.setPan(0, 0);
        this.endDrag();
        this.updateMapTransform();
        Logger.info('Map navigation reset to default state');
      }
    };
    
    // Legacy variables for backward compatibility
    let currentZoom = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let currentTool = 'select';
    let currentMapId = sessionStorage.getItem('current_map_id') || null;
    
    // Legacy function wrappers for backward compatibility
    function handleZoom(action, mouseX = null, mouseY = null) {
      const result = MapNavigation.handleZoom(action, mouseX, mouseY);
      // Update legacy variables
      currentZoom = MapNavigation.currentZoom;
      panX = MapNavigation.panX;
      panY = MapNavigation.panY;
      return result;
    }
    
    function updateMapTransform() {
      const result = MapNavigation.updateMapTransform();
      // Update legacy variables
      currentZoom = MapNavigation.currentZoom;
      panX = MapNavigation.panX;
      panY = MapNavigation.panY;
      return result;
    }
    
    // ===== ENHANCED COORDINATE SYSTEM - ROLL20 INSPIRED =====
    
    const CoordinateSystem = {
      defaultGridSize: 50,
      
      // Validation methods
      isValidCoordinate(value) {
        return typeof value === 'number' && !isNaN(value) && isFinite(value);
      },
      
      isValidCoordinates(x, y) {
        return this.isValidCoordinate(x) && this.isValidCoordinate(y);
      },
      
      isValidGridSize(size) {
        return typeof size === 'number' && size > 0 && size <= 200 && !isNaN(size) && isFinite(size);
      },
      
      // Safe grid size getter
      getGridSize() {
        try {
          const size = MapState.campaignSettings?.gridSize || 
                      window.campaignSettings?.gridSize || 
                      this.defaultGridSize;
          
          return this.isValidGridSize(size) ? size : this.defaultGridSize;
        } catch (error) {
          Logger.warn('Failed to get grid size, using default', error);
          return this.defaultGridSize;
        }
      },
      
      // Enhanced transformation matrix with validation
      getGridTransformMatrix() {
        try {
          // Get current transformation values with fallbacks
          const scale = MapNavigation.currentZoom || currentZoom || 1;
          const translateX = MapNavigation.panX || panX || 0;
          const translateY = MapNavigation.panY || panY || 0;
          
          // Validate transformation values
          if (!this.isValidCoordinate(scale) || !this.isValidCoordinates(translateX, translateY)) {
            Logger.warn('Invalid transformation values, using defaults');
            return {
              scale: 1,
              translateX: 0,
              translateY: 0
            };
          }
          
          return {
            scale: scale,
            translateX: translateX,
            translateY: translateY
          };
        } catch (error) {
          Logger.error('Failed to get transform matrix', error);
          return {
            scale: 1,
            translateX: 0,
            translateY: 0
          };
        }
      },
      
      // Enhanced screen to map coordinate conversion
      screenToMapCoordinates(screenX, screenY) {
        try {
          if (!this.isValidCoordinates(screenX, screenY)) {
            Logger.warn(`Invalid screen coordinates: (${screenX}, ${screenY})`);
            return { x: 0, y: 0 };
          }
          
          const viewport = document.getElementById('map-viewport');
          const mapGrid = document.getElementById('map-grid');
          if (!viewport || !mapGrid) {
            Logger.error('Map viewport or grid not found for coordinate conversion');
            return { x: 0, y: 0 };
          }
          
          // Get transformation matrix
          const transform = this.getGridTransformMatrix();
          
          // Account for map-grid positioning:
          // map-grid is positioned at 50% of viewport with -1000px margin offset
          const viewportRect = viewport.getBoundingClientRect();
          const gridOffsetX = viewport.clientWidth / 2 - 1000;
          const gridOffsetY = viewport.clientHeight / 2 - 1000;
          
          // Adjust screen coordinates to account for grid offset
          const adjustedScreenX = screenX - gridOffsetX;
          const adjustedScreenY = screenY - gridOffsetY;
          
          // Reverse the transformation to get map coordinates
          // Since map-grid has transform-origin: 0 0, we need to account for this
          const mapX = (adjustedScreenX - transform.translateX) / transform.scale;
          const mapY = (adjustedScreenY - transform.translateY) / transform.scale;
          
          if (!this.isValidCoordinates(mapX, mapY)) {
            Logger.warn(`Invalid calculated map coordinates: (${mapX}, ${mapY})`);
            return { x: 0, y: 0 };
          }
          
          return { x: mapX, y: mapY };
        } catch (error) {
          Logger.error('Failed to convert screen to map coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced map to grid coordinate conversion
      mapToGridCoordinates(mapX, mapY) {
        try {
          if (!this.isValidCoordinates(mapX, mapY)) {
            Logger.warn(`Invalid map coordinates: (${mapX}, ${mapY})`);
            return { x: 0, y: 0 };
          }
          
          const gridSize = this.getGridSize();
          
          // Convert map coordinates to grid cell coordinates
          // Use Math.floor for consistent snapping behavior
          const gridX = Math.floor(mapX / gridSize);
          const gridY = Math.floor(mapY / gridSize);
          
          return { x: gridX, y: gridY };
        } catch (error) {
          Logger.error('Failed to convert map to grid coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced grid to map coordinate conversion
      gridToMapCoordinates(gridX, gridY) {
        try {
          if (!this.isValidCoordinates(gridX, gridY)) {
            Logger.warn(`Invalid grid coordinates: (${gridX}, ${gridY})`);
            return { x: 0, y: 0 };
          }
          
          const gridSize = this.getGridSize();
          
          // Convert grid coordinates to map coordinates (center of cell)
          const mapX = gridX * gridSize + gridSize / 2;
          const mapY = gridY * gridSize + gridSize / 2;
          
          return { x: mapX, y: mapY };
        } catch (error) {
          Logger.error('Failed to convert grid to map coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced screen to grid coordinate conversion
      screenToGridCoordinates(screenX, screenY) {
        try {
          // Convert screen to map, then map to grid
          const mapCoords = this.screenToMapCoordinates(screenX, screenY);
          return this.mapToGridCoordinates(mapCoords.x, mapCoords.y);
        } catch (error) {
          Logger.error('Failed to convert screen to grid coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced grid cell to pixel center conversion
      gridCellToPixelCenter(gridCellX, gridCellY) {
        try {
          // This returns the map coordinate (pixel position within the map-grid)
          return this.gridToMapCoordinates(gridCellX, gridCellY);
        } catch (error) {
          Logger.error('Failed to convert grid cell to pixel center', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Snap coordinates to grid
      snapToGrid(mapX, mapY) {
        try {
          const gridCoords = this.mapToGridCoordinates(mapX, mapY);
          return this.gridToMapCoordinates(gridCoords.x, gridCoords.y);
        } catch (error) {
          Logger.error('Failed to snap to grid', error);
          return { x: mapX, y: mapY };
        }
      },
      
      // Distance calculation between two points
      calculateDistance(x1, y1, x2, y2) {
        try {
          if (!this.isValidCoordinates(x1, y1) || !this.isValidCoordinates(x2, y2)) {
            Logger.warn('Invalid coordinates for distance calculation');
            return 0;
          }
          
          const dx = x2 - x1;
          const dy = y2 - y1;
          return Math.sqrt(dx * dx + dy * dy);
        } catch (error) {
          Logger.error('Failed to calculate distance', error);
          return 0;
        }
      },
      
      // Grid distance calculation (in grid units)
      calculateGridDistance(gridX1, gridY1, gridX2, gridY2) {
        try {
          if (!this.isValidCoordinates(gridX1, gridY1) || !this.isValidCoordinates(gridX2, gridY2)) {
            Logger.warn('Invalid grid coordinates for distance calculation');
            return 0;
          }
          
          const dx = Math.abs(gridX2 - gridX1);
          const dy = Math.abs(gridY2 - gridY1);
          
          // Use Chebyshev distance for grid-based movement (D&D style)
          return Math.max(dx, dy);
        } catch (error) {
          Logger.error('Failed to calculate grid distance', error);
          return 0;
        }
      }
    };
    
    // Legacy function wrappers for backward compatibility
    function getGridTransformMatrix() {
      return CoordinateSystem.getGridTransformMatrix();
    }
    
    function screenToMapCoordinates(screenX, screenY) {
      return CoordinateSystem.screenToMapCoordinates(screenX, screenY);
    }
    
    function mapToGridCoordinates(mapX, mapY) {
      return CoordinateSystem.mapToGridCoordinates(mapX, mapY);
    }
    
    function gridToMapCoordinates(gridX, gridY) {
      return CoordinateSystem.gridToMapCoordinates(gridX, gridY);
    }
    
    function screenToGridCoordinates(screenX, screenY) {
      return CoordinateSystem.screenToGridCoordinates(screenX, screenY);
    }
    
    function gridCellToPixelCenter(gridCellX, gridCellY) {
      return CoordinateSystem.gridCellToPixelCenter(gridCellX, gridCellY);
    }
    
    // Initialize map navigation
    function initializeMapNavigation() {
      const viewport = document.getElementById('map-viewport');
      const mapGrid = document.getElementById('map-grid');
      
      // ===== ENHANCED WHEEL AND CLICK HANDLERS =====
      
      // Enhanced mouse wheel zoom with validation
      viewport.addEventListener('wheel', function(e) {
        try {
          e.preventDefault();
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for zoom');
            return;
          }
          
          // Determine zoom direction with validation
          if (typeof e.deltaY !== 'number' || isNaN(e.deltaY)) {
            Logger.warn('Invalid deltaY value for zoom');
            return;
          }
          
          const zoomAction = e.deltaY < 0 ? 'zoom-in' : 'zoom-out';
          
          if (MapNavigation.handleZoom(zoomAction, mouseX, mouseY)) {
            Logger.debug(`Mouse wheel zoom: ${zoomAction} at (${mouseX}, ${mouseY})`);
          }
          
        } catch (error) {
          Logger.error('Failed to handle wheel event', error);
        }
      });
      
      // ===== ENHANCED CLICK HANDLERS =====
      
      // Enhanced click handler for coordinate debugging
      viewport.addEventListener('click', function(e) {
        try {
          // Skip if clicking on a token or other interactive element
          if (e.target.classList.contains('map-asset') || e.target.closest('.map-asset')) {
            return;
          }
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for click debug');
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          const pixelCenter = CoordinateSystem.gridCellToPixelCenter(gridCoords.x, gridCoords.y);
          
          // Validate calculated coordinates
          if (!CoordinateSystem.isValidCoordinates(mapCoords.x, mapCoords.y) ||
              !CoordinateSystem.isValidCoordinates(gridCoords.x, gridCoords.y) ||
              !CoordinateSystem.isValidCoordinates(pixelCenter.x, pixelCenter.y)) {
            Logger.warn('Invalid calculated coordinates for click debug');
            return;
          }
          
          // Enhanced debug output
          const debugInfo = {
            mouse: { x: mouseX, y: mouseY },
            pan: { x: MapNavigation.panX, y: MapNavigation.panY },
            zoom: MapNavigation.currentZoom,
            map: { x: Math.round(mapCoords.x), y: Math.round(mapCoords.y) },
            grid: { x: gridCoords.x, y: gridCoords.y },
            pixelCenter: { x: pixelCenter.x, y: pixelCenter.y },
            transform: CoordinateSystem.getGridTransformMatrix()
          };
          
          Logger.debug('=== VIEWPORT CLICK DEBUG ===', debugInfo);
          
          // Add debug message to chat if function exists
          if (typeof addDebugMessageToChat === 'function') {
            addDebugMessageToChat(`Clicked grid coordinates: (${gridCoords.x}, ${gridCoords.y})`);
          }
          
        } catch (error) {
          Logger.error('Failed to handle viewport click event', error);
        }
      });
      
      // Enhanced click handler for map grid
      mapGrid.addEventListener('click', function(e) {
        try {
          // Skip if clicking on a token or other interactive element
          if (e.target.classList.contains('map-asset') || e.target.closest('.map-asset')) {
            return;
          }
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for map grid click debug');
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          const pixelCenter = CoordinateSystem.gridCellToPixelCenter(gridCoords.x, gridCoords.y);
          
          // Enhanced debug output
          const debugInfo = {
            mouse: { x: mouseX, y: mouseY },
            pan: { x: MapNavigation.panX, y: MapNavigation.panY },
            zoom: MapNavigation.currentZoom,
            map: { x: Math.round(mapCoords.x), y: Math.round(mapCoords.y) },
            grid: { x: gridCoords.x, y: gridCoords.y },
            pixelCenter: { x: pixelCenter.x, y: pixelCenter.y }
          };
          
          Logger.debug('=== MAP GRID CLICK DEBUG ===', debugInfo);
          
        } catch (error) {
          Logger.error('Failed to handle map grid click event', error);
        }
      });
      
      // ===== ENHANCED MOUSE EVENT HANDLERS =====
      
      // Enhanced mouse drag for panning (Roll20 style - right click drag)
      viewport.addEventListener('mousedown', function(e) {
        try {
          if (e.button === 2) { // Right mouse button
            e.preventDefault();
            
            if (MapNavigation.startDrag(e.clientX, e.clientY)) {
              viewport.style.cursor = 'grabbing';
              
              // Update legacy variables for compatibility
              isDragging = true;
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
              
              Logger.debug('Started map panning');
            }
          } else if (e.button === 0) { // Left mouse button
            // Check if clicking on a token
            const clickedToken = e.target.closest('[data-selectable="true"]');
            if (!clickedToken) {
              // Start selection box if not clicking on a token
              startSelectionBox(e);
            }
          }
        } catch (error) {
          Logger.error('Failed to handle mousedown event', error);
        }
      });
      
      // Enhanced mouse move handler
      viewport.addEventListener('mousemove', function(e) {
        try {
          // Handle dragging
          if (MapNavigation.isDragging) {
            if (MapNavigation.updateDrag(e.clientX, e.clientY)) {
              // Update legacy variables for compatibility
              const deltaX = e.clientX - lastMouseX;
              const deltaY = e.clientY - lastMouseY;
              panX += deltaX;
              panY += deltaY;
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
            }
          }
          
          // Update coordinates indicator
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          
          // Update coordinates indicator
          const coordsIndicator = document.getElementById('coordinates-indicator');
          if (coordsIndicator) {
            coordsIndicator.textContent = `Map: ${Math.round(mapCoords.x)}, ${Math.round(mapCoords.y)} | Grid: ${gridCoords.x}, ${gridCoords.y}`;
            
            // Store last mouse position for potential use
            coordsIndicator.dataset.lastMouseX = mouseX.toString();
            coordsIndicator.dataset.lastMouseY = mouseY.toString();
          }
          
        } catch (error) {
          Logger.warn('Failed to handle mousemove event', error);
        }
      });
      
      // Enhanced mouse move handler
      viewport.addEventListener('mousemove', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.updateDrag(e.clientX, e.clientY);
          } else if (isSelecting) {
            // Update selection box
            updateSelectionBox(e);
          }
        } catch (error) {
          Logger.error('Failed to handle mousemove event', error);
        }
      });
      
      // Enhanced mouse up handler
      viewport.addEventListener('mouseup', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.endDrag();
            ToolManager.updateCursor(); // Return to appropriate cursor
            
            // Update legacy variables for compatibility
            isDragging = false;
            
            Logger.debug('Ended map panning');
          } else if (isSelecting) {
            // End selection box
            endSelectionBox(e);
          }
        } catch (error) {
          Logger.error('Failed to handle mouseup event', error);
        }
      });
      
      // Enhanced mouse leave handler
      viewport.addEventListener('mouseleave', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.endDrag();
            ToolManager.updateCursor(); // Return to appropriate cursor
            
            // Update legacy variables for compatibility
            isDragging = false;
            
            Logger.debug('Map panning interrupted by mouse leave');
          }
        } catch (error) {
          Logger.error('Failed to handle mouseleave event', error);
        }
      });
      
      // Prevent context menu on right click
      viewport.addEventListener('contextmenu', function(e) {
        e.preventDefault();
      });
      
      // Update cursor based on current tool
      viewport.addEventListener('mouseenter', function() {
        updateCursor();
      });
      
      // ===== ENHANCED KEYBOARD SHORTCUTS =====
      
      // Enhanced keyboard shortcuts with validation and error handling
      document.addEventListener('keydown', function(e) {
        try {
          // Only handle shortcuts when not typing in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
            return;
          }
          
          // Validate event object
          if (!e || !e.key) {
            Logger.warn('Invalid keyboard event object');
            return;
          }
          
          const key = e.key.toLowerCase();
          
          switch(key) {
            case '+':
            case '=':
              e.preventDefault();
              try {
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Validate viewport dimensions
                if (!CoordinateSystem.isValidCoordinates(centerX, centerY)) {
                  Logger.warn('Invalid viewport center coordinates for zoom in');
                  return;
                }
                
                MapNavigation.handleZoom(1.2, centerX, centerY);
                Logger.debug('Keyboard zoom in triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom in shortcut', error);
              }
              break;
              
            case '-':
              e.preventDefault();
              try {
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Validate viewport dimensions
                if (!CoordinateSystem.isValidCoordinates(centerX, centerY)) {
                  Logger.warn('Invalid viewport center coordinates for zoom out');
                  return;
                }
                
                MapNavigation.handleZoom(0.8, centerX, centerY);
                Logger.debug('Keyboard zoom out triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom out shortcut', error);
              }
              break;
              
            case '0':
              e.preventDefault();
              try {
                ToolManager.selectTool('zoom-fit');
                Logger.debug('Keyboard zoom-fit triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom-fit shortcut', error);
              }
              break;
              
            case ' ':
              e.preventDefault();
              try {
                // Select tool (Roll20 style - space for select)
                ToolManager.selectTool('select');
                Logger.debug('Keyboard select tool triggered');
              } catch (error) {
                Logger.error('Failed to handle select tool shortcut', error);
              }
              break;
              
            case '1':
              e.preventDefault();
              try {
                ToolManager.selectTool('select');
                Logger.debug('Keyboard select tool (1) triggered');
              } catch (error) {
                Logger.error('Failed to handle select tool (1) shortcut', error);
              }
              break;
              
            case '2':
              e.preventDefault();
              try {
                ToolManager.selectTool('measure');
                Logger.debug('Keyboard measure tool triggered');
              } catch (error) {
                Logger.error('Failed to handle measure tool shortcut', error);
              }
              break;
              
            case '3':
              e.preventDefault();
              try {
                ToolManager.selectTool('draw');
                Logger.debug('Keyboard draw tool triggered');
              } catch (error) {
                Logger.error('Failed to handle draw tool shortcut', error);
              }
              break;
              
            case '4':
              e.preventDefault();
              try {
                ToolManager.selectTool('erase');
                Logger.debug('Keyboard erase tool triggered');
              } catch (error) {
                Logger.error('Failed to handle erase tool shortcut', error);
              }
              break;
              
            case '5':
              e.preventDefault();
              try {
                ToolManager.selectTool('token');
                Logger.debug('Keyboard token tool triggered');
              } catch (error) {
                Logger.error('Failed to handle token tool shortcut', error);
              }
              break;
              
            case 'escape':
              e.preventDefault();
              try {
                // Clear token selection first, then return to select tool
                if (selectedTokens.size > 0) {
                  clearTokenSelection();
                  Logger.debug('Keyboard escape - cleared token selection');
                } else {
                  // Cancel current operation or return to select tool
                  ToolManager.selectTool('select');
                  Logger.debug('Keyboard escape - returning to select tool');
                }
              } catch (error) {
                Logger.error('Failed to handle escape shortcut', error);
              }
              break;
              
            case 'arrowup':
            case 'arrowdown':
            case 'arrowleft':
            case 'arrowright':
              e.preventDefault();
              try {
                if (selectedTokens.size > 0) {
                  moveSelectedTokens(key);
                  Logger.debug('Moving selected tokens:', key);
                }
              } catch (error) {
                Logger.error('Failed to handle arrow key movement', error);
              }
              break;
              
            default:
              // No action for other keys
              break;
          }
          
        } catch (error) {
          Logger.error('Failed to handle keyboard shortcut', error);
        }
      });
    }
    
    // ===== ENHANCED CURSOR MANAGEMENT =====
    
    // Enhanced cursor management with validation and error handling
    function updateCursor() {
      try {
        const viewport = document.getElementById('map-viewport');
        if (!viewport) {
          Logger.warn('Viewport element not found for cursor update');
          return;
        }
        
        // Use ToolManager for cursor management if available
        if (typeof ToolManager !== 'undefined' && ToolManager.updateCursor) {
          ToolManager.updateCursor();
          return;
        }
        
        // Fallback to legacy cursor management
        const tool = currentTool || 'select';
        
        switch(tool) {
          case 'draw':
            viewport.style.cursor = 'crosshair';
            break;
          case 'measure':
            viewport.style.cursor = 'crosshair';
            break;
          case 'token':
            viewport.style.cursor = 'pointer';
            break;
          case 'erase':
            viewport.style.cursor = 'crosshair';
            break;
          case 'zoom-in':
            viewport.style.cursor = 'zoom-in';
            break;
          case 'zoom-out':
            viewport.style.cursor = 'zoom-out';
            break;
          default:
            viewport.style.cursor = 'grab'; // Roll20 style - always ready to pan
        }
        
        Logger.debug(`Cursor updated to: ${viewport.style.cursor} for tool: ${tool}`);
        
      } catch (error) {
        Logger.error('Failed to update cursor', error);
      }
    }
    
    // ===== ENHANCED CAMPAIGN MANAGEMENT =====
    
    // Enhanced campaign info loading with validation and error handling
    async function loadCampaignInfo() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('Invalid campaign ID for loading campaign info', { campaignId });
          return;
        }
        
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        if (!user) {
          Logger.error('No user found in storage for campaign info loading');
          return;
        }
        
        Logger.debug('Loading campaign info', { campaignId, user });
        
        const response = await fetch(`http://localhost:8080/api/campaigns?username=${encodeURIComponent(user)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !data.success) {
          throw new Error('Invalid response format or request failed');
        }
        
        if (!Array.isArray(data.campaigns)) {
          Logger.warn('No campaigns array in response');
          return;
        }
        
        const campaign = data.campaigns.find(c => c && c.id == campaignId);
        if (!campaign) {
          Logger.warn('Campaign not found in user campaigns', { campaignId });
          return;
        }
        
        // Update UI elements with validation
        const campaignNameEl = document.getElementById('campaign-name');
        const campaignSystemEl = document.getElementById('campaign-system');
        
        if (campaignNameEl) {
          campaignNameEl.textContent = campaign.name || 'Unnamed Campaign';
        } else {
          Logger.warn('Campaign name element not found');
        }
        
        if (campaignSystemEl) {
          campaignSystemEl.textContent = campaign.system || 'No system selected';
        } else {
          Logger.warn('Campaign system element not found');
        }
        
        Logger.debug('Campaign info loaded successfully', { campaign });
        
      } catch (error) {
        Logger.error('Failed to load campaign info', error);
      }
    }
    
    // Enhanced maps loading with validation and error handling
    async function loadMaps() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('Invalid campaign ID for loading maps', { campaignId });
          return;
        }
        
        Logger.debug('Loading maps for campaign', { campaignId });
        
        const response = await fetch(`http://localhost:8080/api/maps?campaign_id=${campaignId}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !data.success) {
          throw new Error('Invalid response format or request failed');
        }
        
        if (!Array.isArray(data.maps)) {
          Logger.warn('No maps array in response');
          return;
        }
        
        const mapsList = document.getElementById('maps-list');
        if (!mapsList) {
          Logger.error('Maps list element not found');
          return;
        }
        
        // Clear existing maps
        mapsList.innerHTML = '';
        
        // Validate and create map items
        const validMaps = data.maps.filter(map => {
          if (!map || !map.id || !map.name) {
            Logger.warn('Invalid map data found', { map });
            return false;
          }
          return true;
        });
        
        if (validMaps.length === 0) {
          Logger.info('No valid maps found for campaign');
          const noMapsItem = document.createElement('li');
          noMapsItem.className = 'item no-maps';
          noMapsItem.innerHTML = '<div class="item-name">No maps available</div>';
          mapsList.appendChild(noMapsItem);
          return;
        }
        
        // Create map items
        validMaps.forEach(map => {
          try {
            const mapItem = document.createElement('li');
            mapItem.className = 'item';
            mapItem.innerHTML = `
              <div class="item-name">${escapeHtml(map.name)}</div>
              <div class="item-details">Map ID: ${map.id}</div>
            `;
            
            mapItem.addEventListener('click', () => {
              try {
                loadMap(map.id);
              } catch (error) {
                Logger.error('Failed to load map from click', error);
              }
            });
            
            mapsList.appendChild(mapItem);
            
          } catch (error) {
            Logger.error('Failed to create map item', error, { map });
          }
        });
        
        // Auto-load map based on session storage or first available
        if (validMaps.length > 0 && !currentMapId) {
          try {
            const savedMapId = sessionStorage.getItem('current_map_id');
            let mapToLoad = null;
            
            // Try to find the saved map first
            if (savedMapId) {
              mapToLoad = validMaps.find(map => map.id == savedMapId);
              if (mapToLoad) {
                Logger.debug('Found saved map to load', { mapId: savedMapId });
              }
            }
            
            // If saved map not found, use first map
            if (!mapToLoad) {
              mapToLoad = validMaps[0];
              Logger.debug('Using first available map', { mapId: mapToLoad.id });
            }
            
            await loadMap(mapToLoad.id);
            
            // Mark the loaded map as selected
            const mapItems = mapsList.querySelectorAll('.item');
            mapItems.forEach(item => {
              try {
                const detailsEl = item.querySelector('.item-details');
                if (detailsEl) {
                  const mapId = detailsEl.textContent.split(': ')[1];
                  if (mapId == mapToLoad.id) {
                    item.classList.add('selected');
                  }
                }
              } catch (error) {
                Logger.warn('Failed to mark map as selected', error);
              }
            });
            
          } catch (error) {
            Logger.error('Failed to auto-load map', error);
          }
        }
        
        Logger.debug('Maps loaded successfully', { count: validMaps.length });
        
      } catch (error) {
        Logger.error('Failed to load maps', error);
      }
    }
    
    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Enhanced map loading with validation and error handling
    async function loadMap(mapId) {
      try {
        // Validate map ID
        if (!mapId || (typeof mapId !== 'string' && typeof mapId !== 'number')) {
          Logger.error('Invalid map ID provided', { mapId });
          return;
        }
        
        Logger.debug('Loading map', { mapId });
        
        // Remove selection from all maps
        const mapItems = document.querySelectorAll('#maps-list .item');
        mapItems.forEach(item => {
          try {
            item.classList.remove('selected');
          } catch (error) {
            Logger.warn('Failed to remove selection from map item', error);
          }
        });
        
        // Add selection to clicked map (only if called from click event)
        if (typeof event !== 'undefined' && event && event.target) {
          try {
            const itemEl = event.target.closest('.item');
            if (itemEl) {
              itemEl.classList.add('selected');
            }
          } catch (error) {
            Logger.warn('Failed to add selection to clicked map', error);
          }
        }
        
        // Update current map ID
        currentMapId = mapId;
        
        // Save selected map ID to session storage
        try {
          sessionStorage.setItem('current_map_id', mapId.toString());
        } catch (error) {
          Logger.warn('Failed to save map ID to session storage', error);
        }
        
        // Clear existing assets from all layers
        clearAllLayers();
        
        // Load positioned assets for this map
        await loadMapAssets(mapId);
        
        // Update active tokens list for the selected map
        loadActiveTokensAndSheets();
        
        Logger.debug('Map loaded successfully', { mapId });
        
      } catch (error) {
        Logger.error('Failed to load map', error, { mapId });
      }
    }
    
    // Enhanced layer clearing with validation and error handling
    function clearAllLayers() {
      try {
        const layers = ['tokens', 'map', 'audio', 'props'];
        
        Logger.debug('Clearing all map layers', { layers });
        
        layers.forEach(layerName => {
          try {
            const layer = document.getElementById(`${layerName}-layer`);
            if (layer) {
              layer.innerHTML = '';
              Logger.debug(`Cleared layer: ${layerName}`);
            } else {
              Logger.warn(`Layer element not found: ${layerName}-layer`);
            }
          } catch (error) {
            Logger.error(`Failed to clear layer: ${layerName}`, error);
          }
        });
        
        Logger.debug('All layers cleared successfully');
        
      } catch (error) {
        Logger.error('Failed to clear all layers', error);
      }
    }
    
    // Enhanced map assets loading with validation and error handling
    async function loadMapAssets(mapId) {
      try {
        // Validate map ID
        if (!mapId || (typeof mapId !== 'string' && typeof mapId !== 'number')) {
          Logger.error('Invalid map ID for loading assets', { mapId });
          return;
        }
        
        Logger.debug('Loading map assets', { mapId });
        
        // Ensure assets are loaded first
        if (!Array.isArray(assets) || assets.length === 0) {
          Logger.debug('Assets array is empty, loading assets first');
          try {
            await loadAssets();
          } catch (error) {
            Logger.error('Failed to load assets before loading map assets', error);
            return;
          }
        }
        
        Logger.debug('Assets available', { count: assets.length });
        
        // Define asset types to load
        const assetTypes = [
          { name: 'tokens', endpoint: '/api/map-tokens', layer: 'tokens', dataKey: 'tokens' },
          { name: 'backgrounds', endpoint: '/api/map-backgrounds', layer: 'map', dataKey: 'backgrounds' },
          { name: 'audio', endpoint: '/api/map-audio', layer: 'audio', dataKey: 'audio' },
          { name: 'props', endpoint: '/api/map-props', layer: 'props', dataKey: 'props' }
        ];
        
        // Load each asset type
        for (const assetType of assetTypes) {
          try {
            Logger.debug(`Loading ${assetType.name} for map`, { mapId });
            
            const response = await fetch(`${assetType.endpoint}?map_id=${mapId}`);
            
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data || !data.success) {
              Logger.warn(`Failed to load ${assetType.name}`, { mapId, data });
              continue;
            }
            
            const items = data[assetType.dataKey];
            if (!Array.isArray(items)) {
              Logger.warn(`No ${assetType.name} array in response`, { mapId });
              continue;
            }
            
            if (items.length === 0) {
              Logger.debug(`No ${assetType.name} found for map`, { mapId });
              continue;
            }
            
            Logger.debug(`Found ${items.length} ${assetType.name} to display`, { mapId });
            
            // Process each item
            items.forEach((item, index) => {
              try {
                // Validate item data
                if (!item || !item.asset_id || 
                    !CoordinateSystem.isValidCoordinates(item.grid_x, item.grid_y)) {
                  Logger.warn(`Invalid ${assetType.name} data`, { item, index });
                  return;
                }
                
                const assetData = {
                  assetId: item.asset_id,
                  assetType: assetType.name === 'backgrounds' ? 'background' : assetType.name.slice(0, -1), // Remove 's' from plural
                  assetName: item.name || assetType.name.slice(0, -1) // Remove 's' from plural
                };
                
                // Add token-specific data
                if (assetType.name === 'tokens' && item.id) {
                  assetData.tokenId = item.id;
                }
                
                Logger.debug(`Creating visual element for ${assetType.name}`, { assetData, coordinates: { x: item.grid_x, y: item.grid_y } });
                
                // Create visual element with enhanced coordinate system
                createVisualAssetElement(assetData, item.grid_x, item.grid_y, assetType.layer);
                
              } catch (error) {
                Logger.error(`Failed to process ${assetType.name} item`, error, { item, index });
              }
            });
            
            Logger.debug(`Successfully loaded ${items.length} ${assetType.name}`, { mapId });
            
          } catch (error) {
            Logger.error(`Failed to load ${assetType.name}`, error, { mapId });
          }
        }
        
        Logger.debug('Map assets loading completed', { mapId });
        
      } catch (error) {
        Logger.error('Failed to load map assets', error, { mapId });
      }
    }
    
    // Create new map
    async function createNewMap() {
      const mapName = prompt('Enter map name:');
      if (!mapName) return;
      
      try {
        const campaignId = MapState.getCampaignId();
        if (!campaignId) {
          alert('Error: Campaign ID not found. Please reload the page.');
          return;
        }
        
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        const response = await fetch('http://localhost:8080/api/maps', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            campaign_id: campaignId,
            name: mapName,
            data: {},
            username: user
          })
        });
        
        const data = await response.json();
        if (data.success) {
          loadMaps(); // Reload maps list
        } else {
          alert('Failed to create map: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Failed to create map:', error);
        alert('Failed to create map');
      }
    }
    

    

    

    
    // Asset management
    let assets = [];
    
    async function loadAssets() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || isNaN(parseInt(campaignId))) {
          Logger.error('Invalid campaign ID for loading assets:', campaignId);
          return false;
        }
        
        Logger.info('Loading assets for campaign:', campaignId);
        
        const response = await fetch(`http://localhost:8080/api/assets?campaign_id=${campaignId}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || typeof data.success === 'undefined') {
          Logger.warn('Invalid assets response data:', data);
          return false;
        }
        
        if (data.success) {
          if (!Array.isArray(data.assets)) {
            Logger.warn('Assets data is not an array:', data.assets);
            assets = [];
          } else {
            assets = data.assets.filter(asset => {
              if (!asset || typeof asset.id === 'undefined' || !asset.name) {
                Logger.warn('Invalid asset data filtered out:', asset);
                return false;
              }
              return true;
            });
          }
          
          Logger.info(`Loaded ${assets.length} valid assets`);
          displayAssets();
          return true;
        } else {
          Logger.error('Failed to load assets:', data.error || 'Unknown error');
          return false;
        }
      } catch (error) {
        Logger.error('Exception during assets loading:', error);
        return false;
      }
    }
    
    function displayAssets() {
      try {
        const assetsList = document.querySelector('#assets-section .item-list');
        const categorySelect = document.getElementById('asset-category-select');
        
        if (!assetsList) {
          Logger.error('Assets list element not found');
          return false;
        }
        
        if (!categorySelect) {
          Logger.error('Asset category select element not found');
          return false;
        }
        
        const selectedCategory = categorySelect.value;
        Logger.info('Displaying assets for category:', selectedCategory);
        
        assetsList.innerHTML = '';
        
        // Validate assets array
        if (!Array.isArray(assets)) {
          Logger.warn('Assets is not an array:', assets);
          return false;
        }
        
        // Filter assets based on selected category
        const filteredAssets = selectedCategory === 'all' 
          ? assets 
          : assets.filter(asset => {
              try {
                if (!asset || !asset.category) {
                  Logger.warn('Asset missing category:', asset);
                  return false;
                }
                
                if (selectedCategory === 'background') {
                  // Backgrounds are stored as 'backgrounds' category
                  return asset.category === 'backgrounds';
                } else {
                  return asset.category === selectedCategory;
                }
              } catch (filterError) {
                Logger.error('Error filtering asset:', filterError, asset);
                return false;
              }
            });
        
        Logger.info(`Displaying ${filteredAssets.length} filtered assets`);
        
        filteredAssets.forEach(asset => {
          try {
            if (!asset || typeof asset.id === 'undefined' || !asset.name) {
              Logger.warn('Invalid asset data for display:', asset);
              return;
            }
            
            const li = document.createElement('li');
            li.className = 'item';
            li.draggable = true;
            li.dataset.assetId = asset.id;
            li.dataset.assetType = asset.category || 'unknown';
            li.dataset.assetName = asset.name;
            
            const fileSize = asset.file_size ? formatFileSize(asset.file_size) : 'Unknown size';
            const category = asset.category || 'Unknown';
            
            li.innerHTML = `
              <div class="item-name">${escapeHtml(asset.name)}</div>
              <div class="item-details">${escapeHtml(category)} - ${fileSize}</div>
              <div class="item-actions">
                <button onclick="editAsset(${asset.id})" title="Edit">✏️</button>
                <button onclick="deleteAsset(${asset.id})" title="Delete">🗑️</button>
              </div>
            `;
            
            // Add drag event listeners with error handling
            li.addEventListener('dragstart', function(e) {
              try {
                const dragData = {
                  assetId: asset.id,
                  assetType: asset.category || 'unknown',
                  assetName: asset.name
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
                e.dataTransfer.effectAllowed = 'copy';
                Logger.info('Drag started for asset:', asset.name);
              } catch (dragError) {
                Logger.error('Error setting drag data:', dragError);
              }
            });
            
            assetsList.appendChild(li);
          } catch (itemError) {
            Logger.error('Error creating asset item:', itemError, asset);
          }
        });
        
        return true;
        
      } catch (error) {
        Logger.error('Exception during assets display:', error);
        return false;
      }
    }
    
    function uploadAsset() {
      try {
        // Get selected category
        const categorySelect = document.getElementById('asset-category-select');
        
        if (!categorySelect) {
          Logger.error('Asset category select element not found');
          alert('Error: Category selector not found. Please reload the page.');
          return;
        }
        
        const selectedCategory = categorySelect.value;
        
        // Validate category selection
        if (!selectedCategory || selectedCategory === 'all') {
          alert('Please select a specific category before uploading assets.');
          return;
        }
        
        // Validate required IDs
        const campaignId = MapState.getCampaignId();
        if (!userId || !campaignId) {
          Logger.error('Missing required IDs for upload:', { userId, campaignId });
          alert('Error: Missing user or campaign information. Please reload the page.');
          return;
        }
        
        Logger.info('Starting asset upload for category:', selectedCategory);
        
        const input = document.createElement('input');
        input.type = 'file';
        
        // Set file filter based on selected category
        const acceptTypes = {
          'tokens': '.png',
          'background': '.jpg,.jpeg,.png',
          'props': '.png',
          'audio': '.mp3,.wav,.ogg,.m4a,.aac'
        };
        
        input.accept = acceptTypes[selectedCategory] || 'image/*,audio/*';
        
        input.onchange = async function(e) {
          try {
            const file = e.target.files[0];
            if (!file) {
              Logger.warn('No file selected for upload');
              return;
            }
            
            // Validate file size (max 50MB)
            const maxSize = 50 * 1024 * 1024; // 50MB
            if (file.size > maxSize) {
              alert('File size too large. Maximum allowed size is 50MB.');
              return;
            }
            
            // Validate file type
            const allowedTypes = {
              'tokens': ['image/png'],
              'background': ['image/jpeg', 'image/jpg', 'image/png'],
              'props': ['image/png'],
              'audio': ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp4', 'audio/aac']
            };
            
            const categoryTypes = allowedTypes[selectedCategory];
            if (categoryTypes && !categoryTypes.includes(file.type)) {
              alert(`Invalid file type for ${selectedCategory}. Allowed types: ${categoryTypes.join(', ')}`);
              return;
            }
            
            Logger.info('Uploading file:', file.name, 'Size:', file.size, 'Type:', file.type);
            
            // First upload the file to get the URL
            const uploadFormData = new FormData();
            uploadFormData.append('file', file);
            uploadFormData.append('user_id', userId);
            uploadFormData.append('campaign_id', campaignId);
            uploadFormData.append('upload_type', selectedCategory);
            
            // Upload file first
            const uploadResponse = await fetch('http://localhost:8080/api/upload', {
              method: 'POST',
              body: uploadFormData
            });
            
            if (!uploadResponse.ok) {
              throw new Error(`Upload HTTP error! status: ${uploadResponse.status}`);
            }
            
            const uploadData = await uploadResponse.json();
            if (!uploadData || !uploadData.success) {
              const errorMsg = uploadData?.error || 'Unknown upload error';
              Logger.error('File upload failed:', errorMsg);
              alert('Failed to upload file: ' + errorMsg);
              return;
            }
            
            Logger.info('File uploaded successfully, creating asset record');
            
            // Then create asset record
            const assetData = {
              campaign_id: parseInt(campaignId),
              name: file.name,
              category: selectedCategory,
              file_url: uploadData.url,
              file_size: uploadData.size || file.size,
              mime_type: file.type,
              description: '',
              tags: ''
            };
            
            const assetResponse = await fetch('http://localhost:8080/api/assets', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(assetData)
            });
            
            if (!assetResponse.ok) {
              throw new Error(`Asset creation HTTP error! status: ${assetResponse.status}`);
            }
            
            const assetResult = await assetResponse.json();
            if (assetResult && assetResult.success) {
              Logger.info('Asset created successfully:', file.name);
              await loadAssets();
              alert('Asset uploaded successfully!');
            } else {
              const errorMsg = assetResult?.error || 'Unknown asset creation error';
              Logger.error('Asset creation failed:', errorMsg);
              alert('Failed to create asset record: ' + errorMsg);
            }
          } catch (error) {
            Logger.error('Exception during asset upload:', error);
            alert('Failed to upload asset: ' + (error.message || 'Network error'));
          }
        };
        
        input.click();
        
      } catch (error) {
        Logger.error('Exception in uploadAsset function:', error);
        alert('Error starting upload: ' + (error.message || 'Unknown error'));
      }
    }
    
    async function editAsset(assetId) {
      try {
        // Validate asset ID
        if (!assetId || isNaN(parseInt(assetId))) {
          Logger.error('Invalid asset ID for editing:', assetId);
          alert('Error: Invalid asset ID.');
          return;
        }
        
        // Validate assets array
        if (!Array.isArray(assets)) {
          Logger.error('Assets array is not valid:', assets);
          alert('Error: Assets data not loaded. Please reload the page.');
          return;
        }
        
        const asset = assets.find(a => a && a.id == assetId);
        if (!asset) {
          Logger.error('Asset not found for editing:', assetId);
          alert('Error: Asset not found.');
          return;
        }
        
        Logger.info('Editing asset:', asset.name, 'ID:', assetId);
        
        const newName = prompt('Enter new name:', asset.name);
        if (!newName || typeof newName !== 'string' || newName.trim().length === 0) {
          Logger.warn('Asset edit cancelled or invalid name provided');
          return;
        }
        
        const trimmedName = newName.trim();
        if (trimmedName === asset.name) {
          Logger.info('Asset name unchanged, no update needed');
          return;
        }
        
        Logger.info('Updating asset name from', asset.name, 'to', trimmedName);
        
        const response = await fetch(`http://localhost:8080/api/assets/${assetId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: trimmedName
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        if (data && data.success) {
          Logger.info('Asset updated successfully:', trimmedName);
          await loadAssets();
          alert('Asset updated successfully!');
        } else {
          const errorMsg = data?.error || 'Unknown error occurred';
          Logger.error('Failed to update asset:', errorMsg);
          alert('Failed to update asset: ' + errorMsg);
        }
      } catch (error) {
        Logger.error('Exception during asset editing:', error);
        alert('Failed to update asset: ' + (error.message || 'Network error'));
      }
    }

    async function editTokenName(assetData, assetElement) {
      try {
        // Validate input parameters
        if (!assetData || !assetElement) {
          Logger.error('Invalid parameters for editTokenName:', { assetData, assetElement });
          alert('Error: Invalid token data.');
          return;
        }
        
        if (!assetData.assetId || !assetData.assetName) {
          Logger.error('Missing required asset data:', assetData);
          alert('Error: Missing asset information.');
          return;
        }
        
        const currentName = assetData.assetName || 'Token';
        Logger.info('Editing token name:', currentName, 'Asset ID:', assetData.assetId);
        
        const newName = prompt('Inserisci il nuovo nome del token:', currentName);
        if (!newName || typeof newName !== 'string' || newName.trim().length === 0) {
          Logger.warn('Token name edit cancelled or invalid name provided');
          return;
        }
        
        const trimmedName = newName.trim();
        if (trimmedName === currentName) {
          Logger.info('Token name unchanged, no update needed');
          return;
        }
        
        let tokenId = assetData.tokenId;
        
        // If tokenId is not available, find it from the map tokens
        if (!tokenId) {
          try {
            const mapId = getCurrentMapId();
            if (!mapId) {
              Logger.error('No current map ID available');
              alert('Error: No map selected.');
              return;
            }
            
            const tokensResponse = await fetch(`/api/map-tokens?map_id=${mapId}`);
            
            if (!tokensResponse.ok) {
              throw new Error(`HTTP error! status: ${tokensResponse.status}`);
            }
            
            const tokensData = await tokensResponse.json();
            
            if (!tokensData || !tokensData.success || !Array.isArray(tokensData.tokens)) {
              Logger.error('Invalid tokens response:', tokensData);
              alert('Errore nel recupero dei token dalla mappa');
              return;
            }
            
            const token = tokensData.tokens.find(t => t && t.asset_id == assetData.assetId);
            if (!token) {
              Logger.error('Token not found in map tokens:', assetData.assetId);
              alert('Token non trovato nel database');
              return;
            }
            tokenId = token.id;
          } catch (tokenFetchError) {
            Logger.error('Error fetching map tokens:', tokenFetchError);
            alert('Errore nel recupero dei token dalla mappa');
            return;
          }
        }
        
        Logger.info('Updating token name from', currentName, 'to', trimmedName, 'Token ID:', tokenId);
        
        // Update the asset name in the assets table
        const assetResponse = await fetch(`http://localhost:8080/api/assets/${assetData.assetId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: trimmedName
          })
        });
        
        if (!assetResponse.ok) {
          throw new Error(`Asset update HTTP error! status: ${assetResponse.status}`);
        }
        
        const assetResult = await assetResponse.json();
        if (!assetResult || !assetResult.success) {
          const errorMsg = assetResult?.error || 'Unknown asset update error';
          Logger.error('Asset update failed:', errorMsg);
          alert('Errore nell\'aggiornamento dell\'asset: ' + errorMsg);
          return;
        }
        
        // Update the token name in map_tokens table
        const tokenResponse = await fetch(`http://localhost:8080/api/map-tokens/${tokenId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: trimmedName
          })
        });
        
        if (!tokenResponse.ok) {
          throw new Error(`Token update HTTP error! status: ${tokenResponse.status}`);
        }
        
        const tokenData = await tokenResponse.json();
        if (tokenData && tokenData.success) {
          // Update the visual element
          try {
            assetData.assetName = trimmedName;
            assetElement.title = `${assetData.assetType}: ${trimmedName}`;
            
            // Update the assets array
            if (Array.isArray(assets)) {
              const asset = assets.find(a => a && a.id == assetData.assetId);
              if (asset) {
                asset.name = trimmedName;
              }
            }
            
            // Refresh the assets display
            await displayAssets();
            
            Logger.info('Token name updated successfully:', trimmedName);
            alert('Nome del token aggiornato con successo!');
          } catch (updateError) {
            Logger.error('Error updating visual elements:', updateError);
            alert('Token aggiornato ma errore nell\'aggiornamento dell\'interfaccia');
          }
        } else {
          const errorMsg = tokenData?.error || 'Unknown token update error';
          Logger.error('Token update failed:', errorMsg);
          alert('Asset aggiornato ma errore nell\'aggiornamento del token sulla mappa: ' + errorMsg);
        }
      } catch (error) {
        Logger.error('Exception during token name editing:', error);
        alert('Errore nell\'aggiornamento del token: ' + (error.message || 'Network error'));
      }
    }
    
    async function deleteAsset(assetId) {
      try {
        // Validate asset ID
        if (!assetId || isNaN(parseInt(assetId))) {
          Logger.error('Invalid asset ID for deletion:', assetId);
          alert('Error: Invalid asset ID.');
          return;
        }
        
        // Find asset for confirmation
        let assetName = 'this asset';
        if (Array.isArray(assets)) {
          const asset = assets.find(a => a && a.id == assetId);
          if (asset && asset.name) {
            assetName = asset.name;
          }
        }
        
        if (!confirm(`Are you sure you want to delete "${assetName}"? This action cannot be undone.`)) {
          Logger.info('Asset deletion cancelled by user');
          return;
        }
        
        Logger.info('Deleting asset:', assetName, 'ID:', assetId);
        
        const response = await fetch(`http://localhost:8080/api/assets/${assetId}`, {
          method: 'DELETE'
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        if (data && data.success) {
          Logger.info('Asset deleted successfully:', assetName);
          await loadAssets();
          alert('Asset deleted successfully!');
        } else {
          const errorMsg = data?.error || 'Unknown error occurred';
          Logger.error('Failed to delete asset:', errorMsg);
          alert('Failed to delete asset: ' + errorMsg);
        }
      } catch (error) {
        Logger.error('Exception during asset deletion:', error);
        alert('Failed to delete asset: ' + (error.message || 'Network error'));
      }
    }
    
    function formatFileSize(bytes) {
      try {
        // Validate input
        if (typeof bytes !== 'number' || isNaN(bytes) || bytes < 0) {
          Logger.warn('Invalid bytes value for formatFileSize:', bytes);
          return 'Unknown size';
        }
        
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        // Ensure index is within bounds
        const sizeIndex = Math.min(i, sizes.length - 1);
        const formattedSize = parseFloat((bytes / Math.pow(k, sizeIndex)).toFixed(2));
        
        return formattedSize + ' ' + sizes[sizeIndex];
      } catch (error) {
        Logger.error('Error formatting file size:', error, bytes);
        return 'Unknown size';
      }
    }
    
    function addToken() {
      alert('Active token management will be implemented in future updates. Use Assets > Tokens to upload token images.');
    }
    
    function addJournalEntry() {
      alert('Journal system will be implemented in future updates');
    }
    
    // ===== TOKEN SELECTION SYSTEM =====
    let selectedTokens = new Set();
    let isSelecting = false;
    let selectionBox = null;
    let selectionStartX = 0;
    let selectionStartY = 0;
    
    function selectToken(tokenElement, isShiftKey = false) {
      try {
        if (!tokenElement || !tokenElement.dataset.selectable) {
          Logger.warn('Invalid token element for selection:', tokenElement);
          return;
        }
        
        const tokenId = tokenElement.dataset.tokenId;
        if (!tokenId) {
          Logger.warn('Token element missing tokenId:', tokenElement);
          return;
        }
        
        Logger.debug('Selecting token:', tokenId, 'Shift key:', isShiftKey);
        
        if (!isShiftKey) {
          // Clear previous selection if not holding Shift
          clearTokenSelection();
        }
        
        if (selectedTokens.has(tokenId)) {
          // Deselect if already selected and Shift is held
          if (isShiftKey) {
            deselectToken(tokenElement);
          }
        } else {
          // Add to selection
          selectedTokens.add(tokenId);
          tokenElement.classList.add('selected-token');
          tokenElement.style.boxShadow = '0 0 10px 3px rgba(255, 215, 0, 0.8)';
          tokenElement.style.zIndex = '1000';
        }
        
        Logger.info(`Selected tokens: ${selectedTokens.size}`);
        updateSelectionUI();
        
      } catch (error) {
        Logger.error('Error in selectToken:', error);
      }
    }
    
    function deselectToken(tokenElement) {
      try {
        const tokenId = tokenElement.dataset.tokenId;
        if (tokenId && selectedTokens.has(tokenId)) {
          selectedTokens.delete(tokenId);
          tokenElement.classList.remove('selected-token');
          tokenElement.style.boxShadow = '';
          tokenElement.style.zIndex = '';
        }
      } catch (error) {
        Logger.error('Error in deselectToken:', error);
      }
    }
    
    function clearTokenSelection() {
      try {
        const selectedElements = document.querySelectorAll('.selected-token');
        selectedElements.forEach(element => {
          element.classList.remove('selected-token');
          element.style.boxShadow = '';
          element.style.zIndex = '';
        });
        selectedTokens.clear();
        updateSelectionUI();
        Logger.debug('Token selection cleared');
      } catch (error) {
        Logger.error('Error in clearTokenSelection:', error);
      }
    }
    
    function updateSelectionUI() {
       try {
         // Update UI to show selection count or selected token info
         const selectionInfo = document.getElementById('selection-info');
         if (selectionInfo) {
           if (selectedTokens.size === 0) {
             selectionInfo.textContent = '';
           } else if (selectedTokens.size === 1) {
             selectionInfo.textContent = '1 token selected';
           } else {
             selectionInfo.textContent = `${selectedTokens.size} tokens selected`;
           }
         }
       } catch (error) {
         Logger.error('Error in updateSelectionUI:', error);
       }
     }
     
     // ===== TOKEN MOVEMENT SYSTEM =====
     function moveSelectedTokens(direction) {
       try {
         if (selectedTokens.size === 0) {
           Logger.warn('No tokens selected for movement');
           return;
         }
         
         // Calculate movement delta based on grid size
         const gridSize = 50; // Default grid size in pixels
         let deltaX = 0;
         let deltaY = 0;
         
         switch(direction) {
           case 'arrowup':
             deltaY = -gridSize;
             break;
           case 'arrowdown':
             deltaY = gridSize;
             break;
           case 'arrowleft':
             deltaX = -gridSize;
             break;
           case 'arrowright':
             deltaX = gridSize;
             break;
           default:
             Logger.warn('Invalid movement direction:', direction);
             return;
         }
         
         // Move each selected token
         selectedTokens.forEach(tokenId => {
           const tokenElement = document.querySelector(`[data-token-id="${tokenId}"]`);
           if (tokenElement) {
             moveTokenElement(tokenElement, deltaX, deltaY);
           }
         });
         
         Logger.info(`Moved ${selectedTokens.size} tokens ${direction}`);
         
       } catch (error) {
         Logger.error('Error in moveSelectedTokens:', error);
       }
     }
     
     function moveTokenElement(tokenElement, deltaX, deltaY) {
       try {
         // Get current position
         const currentLeft = parseInt(tokenElement.style.left) || 0;
         const currentTop = parseInt(tokenElement.style.top) || 0;
         
         // Calculate new position
         const newLeft = currentLeft + deltaX;
         const newTop = currentTop + deltaY;
         
         // Apply new position
         tokenElement.style.left = newLeft + 'px';
         tokenElement.style.top = newTop + 'px';
         
         // Update token position on server
         updateTokenPositionOnServer(tokenElement, newLeft, newTop);
         
         Logger.debug('Token moved:', {
           tokenId: tokenElement.dataset.tokenId,
           from: { x: currentLeft, y: currentTop },
           to: { x: newLeft, y: newTop }
         });
         
       } catch (error) {
         Logger.error('Error in moveTokenElement:', error);
       }
     }
     
     async function updateTokenPositionOnServer(tokenElement, x, y) {
        try {
          const tokenId = tokenElement.dataset.tokenId;
          if (!tokenId) {
            Logger.warn('Token element missing tokenId for server update');
            return;
          }
          
          const mapId = getCurrentMapId();
          if (!mapId) {
            Logger.warn('No current map ID for token position update');
            return;
          }
          
          // Convert pixel coordinates to map coordinates if needed
          const mapCoords = screenToMapCoordinates(x, y);
          const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
          
          const response = await fetch(`http://localhost:8080/api/map-tokens/${tokenId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              grid_x: gridCoords.x,
              grid_y: gridCoords.y
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          if (!data.success) {
            throw new Error('Server reported failure updating token position');
          }
          
          Logger.debug('Token position updated on server:', { tokenId, x: mapCoords.x, y: mapCoords.y });
          
        } catch (error) {
          Logger.error('Failed to update token position on server:', error);
        }
      }
      
      function handleMultiTokenDrop(e, dragData) {
        try {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            Logger.error('Map viewport not found during multi-token drop');
            return;
          }
          
          const rect = viewport.getBoundingClientRect();
          const dropX = e.clientX - rect.left;
          const dropY = e.clientY - rect.top;
          
          // Calculate the offset from the original drag start position in screen coordinates
          const dragStartRect = viewport.getBoundingClientRect();
          const dragStartX = dragData.dragStartX - dragStartRect.left;
          const dragStartY = dragData.dragStartY - dragStartRect.top;
          
          const deltaX = dropX - dragStartX;
          const deltaY = dropY - dragStartY;
          
          Logger.debug('Multi-token drop:', {
            dropPosition: { x: dropX, y: dropY },
            dragStart: { x: dragStartX, y: dragStartY },
            delta: { x: deltaX, y: deltaY },
            tokensCount: dragData.tokens.length
          });
          
          // Move each token by the same delta
          dragData.tokens.forEach(tokenData => {
            const tokenElement = document.querySelector(`[data-token-id="${tokenData.assetId}"]`);
            if (tokenElement) {
              // Calculate new position based on original position + delta
              const newX = tokenData.currentX + deltaX;
              const newY = tokenData.currentY + deltaY;
              
              // Snap to grid - convert viewport coordinates to map coordinates
              const mapCoords = screenToMapCoordinates(newX, newY);
              const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
              const pixelCenter = gridCellToPixelCenter(gridCoords.x, gridCoords.y);
              
              // Update token position
              tokenElement.style.left = pixelCenter.x + 'px';
              tokenElement.style.top = pixelCenter.y + 'px';
              
              // Update position on server
              updateTokenPositionOnServer(tokenElement, pixelCenter.x, pixelCenter.y);
              
              Logger.debug('Token moved in multi-drop:', {
                tokenId: tokenData.assetId,
                from: { x: tokenData.currentX, y: tokenData.currentY },
                to: { x: pixelCenter.x, y: pixelCenter.y },
                grid: { x: gridCoords.x, y: gridCoords.y },
                delta: { x: deltaX, y: deltaY }
              });
            }
          });
          
          Logger.info(`Moved ${dragData.tokens.length} tokens via drag and drop`);
          
        } catch (error) {
          Logger.error('Error in handleMultiTokenDrop:', error);
        }
      }
     
     // ===== SELECTION BOX SYSTEM =====
     function startSelectionBox(e) {
       try {
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         selectionStartX = e.clientX - rect.left;
         selectionStartY = e.clientY - rect.top;
         
         isSelecting = true;
         
         // Create selection box element
         selectionBox = document.createElement('div');
         selectionBox.className = 'selection-box';
         selectionBox.style.position = 'absolute';
         selectionBox.style.border = '2px dashed #007bff';
         selectionBox.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
         selectionBox.style.pointerEvents = 'none';
         selectionBox.style.zIndex = '9999';
         selectionBox.style.left = selectionStartX + 'px';
         selectionBox.style.top = selectionStartY + 'px';
         selectionBox.style.width = '0px';
         selectionBox.style.height = '0px';
         
         viewport.appendChild(selectionBox);
         
         // Clear previous selection if not holding Shift
         if (!e.shiftKey) {
           clearTokenSelection();
         }
         
         Logger.debug('Started selection box at:', selectionStartX, selectionStartY);
         
       } catch (error) {
         Logger.error('Error in startSelectionBox:', error);
       }
     }
     
     function updateSelectionBox(e) {
       try {
         if (!isSelecting || !selectionBox) return;
         
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         const currentX = e.clientX - rect.left;
         const currentY = e.clientY - rect.top;
         
         const left = Math.min(selectionStartX, currentX);
         const top = Math.min(selectionStartY, currentY);
         const width = Math.abs(currentX - selectionStartX);
         const height = Math.abs(currentY - selectionStartY);
         
         selectionBox.style.left = left + 'px';
         selectionBox.style.top = top + 'px';
         selectionBox.style.width = width + 'px';
         selectionBox.style.height = height + 'px';
         
       } catch (error) {
         Logger.error('Error in updateSelectionBox:', error);
       }
     }
     
     function endSelectionBox(e) {
       try {
         if (!isSelecting || !selectionBox) return;
         
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         const currentX = e.clientX - rect.left;
         const currentY = e.clientY - rect.top;
         
         const left = Math.min(selectionStartX, currentX);
         const top = Math.min(selectionStartY, currentY);
         const right = Math.max(selectionStartX, currentX);
         const bottom = Math.max(selectionStartY, currentY);
         
         // Find tokens within selection box
         const tokens = document.querySelectorAll('[data-selectable="true"]');
         const tokensToSelect = [];
         
         Logger.debug('Selection box coordinates:', { left, top, right, bottom });
         Logger.debug('Found tokens to check:', tokens.length);
         
         // Get viewport rect for coordinate conversion
         const viewportRect = viewport.getBoundingClientRect();
         
         tokens.forEach(token => {
           try {
             // Get token position in screen coordinates
             const tokenRect = token.getBoundingClientRect();
             
             // Convert token screen coordinates to viewport-relative coordinates
             const tokenScreenLeft = tokenRect.left - viewportRect.left;
             const tokenScreenTop = tokenRect.top - viewportRect.top;
             const tokenScreenRight = tokenScreenLeft + tokenRect.width;
             const tokenScreenBottom = tokenScreenTop + tokenRect.height;
             
             // Check intersection with selection box (both in viewport coordinates)
             const intersects = tokenScreenLeft < right && tokenScreenRight > left && 
                               tokenScreenTop < bottom && tokenScreenBottom > top;
             
             Logger.debug('Token check:', {
               tokenId: token.dataset.tokenId,
               tokenScreenBounds: { 
                 left: tokenScreenLeft, 
                 top: tokenScreenTop, 
                 right: tokenScreenRight, 
                 bottom: tokenScreenBottom 
               },
               selectionBounds: { left, top, right, bottom },
               intersects
             });
             
             if (intersects) {
               tokensToSelect.push(token);
             }
           } catch (error) {
             Logger.warn('Error checking token intersection:', error, token);
           }
         });
         
         Logger.debug('Tokens to select:', tokensToSelect.length);
         
         // Select all tokens found in the selection box
         tokensToSelect.forEach((token, index) => {
           // For drag selection, treat as additive (like holding Shift)
           // Only clear selection for the first token if Shift is not held
           const shouldClearFirst = index === 0 && !e.shiftKey;
           if (shouldClearFirst) {
             selectToken(token, false); // This will clear previous selection
           } else {
             selectToken(token, true); // This will add to selection
           }
         });
         
         // Clean up
         viewport.removeChild(selectionBox);
         selectionBox = null;
         isSelecting = false;
         
         Logger.debug('Ended selection box, selected tokens:', selectedTokens.size);
         
       } catch (error) {
         Logger.error('Error in endSelectionBox:', error);
         // Clean up on error
         if (selectionBox && selectionBox.parentNode) {
           selectionBox.parentNode.removeChild(selectionBox);
         }
         selectionBox = null;
         isSelecting = false;
       }
     }
    
    function sendChatMessage() {
      try {
        const input = document.getElementById('chat-input');
        
        if (!input) {
          Logger.warn('Chat input element not found');
          return;
        }
        
        const message = input.value.trim();
        if (!message) {
          Logger.debug('Empty chat message, ignoring');
          return;
        }
        
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) {
          Logger.warn('Chat messages container not found');
          return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = 'margin-bottom: 10px; padding: 5px; background: #4a4a2a; border-radius: 3px;';
        messageDiv.innerHTML = `<strong>You:</strong> ${escapeHtml(message)}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        input.value = '';
        Logger.debug('Chat message sent:', message);
      } catch (error) {
        Logger.error('Error sending chat message:', error);
      }
    }
    
    function addDebugMessageToChat(message) {
      try {
        if (!message || typeof message !== 'string') {
          Logger.warn('Invalid debug message:', message);
          return;
        }
        
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) {
          Logger.warn('Chat messages container not found for debug message');
          return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = 'margin-bottom: 10px; padding: 5px; background: #2a4a4a; border-radius: 3px; border-left: 3px solid #00ff00;';
        messageDiv.innerHTML = `<strong style="color: #00ff00;">[DEBUG]:</strong> ${escapeHtml(message)}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        Logger.debug('Debug message added to chat:', message);
      } catch (error) {
        Logger.error('Error adding debug message to chat:', error);
      }
    }
    
    // Campaign settings management
    let campaignSettings = {
      gridSize: 50,
      gridColor: '#ffffff',
      gridOpacity: 10
    };
    
    async function loadCampaignSettings() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || typeof campaignId !== 'string') {
          Logger.error('Invalid campaign ID for loading settings:', campaignId);
          return;
        }
        
        const response = await fetch(`http://localhost:8080/api/campaigns/${campaignId}/settings`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data && data.success && data.settings) {
          // Validate settings data
          const validatedSettings = {
            gridSize: typeof data.settings.gridSize === 'number' ? data.settings.gridSize : campaignSettings.gridSize,
            gridColor: typeof data.settings.gridColor === 'string' ? data.settings.gridColor : campaignSettings.gridColor,
            gridOpacity: typeof data.settings.gridOpacity === 'number' ? data.settings.gridOpacity : campaignSettings.gridOpacity
          };
          
          campaignSettings = { ...campaignSettings, ...validatedSettings };
          applySettings();
          Logger.info('Campaign settings loaded successfully');
        } else {
          Logger.warn('No valid settings data received:', data);
        }
      } catch (error) {
        Logger.error('Failed to load campaign settings:', error);
      }
    }
    
    function applySettings() {
      try {
        // Validate settings object
        if (!campaignSettings || typeof campaignSettings !== 'object') {
          Logger.error('Invalid campaign settings object:', campaignSettings);
          return;
        }
        
        // Update UI controls with error handling
        const gridSizeElement = document.getElementById('grid-size');
        const gridColorElement = document.getElementById('grid-color');
        const gridOpacityElement = document.getElementById('grid-opacity');
        
        if (gridSizeElement) {
          gridSizeElement.value = campaignSettings.gridSize || 50;
        }
        if (gridColorElement) {
          gridColorElement.value = campaignSettings.gridColor || '#ffffff';
        }
        if (gridOpacityElement) {
          gridOpacityElement.value = campaignSettings.gridOpacity || 10;
        }
        
        // Apply to map grid
        const mapGrid = document.getElementById('map-grid');
        if (!mapGrid) {
          Logger.warn('Map grid element not found');
          return;
        }
        
        const gridSize = campaignSettings.gridSize || 50;
        mapGrid.style.backgroundSize = `${gridSize}px ${gridSize}px`;
        
        const opacity = (campaignSettings.gridOpacity || 10) / 100;
        const rgb = hexToRgb(campaignSettings.gridColor || '#ffffff');
        
        if (rgb) {
          mapGrid.style.backgroundImage = `
            linear-gradient(rgba(${rgb.r},${rgb.g},${rgb.b},${opacity}) 1px, transparent 1px),
            linear-gradient(90deg, rgba(${rgb.r},${rgb.g},${rgb.b},${opacity}) 1px, transparent 1px)
          `;
        } else {
          Logger.error('Failed to convert grid color to RGB:', campaignSettings.gridColor);
        }
        
        Logger.debug('Settings applied successfully');
      } catch (error) {
        Logger.error('Error applying settings:', error);
      }
    }
    
    async function saveSettings() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || typeof campaignId !== 'string') {
          Logger.error('Invalid campaign ID for saving settings:', campaignId);
          alert('Invalid campaign ID');
          return;
        }
        
        // Get and validate UI elements
        const gridSizeElement = document.getElementById('grid-size');
        const gridColorElement = document.getElementById('grid-color');
        const gridOpacityElement = document.getElementById('grid-opacity');
        
        if (!gridSizeElement || !gridColorElement || !gridOpacityElement) {
          Logger.error('Settings UI elements not found');
          alert('Settings form not available');
          return;
        }
        
        // Parse and validate values
        const gridSize = parseInt(gridSizeElement.value);
        const gridColor = gridColorElement.value;
        const gridOpacity = parseInt(gridOpacityElement.value);
        
        if (isNaN(gridSize) || gridSize < 10 || gridSize > 200) {
          alert('Grid size must be between 10 and 200 pixels');
          return;
        }
        
        if (!gridColor || !/^#[0-9A-F]{6}$/i.test(gridColor)) {
          alert('Please select a valid grid color');
          return;
        }
        
        if (isNaN(gridOpacity) || gridOpacity < 0 || gridOpacity > 100) {
          alert('Grid opacity must be between 0 and 100');
          return;
        }
        
        const settings = {
          gridSize,
          gridColor,
          gridOpacity
        };
        
        const response = await fetch(`http://localhost:8080/api/campaigns/${campaignId}/settings`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ settings })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data && data.success) {
          campaignSettings = settings;
          applySettings();
          Logger.info('Settings saved successfully');
          alert('Settings saved successfully!');
        } else {
          const errorMsg = data?.error || 'Unknown error occurred';
          Logger.error('Failed to save settings:', errorMsg);
          alert('Failed to save settings: ' + errorMsg);
        }
      } catch (error) {
        Logger.error('Exception during settings save:', error);
        alert('Failed to save settings: ' + (error.message || 'Network error'));
      }
    }
    
    function hexToRgb(hex) {
      try {
        // Validate input
        if (!hex || typeof hex !== 'string') {
          Logger.warn('Invalid hex color input:', hex);
          return null;
        }
        
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        
        if (!result) {
          Logger.warn('Invalid hex color format:', hex);
          return null;
        }
        
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      } catch (error) {
        Logger.error('Error converting hex to RGB:', error, hex);
        return null;
      }
    }
    
    // Help panel toggle
    function toggleHelp() {
      try {
        const helpPanel = document.getElementById('help-panel');
        
        if (!helpPanel) {
          Logger.warn('Help panel element not found');
          return;
        }
        
        if (helpPanel.style.display === 'none' || helpPanel.style.display === '') {
          helpPanel.style.display = 'block';
          Logger.debug('Help panel opened');
        } else {
          helpPanel.style.display = 'none';
          Logger.debug('Help panel closed');
        }
      } catch (error) {
        Logger.error('Error toggling help panel:', error);
      }
    }
    
    // Chat input enter key support
    document.getElementById('chat-input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });
    
    // Global userId variable
    let userId;
    
    // Layer Management System
    let currentLayer = 'tokens';
    let layerVisibility = {
      'map': true,
      'walls': true,
      'tokens': true,
      'gm': true,
      'audio': true,
      'props': true
    };

    function initializeLayerSystem() {
      try {
        const layerButtons = document.querySelectorAll('.layer-btn');
        
        if (!layerButtons || layerButtons.length === 0) {
          Logger.warn('No layer buttons found for initialization');
          return;
        }
        
        layerButtons.forEach(button => {
          if (!button.dataset.target) {
            Logger.warn('Layer button missing target dataset:', button);
            return;
          }
          
          button.addEventListener('click', function() {
            try {
              const targetLayer = this.dataset.target;
              const layerName = targetLayer.replace('-layer', '');
              
              // Set as active layer (exclusive selection)
              setActiveLayer(layerName);
            } catch (error) {
              Logger.error('Error handling layer button click:', error);
            }
          });
          
          // Right click to toggle visibility
          button.addEventListener('contextmenu', function(e) {
            try {
              e.preventDefault();
              const targetLayer = this.dataset.target;
              const layerName = targetLayer.replace('-layer', '');
              
              if (this.classList.contains('hidden')) {
                showLayer(layerName);
                this.classList.remove('hidden');
                Logger.debug('Layer shown:', layerName);
              } else {
                hideLayer(layerName);
                this.classList.add('hidden');
                Logger.debug('Layer hidden:', layerName);
              }
            } catch (error) {
              Logger.error('Error handling layer context menu:', error);
            }
          });
        });
        
        Logger.info('Layer system initialized with', layerButtons.length, 'buttons');
      } catch (error) {
        Logger.error('Error initializing layer system:', error);
      }
      
      // Keyboard navigation for layers
      document.addEventListener('keydown', function(e) {
        try {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return; // Don't interfere with text input
          }
          
          switch(e.key) {
            case '1':
              setActiveLayer('map');
              break;
            case '2':
              setActiveLayer('walls');
              break;
            case '3':
              setActiveLayer('tokens');
              break;
            case '4':
              setActiveLayer('gm');
              break;
            case '5':
              setActiveLayer('audio');
              break;
            case '6':
              setActiveLayer('props');
              break;
          }
        } catch (error) {
          Logger.error('Error handling layer keyboard navigation:', error);
        }
      });
      
      // Set tokens layer as default active
      try {
        setActiveLayer('tokens');
      } catch (error) {
        Logger.error('Error setting default active layer:', error);
      }
      
      // Initialize drag and drop for layers
      try {
        initializeLayerDropZones();
      } catch (error) {
        Logger.error('Error initializing layer drop zones:', error);
      }
    }
    
    function initializeLayerDropZones() {
      try {
        const mapViewport = document.getElementById('map-viewport');
        
        if (!mapViewport) {
          Logger.error('Map viewport element not found for drop zone initialization');
          return;
        }
        
        mapViewport.addEventListener('dragover', function(e) {
          try {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            mapViewport.classList.add('drag-over');
          } catch (error) {
            Logger.error('Error handling dragover event:', error);
          }
        });
        
        mapViewport.addEventListener('dragleave', function(e) {
          try {
            // Only remove drag-over if we're leaving the viewport entirely
            if (!mapViewport.contains(e.relatedTarget)) {
              mapViewport.classList.remove('drag-over');
            }
          } catch (error) {
            Logger.error('Error handling dragleave event:', error);
          }
        });
      
        mapViewport.addEventListener('drop', function(e) {
          try {
            e.preventDefault();
            mapViewport.classList.remove('drag-over');
            
            // Validate drop data
            const dataText = e.dataTransfer.getData('text/plain');
            if (!dataText) {
              Logger.warn('No data found in drop event');
              return;
            }
            
            const data = JSON.parse(dataText);
            
            // Handle multi-token movement
            if (data.type === 'multitoken' && data.tokens) {
              handleMultiTokenDrop(e, data);
              return;
            }
            
            // Handle single asset drop (new assets from library)
            if (!data || !data.assetId || !data.assetType) {
              Logger.error('Invalid asset data in drop event:', data);
              return;
            }
            
            const viewport = document.getElementById('map-viewport');
            if (!viewport) {
              Logger.error('Map viewport not found during drop');
              return;
            }
            
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Validate coordinate functions
            if (typeof screenToMapCoordinates !== 'function' || 
                typeof mapToGridCoordinates !== 'function' || 
                typeof gridCellToPixelCenter !== 'function') {
              Logger.error('Required coordinate conversion functions not available');
              return;
            }
            
            // Use Roll20-inspired coordinate system
            const mapCoords = screenToMapCoordinates(mouseX, mouseY);
            const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
            const pixelCenter = gridCellToPixelCenter(gridCoords.x, gridCoords.y);
            
            const gridX = gridCoords.x;
            const gridY = gridCoords.y;
            const pixelX = pixelCenter.x;
            const pixelY = pixelCenter.y;
            
            Logger.debug('=== TOKEN DROP DEBUG ===');
            Logger.debug(`Target cell: Grid (${gridX}, ${gridY})`);
            Logger.debug(`Screen coordinates: (${mouseX}, ${mouseY})`);
            Logger.debug(`Map coordinates: (${mapCoords.x.toFixed(2)}, ${mapCoords.y.toFixed(2)})`);
            Logger.debug(`Calculated pixels: (${pixelX}, ${pixelY})`);
            Logger.debug('========================');
          
            // Determine target layer based on asset type
            let targetLayer;
            switch(data.assetType.toLowerCase()) {
              case 'token':
                // Tokens can only be dropped on 'tokens' or 'gm' layers
                if (currentLayer === 'tokens' || currentLayer === 'gm') {
                  targetLayer = currentLayer;
                } else {
                  // Show warning and prevent drop on invalid layers
                  Logger.warn(`Tokens can only be dropped on 'Tokens' or 'GM' layers. Current layer: ${currentLayer}`);
                  alert('I token possono essere posizionati solo sui layer "Tokens" o "GM". Seleziona uno di questi layer prima di trascinare il token.');
                  return; // Exit without creating the token
                }
                break;
              case 'background':
                targetLayer = 'map';
                break;
              case 'audio':
                // Audio can only be dropped on 'audio' layer
                if (currentLayer === 'audio') {
                  targetLayer = 'audio';
                } else {
                  // Show warning and prevent drop on invalid layers
                  Logger.warn(`Audio can only be dropped on 'Audio' layer. Current layer: ${currentLayer}`);
                  alert('Gli audio possono essere posizionati solo sul layer "Audio". Seleziona il layer Audio prima di trascinare l\'audio.');
                  return; // Exit without creating the audio
                }
                break;
              case 'props':
                targetLayer = 'props';
                break;
              default:
                targetLayer = currentLayer || 'tokens'; // Use current active layer as fallback
            }
            
            // Create asset on the appropriate layer
            createAssetOnLayer(data, gridX, gridY, pixelX, pixelY, targetLayer);
            
          } catch (error) {
            Logger.error('Error handling drop event:', error);
          }
        });
        
        Logger.info('Layer drop zones initialized successfully');
      } catch (error) {
        Logger.error('Error initializing layer drop zones:', error);
      }
    }
    
    function createAssetOnLayer(assetData, gridX, gridY, pixelX, pixelY, targetLayer) {
      try {
        // Validate input parameters
        if (!assetData || !assetData.assetId) {
          Logger.error('Invalid asset data for layer creation:', assetData);
          return;
        }
        
        if (typeof gridX !== 'number' || typeof gridY !== 'number') {
          Logger.error('Invalid grid coordinates:', { gridX, gridY });
          return;
        }
        
        if (!targetLayer || typeof targetLayer !== 'string') {
          Logger.error('Invalid target layer:', targetLayer);
          return;
        }
        
        const mapId = getCurrentMapId();
        if (!mapId) {
          Logger.error('No current map ID available for asset creation');
          return;
        }
        
        // Prepare data for API call with grid coordinates
        const payload = {
          map_id: mapId,
          asset_id: assetData.assetId,
          grid_x: gridX,
          grid_y: gridY,
          grid_z: 0,
          scale_x: 1.0,
          scale_y: 1.0,
          rotation: 0.0,
          visible: true,
          locked: false,
          properties: {}
        };
      
        // Add name for tokens (both tokens and gm layers)
        if (targetLayer === 'tokens' || targetLayer === 'gm') {
          payload.name = assetData.assetName || 'Unnamed Token';
        }
        
        // Add specific properties based on asset type
        if (targetLayer === 'map') {
          // Background-specific properties
          payload.opacity = 1.0;
          payload.blend_mode = 'normal';
          payload.grid_width = 1;
          payload.grid_height = 1;
        } else if (targetLayer === 'audio') {
          // Audio-specific properties
          payload.volume = 1.0;
          payload.loop = false;
          payload.radius_grid = 2; // Default audio radius in grid units
        } else if (targetLayer === 'props') {
          // Props-specific properties
          payload.interactive = true;
          payload.grid_width = 1;
          payload.grid_height = 1;
        }
        
        // Determine API endpoint based on target layer
        let apiEndpoint;
        switch(targetLayer) {
          case 'tokens':
          case 'gm':
            apiEndpoint = '/api/map-tokens';
            break;
          case 'map':
            apiEndpoint = '/api/map-backgrounds';
            break;
          case 'audio':
            apiEndpoint = '/api/map-audio';
            break;
          case 'props':
            apiEndpoint = '/api/map-props';
            break;
          default:
            Logger.error('Unknown target layer:', targetLayer);
            return;
        }
      
        // Make API call to create asset on layer
        fetch(apiEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          if (data && data.success) {
            Logger.info(`Asset placed on ${targetLayer} layer:`, data);
            // Optionally refresh the layer or add visual feedback
            if (typeof createVisualAssetElement === 'function') {
              createVisualAssetElement(assetData, gridX, gridY, targetLayer);
            } else {
              Logger.warn('createVisualAssetElement function not available');
            }
            // Update active tokens list if a token was added
            if (targetLayer === 'tokens' || targetLayer === 'gm') {
              loadActiveTokensAndSheets();
            }
          } else {
            const errorMsg = data?.error || 'Unknown error occurred';
            Logger.error(`Failed to place asset on ${targetLayer} layer:`, errorMsg);
          }
        })
        .catch(error => {
          Logger.error(`Exception during asset placement on ${targetLayer} layer:`, error);
        });
        
      } catch (error) {
        Logger.error('Error in createAssetOnLayer:', error);
      }
    }
    
    async function createVisualAssetElement(assetData, gridX, gridY, targetLayer) {
      try {
        // Validate input parameters
        if (!assetData || !assetData.assetId) {
          Logger.error('Invalid asset data for visual element creation:', assetData);
          return;
        }
        
        if (typeof gridX !== 'number' || typeof gridY !== 'number') {
          Logger.error('Invalid grid coordinates for visual element:', { gridX, gridY });
          return;
        }
        
        if (!targetLayer || typeof targetLayer !== 'string') {
          Logger.error('Invalid target layer for visual element:', targetLayer);
          return;
        }
        
        const layerElement = document.getElementById(`${targetLayer}-layer`);
        Logger.debug('Target layer element:', layerElement);
        
        if (!layerElement) {
          Logger.error('Layer element not found for:', targetLayer);
          return;
        }
      
        // Find the asset in our assets array to get the file_url
        const asset = assets ? assets.find(a => a.id == assetData.assetId) : null;
        Logger.debug('Creating visual asset element:', {
          assetData,
          foundAsset: asset,
          totalAssets: assets ? assets.length : 0,
          targetLayer,
          gridPosition: { gridX, gridY }
        });
      
        const assetElement = document.createElement('div');
        assetElement.className = 'map-asset';
        assetElement.style.position = 'absolute';
        
        // Validate coordinate functions
        if (typeof gridCellToPixelCenter !== 'function') {
          Logger.error('gridCellToPixelCenter function not available');
          return;
        }
        
        // Use new coordinate system functions for consistent positioning
        const pixelCenter = gridCellToPixelCenter(gridX, gridY);
        const pixelX = pixelCenter.x;
        const pixelY = pixelCenter.y;
        
        // Position relative to the map grid coordinate system
        assetElement.style.left = pixelX + 'px';
        assetElement.style.top = pixelY + 'px';
        assetElement.style.position = 'absolute';
        
        // Center the token image within its position
        assetElement.style.transform = 'translate(-50%, -50%)';
        assetElement.style.cursor = 'move';
        assetElement.title = `${assetData.assetType}: ${assetData.assetName}`;
        // Ensure the element is positioned relative to the grid coordinate system
        assetElement.style.transformOrigin = 'top left';
        
        // Log the visual positioning for debugging
        Logger.debug('=== VISUAL ASSET CREATION ===');
        Logger.debug(`Asset positioned at: Grid (${gridX}, ${gridY}) -> Pixel (${pixelX}, ${pixelY})`);
        Logger.debug('==============================');

      
      // Create image element if asset has file_url and is an image category (excluding audio)
      if (asset && asset.file_url && ['tokens', 'backgrounds', 'props'].includes(asset.category) && targetLayer !== 'audio') {
        const img = document.createElement('img');
        // Ensure the URL is correctly formatted
        let imageUrl = asset.file_url;
        if (!imageUrl.startsWith('http')) {
          // Remove leading slash if present to avoid double slashes
          const cleanPath = imageUrl.startsWith('/') ? imageUrl.substring(1) : imageUrl;
          imageUrl = `http://localhost:8080/${cleanPath}`;
        }
        img.src = imageUrl;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.borderRadius = 'inherit';
        img.onload = function() {
          Logger.debug('Image loaded successfully:', imageUrl);
        };
        img.onerror = function() {
          Logger.error('Failed to load image:', imageUrl);
          // Fallback to text if image fails to load
          assetElement.innerHTML = '';
          assetElement.textContent = assetData.assetName;
          assetElement.style.display = 'flex';
          assetElement.style.alignItems = 'center';
          assetElement.style.justifyContent = 'center';
          assetElement.style.fontSize = '12px';
          assetElement.style.color = '#007bff';
        };
        assetElement.appendChild(img);
      } else {
        // Fallback to text for non-image assets or when asset not found
        assetElement.style.display = 'flex';
        assetElement.style.alignItems = 'center';
        assetElement.style.justifyContent = 'center';
        assetElement.style.fontSize = '12px';
        assetElement.style.color = '#007bff';
        assetElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
        
        switch(assetData.assetType.toLowerCase()) {
          case 'token':
            assetElement.textContent = '👤';
            break;
          case 'background':
            assetElement.textContent = '🗺️';
            break;
          case 'audio':
            assetElement.textContent = '🔊';
            break;
          case 'props':
            assetElement.textContent = '🎭';
            break;
          default:
            assetElement.textContent = assetData.assetName;
        }
      }
      
      // Set size and styling based on asset type
      switch(assetData.assetType.toLowerCase()) {
        case 'token':
          assetElement.style.width = '50px';
          assetElement.style.height = '50px';
          assetElement.style.borderRadius = '50%';
          assetElement.style.border = '2px solid #28a745';
          break;
        case 'background':
          assetElement.style.width = '100px';
          assetElement.style.height = '100px';
          assetElement.style.borderRadius = '4px';
          assetElement.style.border = '2px solid #6f42c1';
          break;
        case 'audio':
          assetElement.style.width = '40px';
          assetElement.style.height = '40px';
          assetElement.style.borderRadius = '50%';
          assetElement.style.border = '2px solid #fd7e14';
          break;
        case 'props':
          assetElement.style.width = '60px';
          assetElement.style.height = '60px';
          assetElement.style.borderRadius = '8px';
          assetElement.style.border = '2px solid #20c997';
          break;
        default:
          assetElement.style.width = '50px';
          assetElement.style.height = '50px';
          assetElement.style.borderRadius = '4px';
          assetElement.style.border = '2px solid #007bff';
      }
      
      // Add context menu for tokens to enable editing
      if (assetData.assetType.toLowerCase() === 'token') {
        assetElement.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          editTokenName(assetData, assetElement);
        });
        
        // Add click handler for token selection
        assetElement.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          selectToken(assetElement, e.shiftKey);
        });
        
        // Add drag and drop support for existing tokens
        assetElement.draggable = true;
        assetElement.addEventListener('dragstart', function(e) {
          try {
            // If this token is not selected, select it and clear others
            if (!selectedTokens.has(assetData.assetId)) {
              clearTokenSelection();
              selectToken(assetElement, false);
            }
            
            // Prepare drag data for all selected tokens
            const selectedTokensData = [];
            selectedTokens.forEach(tokenId => {
              const tokenEl = document.querySelector(`[data-token-id="${tokenId}"]`);
              if (tokenEl) {
                selectedTokensData.push({
                  assetId: tokenId,
                  assetType: 'token',
                  assetName: tokenEl.title || 'Token',
                  currentX: parseInt(tokenEl.style.left) || 0,
                  currentY: parseInt(tokenEl.style.top) || 0
                });
              }
            });
            
            const dragData = {
              type: 'multitoken',
              tokens: selectedTokensData,
              dragStartX: e.clientX,
              dragStartY: e.clientY
            };
            
            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            e.dataTransfer.effectAllowed = 'move';
            Logger.info('Multi-token drag started:', selectedTokensData.length, 'tokens');
          } catch (dragError) {
            Logger.error('Error setting token drag data:', dragError);
          }
        });
        
        // Add dragend event listener to save position when drag ends
        assetElement.addEventListener('dragend', function(e) {
          try {
            // Get the current position of the token after drag
            const currentX = parseInt(assetElement.style.left) || 0;
            const currentY = parseInt(assetElement.style.top) || 0;
            
            // Update position on server for this token
            updateTokenPositionOnServer(assetElement, currentX, currentY);
            
            Logger.debug('Token drag ended, position saved:', {
              tokenId: assetData.assetId,
              x: currentX,
              y: currentY
            });
          } catch (dragEndError) {
            Logger.error('Error handling token dragend:', dragEndError);
          }
        });
        
        // Add data attributes for selection management
        assetElement.dataset.tokenId = assetData.assetId;
        assetElement.dataset.selectable = 'true';
      }
      
      // Add audio playback functionality for audio assets
       if (assetData.assetType.toLowerCase() === 'audio' && asset && asset.file_url) {
         // Store audio instance on the element to track playback state
         let audioInstance = null;
         
         assetElement.addEventListener('click', function(e) {
           e.preventDefault();
           e.stopPropagation();
           
           // Check if audio is already playing
           if (audioInstance && !audioInstance.paused) {
             // Stop current audio
             audioInstance.pause();
             audioInstance.currentTime = 0;
             audioInstance = null;
             
             // Reset visual feedback
             assetElement.style.border = '2px solid #fd7e14';
             assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
             Logger.info('Audio stopped:', assetData.assetName);
             return;
           }
           
           // Create new audio element and play
           audioInstance = new Audio();
           let audioUrl = asset.file_url;
           if (!audioUrl.startsWith('http')) {
             const cleanPath = audioUrl.startsWith('/') ? audioUrl.substring(1) : audioUrl;
             audioUrl = `http://localhost:8080/${cleanPath}`;
           }
           
           audioInstance.src = audioUrl;
           
           // Add event listener for when audio ends
           audioInstance.addEventListener('ended', function() {
             assetElement.style.border = '2px solid #fd7e14';
             assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
             audioInstance = null;
           });
           
           audioInstance.play().then(() => {
             Logger.info('Audio playing:', assetData.assetName);
             // Visual feedback - change color while playing
             assetElement.style.border = '3px solid #28a745';
             assetElement.title = `Audio: ${assetData.assetName} (In riproduzione - clicca per fermare)`;
           }).catch(error => {
             Logger.error('Failed to play audio:', error);
             alert('Impossibile riprodurre l\'audio: ' + assetData.assetName);
             audioInstance = null;
           });
         });
         
         // Add tooltip with audio info
         assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
       }

        layerElement.appendChild(assetElement);
        Logger.debug('Visual asset element added to layer:', {
          elementAdded: assetElement,
          layerChildren: layerElement.children.length,
          layerName: targetLayer
        });
        
      } catch (error) {
        Logger.error('Error in createVisualAssetElement:', error);
      }
    }
    
    function getCurrentMapId() {
      try {
        // Return the currently loaded map ID or fallback to URL parameter
        if (currentMapId) {
          return currentMapId;
        }
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('id') || '1'; // Default to 1 if not found
      } catch (error) {
        Logger.error('Error getting current map ID:', error);
        return '1'; // Safe fallback
      }
    }
    
    function setActiveLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for setActiveLayer:', layerName);
          return;
        }
        
        // Remove active class from all layers
        document.querySelectorAll('.map-layer').forEach(layer => {
          layer.classList.remove('active');
        });
        
        // Remove active class from all layer buttons
        document.querySelectorAll('.layer-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // Set new active layer
        const targetLayer = document.getElementById(layerName + '-layer');
        if (targetLayer) {
          targetLayer.classList.add('active');
          currentLayer = layerName;
          
          // Set corresponding button as active
          const targetButton = document.querySelector(`[data-target="${layerName}-layer"]`);
          if (targetButton) {
            targetButton.classList.add('active');
          }
          Logger.debug('Active layer set to:', layerName);
        } else {
          Logger.error('Target layer not found:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in setActiveLayer:', error);
      }
    }
    
    function showLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for showLayer:', layerName);
          return;
        }
        
        const layer = document.getElementById(layerName + '-layer');
        if (layer) {
          layer.classList.remove('layer-hidden');
          layerVisibility[layerName] = true;
          Logger.debug('Layer shown:', layerName);
        } else {
          Logger.error('Layer not found for showing:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in showLayer:', error);
      }
    }
    
    function hideLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for hideLayer:', layerName);
          return;
        }
        
        const layer = document.getElementById(layerName + '-layer');
        if (layer) {
          layer.classList.add('layer-hidden');
          layerVisibility[layerName] = false;
          Logger.debug('Layer hidden:', layerName);
        } else {
          Logger.error('Layer not found for hiding:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in hideLayer:', error);
      }
    }
    
    function getCurrentLayer() {
      return currentLayer;
    }
    
    function isLayerVisible(layerName) {
      return layerVisibility[layerName];
    }
    
    // Initialize function
    async function initialize() {
      try {
        Logger.info('Starting map initialization...');
        
        // Check login state
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        if (!user) {
          Logger.warn('No user found, redirecting to login');
          window.location.href = '/login';
          return;
        }
        
        Logger.debug('User found:', user);
        
        // Get user ID
        try {
          const userIdResponse = await fetch(`http://localhost:8080/api/user_id?username=${encodeURIComponent(user)}`);
          
          if (!userIdResponse.ok) {
            throw new Error(`HTTP ${userIdResponse.status}: ${userIdResponse.statusText}`);
          }
          
          const userIdData = await userIdResponse.json();
          if (userIdData.success) {
            userId = userIdData.user_id;
            Logger.info('User ID obtained:', userId);
          } else {
            const errorMsg = userIdData.error || 'Unknown error';
            Logger.error('Failed to get user ID:', errorMsg);
            alert('Failed to get user information: ' + errorMsg);
            return;
          }
        } catch (error) {
          Logger.error('Error getting user ID:', error);
          alert('Error getting user information: ' + error.message);
          return;
        }
        
        // Initialize after getting userId
        Logger.debug('Loading campaign data...');
        await Promise.all([
          loadCampaignInfo(),
          loadMaps(),
          loadAssets(),
          loadCampaignSettings()
        ]);
        
        // Add event listener for asset category filter
        const categorySelect = document.getElementById('asset-category-select');
        const assetAddBtn = document.querySelector('#assets-section .add-btn');
        
        if (categorySelect && assetAddBtn) {
          categorySelect.addEventListener('change', function() {
            try {
              displayAssets();
              
              // Disable + button when "All" is selected
              if (this.value === 'all') {
                assetAddBtn.disabled = true;
                assetAddBtn.style.opacity = '0.5';
                assetAddBtn.style.cursor = 'not-allowed';
                assetAddBtn.title = 'Select a specific category to upload assets';
              } else {
                assetAddBtn.disabled = false;
                assetAddBtn.style.opacity = '1';
                assetAddBtn.style.cursor = 'pointer';
                assetAddBtn.title = 'Upload new asset';
              }
            } catch (error) {
              Logger.error('Error in category select change handler:', error);
            }
          });
          
          // Initialize button state
          if (categorySelect.value === 'all') {
            assetAddBtn.disabled = true;
            assetAddBtn.style.opacity = '0.5';
            assetAddBtn.style.cursor = 'not-allowed';
            assetAddBtn.title = 'Select a specific category to upload assets';
          }
        } else {
          Logger.error('Category select or asset add button not found');
        }
        
        // Initialize navigation and layer systems
        initializeMapNavigation();
        initializeLayerSystem();
        
        Logger.info('Map initialization completed successfully');
        
      } catch (error) {
        Logger.error('Critical error during initialization:', error);
        alert('Failed to initialize the map: ' + error.message);
      }
    }
    
    // Start initialization
    initialize();
  </script>
</body>
</html>