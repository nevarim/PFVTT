<!DOCTYPE html>
<html>
<head>
  <title>PFVTT - Campaign Manager</title>
  <link rel="stylesheet" href="/style.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
    }
    
    .campaign-interface {
      display: flex;
      height: 100vh;
      width: 100vw;
    }
    
    /* Left Sidebar */
    .left-sidebar {
      width: 280px;
      background: #2c2c2c;
      border-right: 1px solid #444;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .campaign-header {
      padding: 15px;
      background: #333;
      border-bottom: 1px solid #444;
    }
    
    .campaign-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .campaign-system {
      font-size: 12px;
      color: #aaa;
    }
    
    .sidebar-tabs {
      display: flex;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
    }
    
    .sidebar-tab {
      flex: 1;
      padding: 10px 5px;
      text-align: center;
      background: #2a2a2a;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 11px;
      border-right: 1px solid #444;
    }
    
    .sidebar-tab:last-child {
      border-right: none;
    }
    
    .sidebar-tab.active {
      background: #0066cc;
      color: white;
    }
    
    .sidebar-tab:hover:not(.active) {
      background: #333;
    }
    
    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    
    .content-section {
      display: none;
    }
    
    .content-section.active {
      display: block;
    }
    
    /* Main Canvas Area */
    .main-canvas {
      flex: 1;
      position: relative;
      background: #1a1a1a;
      overflow: hidden;
    }
    
    .canvas-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      display: flex;
      gap: 5px;
    }
    
    .tool-group {
      display: flex;
      background: rgba(44, 44, 44, 0.9);
      border-radius: 5px;
      padding: 5px;
      gap: 2px;
    }
    
    .tool-btn {
      width: 35px;
      height: 35px;
      background: #444;
      border: none;
      border-radius: 3px;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    
    .tool-btn:hover {
      background: #555;
    }
    
    .tool-btn.active {
      background: #0066cc;
      color: white;
    }
    
    .map-ui-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      pointer-events: none;
      z-index: 10;
    }
    
    .zoom-indicator, .coordinates-indicator, .help-toggle {
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        margin-bottom: 5px;
        font-family: monospace;
      }
      
      .help-toggle {
        cursor: pointer;
        pointer-events: auto;
        text-align: center;
        width: 20px;
        font-weight: bold;
      }
      
      .help-toggle:hover {
        background: rgba(0, 0, 0, 0.9);
      }
      
      .help-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        border-radius: 8px;
        padding: 0;
        max-width: 300px;
        z-index: 20;
        border: 1px solid #555;
      }
      
      .help-header {
        background: #333;
        padding: 10px;
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: bold;
      }
      
      .help-header button {
        background: none;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0;
      }
      
      /* Loading spinner animation */
      .loading-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #ffffff;
        border-top: 2px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* Map loading and error styles */
      .map-load-error {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      
      #map-loading-indicator {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        width: 20px;
        height: 20px;
      }
      
      .help-content {
        padding: 15px;
      }
      
      .help-section {
        margin-bottom: 15px;
      }
      
      .help-section:last-child {
        margin-bottom: 0;
      }
      
      .help-section h4 {
        margin: 0 0 8px 0;
        color: #4a90e2;
        font-size: 14px;
      }
      
      .help-section ul {
        margin: 0;
        padding-left: 15px;
        font-size: 12px;
        line-height: 1.4;
      }
      
      .help-section li {
        margin-bottom: 4px;
      }
    
    .map-viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background: #1a1a1a;
      cursor: default;
      user-select: none;
      min-height: 600px;
    }
    
    .map-grid {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 2000px;
      height: 2000px;
      margin-left: -1000px;
      margin-top: -1000px;
      background-color: #2a2a2a;
      background-image: 
        linear-gradient(rgba(255,255,255,0.15) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.15) 1px, transparent 1px);
      background-size: 50px 50px;
      transform-origin: 0 0;
    }
    
    /* Map Layers System */
    .map-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .map-layer.active {
      pointer-events: auto;
    }
    
    #map-layer {
      z-index: 1;
    }
    
    #walls-layer {
      z-index: 2;
    }
    
    #tokens-layer {
      z-index: 3;
    }
    
    #gm-layer {
      z-index: 4;
      opacity: 0.7;
    }

    #audio-layer {
      z-index: 5;
      opacity: 0.8;
    }

    #props-layer {
      z-index: 6;
      opacity: 0.9;
    }

    .layer-hidden {
      display: none !important;
    }
    
    /* Map Assets */
    .map-asset {
      user-select: none;
      transition: all 0.2s ease;
    }
    
    .map-asset:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    /* Drag and Drop Visual Feedback */
    .map-viewport.drag-over {
      background-color: rgba(0, 123, 255, 0.1);
      border: 2px dashed #007bff;
    }
    
    /* Asset List Items Draggable */
    .assets-list .item[draggable="true"] {
      cursor: grab;
    }
    
    .assets-list .item[draggable="true"]:active {
      cursor: grabbing;
    }
    
    /* Layer Controls */
    .layer-controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(44, 44, 44, 0.9);
      border-radius: 5px;
      padding: 8px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    
    .layer-btn {
      width: 30px;
      height: 30px;
      background: #444;
      border: none;
      border-radius: 3px;
      color: #ccc;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      position: relative;
    }
    
    .layer-btn:hover {
      background: #555;
    }
    
    .layer-btn.active {
      background: #0066cc;
      color: white;
      border: 2px solid #4da6ff;
      box-shadow: 0 0 8px rgba(77, 166, 255, 0.5);
      transform: scale(1.1);
    }

    .layer-btn.hidden {
      opacity: 0.3;
    }

    .layer-btn {
      transition: all 0.2s ease;
    }
    
    .layer-btn::after {
      content: attr(data-layer);
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    
    .layer-btn:hover::after {
      opacity: 1;
    }
    
    /* Right Panel */
    .right-panel {
      width: 300px;
      background: #2c2c2c;
      border-left: 1px solid #444;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .panel-tabs {
      display: flex;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
    }
    
    .panel-tab {
      flex: 1;
      padding: 10px 5px;
      text-align: center;
      background: #2a2a2a;
      border: none;
      color: #ccc;
      cursor: pointer;
      font-size: 11px;
      border-right: 1px solid #444;
    }
    
    .panel-tab:last-child {
      border-right: none;
    }
    
    .panel-tab.active {
      background: #0066cc;
      color: white;
    }
    
    .panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }
    
    .panel-section {
      display: none;
    }
    
    .panel-section.active {
      display: block;
    }
    
    /* Common Elements */
    .item-list {
      list-style: none;
    }
    
    .item {
      background: #333;
      margin: 5px 0;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
      border: 1px solid transparent;
    }
    
    .item:hover {
      background: #3a3a3a;
      border-color: #555;
    }
    
    .item.selected {
      border-color: #0066cc;
      background: #2a4a6a;
    }
    
    .item.selected {
      background: #4a90e2;
      color: white;
    }
    
    .item-name {
      font-weight: bold;
      margin-bottom: 3px;
    }
    
    .item-details {
      font-size: 11px;
      color: #999;
    }
    
    .item-actions {
      display: flex;
      gap: 5px;
      margin-top: 5px;
    }
    
    .item-actions button {
      background: #444;
      border: none;
      color: #ccc;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .item-actions button:hover {
      background: #555;
    }
    
    .btn {
      background: #444;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      margin: 2px;
    }
    
    .btn:hover {
      background: #555;
    }
    
    .btn.primary {
      background: #0066cc;
    }
    
    .btn.primary:hover {
      background: #0077dd;
    }
    
    .btn.danger {
      background: #cc3333;
    }
    
    .btn.danger:hover {
      background: #dd4444;
    }
    
    .input-group {
      margin: 10px 0;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 12px;
      color: #ccc;
    }
    
    .input-group input, .input-group select, .input-group textarea {
      width: 100%;
      padding: 6px;
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      color: white;
      font-size: 12px;
    }
    
    .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
      outline: none;
      border-color: #0066cc;
    }
    
    .back-button {
      position: absolute;
      bottom: 20px;
      right: 20px;
      z-index: 1001;
      background: rgba(102, 102, 102, 0.9);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .back-button:hover {
      background: rgba(119, 119, 119, 0.9);
    }
    
    .search-box {
      width: 100%;
      padding: 6px;
      background: #333;
      border: 1px solid #555;
      border-radius: 3px;
      color: white;
      font-size: 12px;
      margin-bottom: 10px;
    }
    
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #444;
    }
    
    .section-title {
      font-size: 14px;
      font-weight: bold;
    }
    
    .add-btn {
      background: #0066cc;
      color: white;
      border: none;
      width: 20px;
      height: 20px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .add-btn:hover {
      background: #0077dd;
    }
  </style>
</head>
<body>
  <div class="campaign-interface">
    <!-- Left Sidebar -->
    <div class="left-sidebar">
      <div class="campaign-header">
        <div class="campaign-title" id="campaign-name">Loading...</div>
        <div class="campaign-system" id="campaign-system">Loading system...</div>
      </div>
      
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="maps">Maps</button>
        <button class="sidebar-tab" data-tab="assets">Assets</button>
        <button class="sidebar-tab" data-tab="settings">Settings</button>
      </div>
      
      <div class="sidebar-content">
        <!-- Maps Section -->
        <div class="content-section active" id="maps-section">
          <div class="section-header">
            <span class="section-title">Maps</span>
            <button class="add-btn" onclick="createNewMap()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search maps..." id="maps-search">
          <ul class="item-list" id="maps-list">
            <!-- Maps will be loaded here -->
          </ul>
        </div>
        
        
        <!-- Assets Section -->
        <div class="content-section" id="assets-section">
          <div class="section-header">
            <span class="section-title">Assets</span>
            <button class="add-btn" onclick="uploadAsset()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search assets...">
          <div class="input-group">
            <label>Asset Categories</label>
            <select id="asset-category-select">
              <option value="all">All</option>
              <option value="tokens">Tokens</option>
              <option value="background">Backgrounds</option>
              <option value="props">Props</option>
              <option value="audio">Audio</option>
            </select>
          </div>
          <ul class="item-list">
            <li class="item">
              <div class="item-name">Goblin Token</div>
              <div class="item-details">32x32px</div>
            </li>
            <li class="item">
              <div class="item-name">Dungeon Tiles</div>
              <div class="item-details">Tileset</div>
            </li>
          </ul>
        </div>
        
        <!-- Settings Section -->
        <div class="content-section" id="settings-section">
          <div class="section-header">
            <span class="section-title">Campaign Settings</span>
          </div>
          <div class="input-group">
            <label>Grid Size</label>
            <select id="grid-size">
              <option value="25">25px</option>
              <option value="50" selected>50px</option>
              <option value="75">75px</option>
              <option value="100">100px</option>
            </select>
          </div>
          <div class="input-group">
            <label>Grid Color</label>
            <input type="color" value="#ffffff" id="grid-color">
          </div>
          <div class="input-group">
            <label>Grid Opacity</label>
            <input type="range" min="0" max="100" value="10" id="grid-opacity">
          </div>
          <button class="btn primary" onclick="saveSettings()">Save Settings</button>
        </div>
      </div>
    </div>
    
    <!-- Main Canvas -->
    <div class="main-canvas">
      <button class="back-button" onclick="window.location.href='/campaigns'">← Back to Campaigns</button>
      
      <div class="canvas-toolbar">
        <div class="tool-group">
          <button class="tool-btn active" data-tool="select" title="Select">⚬</button>
          <button class="tool-btn" data-tool="move" title="Move">✋</button>
          <button class="tool-btn" data-tool="draw" title="Draw">✏</button>
          <button class="tool-btn" data-tool="measure" title="Measure">📏</button>
        </div>
        
        <div class="tool-group">
          <button class="tool-btn" data-tool="token" title="Add Token">👤</button>
          <button class="tool-btn" data-tool="light" title="Lighting">💡</button>
          <button class="tool-btn" data-tool="fog" title="Fog of War">🌫</button>
        </div>
        
        <div class="tool-group">
          <button class="tool-btn" data-tool="zoom-in" title="Zoom In">+</button>
          <button class="tool-btn" data-tool="zoom-out" title="Zoom Out">-</button>
          <button class="tool-btn" data-tool="zoom-fit" title="Fit to Screen">⚏</button>
        </div>
      </div>
      
      <div class="map-viewport" id="map-viewport">
        <div class="map-grid" id="map-grid">
          <!-- Layer system like Roll20 -->
          <div class="map-layer" id="map-layer" data-layer="map">
            <!-- Background images and map content -->
          </div>
          <div class="map-layer" id="walls-layer" data-layer="walls">
            <!-- Walls, doors, and lighting objects -->
          </div>
          <div class="map-layer" id="tokens-layer" data-layer="tokens">
            <!-- Player tokens and NPCs -->
          </div>
          <div class="map-layer" id="gm-layer" data-layer="gm">
            <!-- GM-only content, notes, hidden objects -->
          </div>
          <div class="map-layer" id="audio-layer" data-layer="audio">
            <!-- Audio sources and ambient sounds -->
          </div>
          <div class="map-layer" id="props-layer" data-layer="props">
            <!-- Props and decorative objects -->
          </div>
        </div>
        
        <!-- Layer Controls -->
         <div class="layer-controls">
           <button class="layer-btn active" data-layer="Map" data-target="map-layer" title="Map Layer">🗺️</button>
           <button class="layer-btn active" data-layer="Walls" data-target="walls-layer" title="Walls & Lighting">🧱</button>
           <button class="layer-btn active" data-layer="Tokens" data-target="tokens-layer" title="Tokens Layer">👤</button>
           <button class="layer-btn active" data-layer="GM" data-target="gm-layer" title="GM Layer">👁️</button>
           <button class="layer-btn active" data-layer="Audio" data-target="audio-layer" title="Audio Layer">🔊</button>
           <button class="layer-btn active" data-layer="Props" data-target="props-layer" title="Props Layer">🎭</button>
         </div>
        
        <!-- Map UI Overlays -->
        <div class="map-ui-overlay">
          <div class="zoom-indicator" id="zoom-indicator">100%</div>
          <div class="coordinates-indicator" id="coordinates-indicator">X: 0, Y: 0</div>
          <div class="selection-info" id="selection-info" style="position: absolute; bottom: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: white; padding: 5px 10px; border-radius: 3px; font-size: 12px; z-index: 1000;"></div>
          <div class="help-toggle" id="help-toggle" onclick="toggleHelp()">?</div>
        </div>
        
        <!-- Help Panel -->
        <div class="help-panel" id="help-panel" style="display: none;">
          <div class="help-header">
            <span>Navigation Help</span>
            <button onclick="toggleHelp()">×</button>
          </div>
          <div class="help-content">
            <div class="help-section">
               <h4>Mouse Controls (Roll20 Style):</h4>
               <ul>
                 <li><strong>Mouse Wheel:</strong> Zoom in/out</li>
                 <li><strong>Right Click + Drag:</strong> Pan map</li>
                 <li><strong>Left Click:</strong> Select/interact with elements</li>
               </ul>
             </div>
            <div class="help-section">
              <h4>Keyboard Shortcuts:</h4>
              <ul>
                <li><strong>+ / =:</strong> Zoom in</li>
                <li><strong>-:</strong> Zoom out</li>
                <li><strong>0:</strong> Fit to screen</li>
                <li><strong>Space:</strong> Select tool</li>
                <li><strong>1:</strong> Select Map layer</li>
                <li><strong>2:</strong> Select Walls layer</li>
                <li><strong>3:</strong> Select Tokens layer</li>
                <li><strong>4:</strong> Select GM layer</li>
                <li><strong>5:</strong> Select Audio layer</li>
                <li><strong>6:</strong> Select Props layer</li>
              </ul>
            </div>
            <div class="help-section">
              <h4>Layer System (Roll20 Style):</h4>
              <ul>
                <li><strong>🗺️ Map:</strong> Background images and terrain</li>
                <li><strong>🧱 Walls:</strong> Walls, doors, and lighting</li>
                <li><strong>👤 Tokens:</strong> Player characters and NPCs</li>
                <li><strong>👁️ GM:</strong> GM-only notes and objects</li>
                <li><strong>🔊 Audio:</strong> Sound effects and ambient audio</li>
                <li><strong>🎭 Props:</strong> Decorative objects and props</li>
                <li><strong>Left Click:</strong> Select active layer (exclusive)</li>
                <li><strong>Right Click:</strong> Toggle layer visibility</li>
                <li><strong>Keys 1-6:</strong> Quick layer selection</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Right Panel -->
    <div class="right-panel">
      <div class="panel-tabs">
        <button class="panel-tab active" data-panel="tokens">Tokens</button>
        <button class="panel-tab" data-panel="journal">Journal</button>
        <button class="panel-tab" data-panel="chat">Chat</button>
      </div>
      
      <div class="panel-content">
        <!-- Tokens Panel -->
        <div class="panel-section active" id="tokens-panel">
          <div class="section-header">
            <span class="section-title">Active Tokens</span>
          </div>
          <input type="text" class="search-box" placeholder="Search active tokens...">
          <ul class="item-list" id="tokens-list">
            <!-- Active tokens on the map will appear here dynamically -->
          </ul>
          <!-- Token Sheet Modal -->
          <div id="token-sheet-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#222; color:white; border-radius:8px; box-shadow:0 4px 24px rgba(0,0,0,0.7); z-index:10001; min-width:400px; max-width:600px; max-height:80vh; overflow-y:auto; padding:24px;">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
              <span id="token-sheet-modal-title" style="font-size:18px; font-weight:bold;">Token Sheet</span>
              <button onclick="closeTokenSheetModal()" style="background:none; border:none; color:white; font-size:20px; cursor:pointer;">×</button>
            </div>
            <form id="token-sheet-form" onsubmit="saveTokenSheet(event)">
              <input type="hidden" id="token-sheet-id">
              <input type="hidden" id="token-sheet-token-id">
              <div class="input-group">
                <label for="token-sheet-name">Name</label>
                <input type="text" id="token-sheet-name" required style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px;">
              </div>
              <!-- Dynamic content will be inserted here -->
              <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:18px;">
                <button type="button" onclick="deleteTokenSheet()" id="token-sheet-delete-btn" style="background:#c0392b; color:white; border:none; border-radius:3px; padding:6px 14px; display:none;">Delete</button>
                <button type="submit" style="background:#0066cc; color:white; border:none; border-radius:3px; padding:6px 14px;">Save</button>
              </div>
            </form>
          </div>
        </div>
        
        <!-- Journal Panel -->
        <div class="panel-section" id="journal-panel">
          <div class="section-header">
            <span class="section-title">Journal</span>
            <button class="add-btn" onclick="addJournalEntry()">+</button>
          </div>
          <input type="text" class="search-box" placeholder="Search journal...">
          <ul class="item-list">
            <li class="item">
              <div class="item-name">Session Notes</div>
              <div class="item-details">Last updated: Today</div>
            </li>
            <li class="item">
              <div class="item-name">NPC: Tavern Keeper</div>
              <div class="item-details">Character sheet</div>
            </li>
          </ul>
        </div>
        
        <!-- Chat Panel -->
        <div class="panel-section" id="chat-panel">
          <div class="section-header">
            <span class="section-title">Chat</span>
          </div>
          <div id="chat-messages" style="height: 300px; overflow-y: auto; background: #1a1a1a; padding: 10px; border-radius: 3px; margin-bottom: 10px;">
            <div style="margin-bottom: 10px; padding: 5px; background: #333; border-radius: 3px;">
              <strong>GM:</strong> Welcome to the campaign!
            </div>
            <div style="margin-bottom: 10px; padding: 5px; background: #2a4a2a; border-radius: 3px;">
              <strong>Player1:</strong> Ready to start!
            </div>
          </div>
          <div style="display: flex; gap: 5px;">
            <input type="text" id="chat-input" placeholder="Type a message..." style="flex: 1; padding: 6px; background: #333; border: 1px solid #555; border-radius: 3px; color: white;">
            <button class="btn primary" onclick="sendChatMessage()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // ===== PFVTT MAP SYSTEM - ENHANCED VERSION =====
    // Robust error handling and validation
    // ===== TOKEN SHEET LOGIC =====
    // Debouncing mechanism to prevent excessive API calls
    let loadTokensTimeout = null;
    let isLoadingTokens = false;
    
    async function loadActiveTokensAndSheets(forceReload = false) {
      const mapId = MapState.getCurrentMapId();
      if (!mapId) {
        Logger.warn('No map ID available for loading tokens');
        return;
      }
      
      // Prevent multiple simultaneous calls
      if (isLoadingTokens && !forceReload) {
        Logger.debug('Token loading already in progress, skipping duplicate call');
        return;
      }
      
      // Clear any pending timeout
      if (loadTokensTimeout) {
        clearTimeout(loadTokensTimeout);
        loadTokensTimeout = null;
      }
      
      // If not forcing reload, debounce the call
      if (!forceReload) {
        loadTokensTimeout = setTimeout(() => {
          loadActiveTokensAndSheets(true);
        }, 1100); // 1100ms debounce to work with backend rate limiting
        return;
      }
      
      isLoadingTokens = true;
      
      try {
        Logger.info(`Loading tokens for map ID: ${mapId}`);
        
        // Load tokens and sheets in parallel with timeout and retry logic
        let tokensRes, sheetsRes;
        let retryCount = 0;
        const maxRetries = 3;
        
        while (retryCount < maxRetries) {
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            [tokensRes, sheetsRes] = await Promise.all([
              fetch(`/api/map-tokens?map_id=${encodeURIComponent(mapId)}`, {
                signal: controller.signal,
                headers: {
                  'Content-Type': 'application/json'
                }
              }),
              fetch(`/api/token-sheets?map_id=${encodeURIComponent(mapId)}`, {
                signal: controller.signal,
                headers: {
                  'Content-Type': 'application/json'
                }
              })
            ]);
            
            clearTimeout(timeoutId);
            break; // Success, exit retry loop
            
          } catch (fetchError) {
            retryCount++;
            Logger.warn(`Fetch attempt ${retryCount} failed:`, fetchError.message);
            
            if (retryCount >= maxRetries) {
              throw new Error(`Failed to fetch data after ${maxRetries} attempts: ${fetchError.message}`);
            }
            
            // Exponential backoff: wait 1s, 2s, 4s
            const delay = Math.pow(2, retryCount - 1) * 1000;
            Logger.info(`Retrying in ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
        
        // Check response status
        if (!tokensRes.ok) {
          if (tokensRes.status === 429) {
            Logger.warn('Rate limit exceeded for tokens, retrying in 1200ms');
            setTimeout(() => loadActiveTokensAndSheets(true), 1200);
            return;
          }
          if (tokensRes.status === 504) {
            Logger.warn('Backend timeout for tokens, retrying in 2000ms');
            setTimeout(() => loadActiveTokensAndSheets(true), 2000);
            return;
          }
          throw new Error(`Failed to fetch tokens: ${tokensRes.status} ${tokensRes.statusText}`);
        }
        
        if (!sheetsRes.ok) {
          if (sheetsRes.status === 504) {
            Logger.warn('Backend timeout for sheets, continuing with tokens only');
            // Continue with empty sheets array
          } else {
            throw new Error(`Failed to fetch token sheets: ${sheetsRes.status} ${sheetsRes.statusText}`);
          }
        }
        
        // Parse response texts with error handling
        let tokensText, sheetsText;
        try {
          const textPromises = [tokensRes.text()];
          if (sheetsRes.ok) {
            textPromises.push(sheetsRes.text());
          }
          
          const textResults = await Promise.all(textPromises);
          tokensText = textResults[0];
          sheetsText = textResults[1] || '{"success": true, "sheets": []}';
        } catch (textError) {
          Logger.error('Failed to read response text:', textError);
          throw new Error('Failed to read API response');
        }
        
        Logger.debug('Tokens response text:', tokensText);
        Logger.debug('Sheets response text:', sheetsText);
        
        // Parse JSON with comprehensive error handling
        let tokensData, sheetsData;
        try {
          // Validate tokens response
          if (!tokensText || tokensText.trim() === '') {
            throw new Error('Empty tokens response');
          }
          
          tokensData = JSON.parse(tokensText);
          if (!tokensData || typeof tokensData !== 'object') {
            throw new Error('Invalid tokens data structure');
          }
          
          if (typeof tokensData.success !== 'boolean') {
            throw new Error('Missing success field in tokens response');
          }
          
          if (!tokensData.success) {
            throw new Error(`Tokens API error: ${tokensData.error || 'Unknown error'}`);
          }
          
          // Validate sheets response
          if (!sheetsText || sheetsText.trim() === '') {
            Logger.warn('Empty sheets response, using default');
            sheetsData = { success: true, sheets: [] };
          } else {
            sheetsData = JSON.parse(sheetsText);
            if (!sheetsData || typeof sheetsData !== 'object') {
              Logger.warn('Invalid sheets data structure, using default');
              sheetsData = { success: true, sheets: [] };
            }
          }
          
        } catch (parseError) {
          Logger.error('Failed to parse JSON response', parseError);
          Logger.error('Tokens response was:', tokensText);
          Logger.error('Sheets response was:', sheetsText);
          throw new Error(`Invalid JSON response from API endpoints: ${parseError.message}`);
        }
        
        // Validate and extract data arrays
        const tokens = Array.isArray(tokensData.tokens) ? tokensData.tokens : [];
        const sheets = Array.isArray(sheetsData.sheets) ? sheetsData.sheets : [];
        
        // Validate token objects
        const validTokens = tokens.filter(token => {
          if (!token || typeof token !== 'object') {
            Logger.warn('Invalid token object:', token);
            return false;
          }
          if (!token.id || !token.name) {
            Logger.warn('Token missing required fields:', token);
            return false;
          }
          return true;
        });
        Logger.info(`Loaded ${validTokens.length}/${tokens.length} valid tokens and ${sheets.length} token sheets`);
        
        // Update UI with validated tokens
        try {
          const list = document.getElementById('tokens-list');
          if (!list) {
            Logger.error('tokens-list element not found');
            throw new Error('UI container not found');
          }
          
          list.innerHTML = '';
          
          if (validTokens.length === 0) {
            const li = document.createElement('li');
            li.className = 'item';
            li.innerHTML = `<div class='item-name' style='color: #999; font-style: italic;'>No valid tokens on this map</div>`;
            list.appendChild(li);
          } else {
            validTokens.forEach(token => {
              try {
                const li = document.createElement('li');
                li.className = 'item';
                
                // Safely find associated sheet
                const tokenSheet = sheets.find(s => s && s.map_token_id === token.id) || null;
                
                // Validate token data before creating UI
                const tokenName = escapeHtml(token.name || 'Token');
                const tokenId = parseInt(token.id);
                
                if (isNaN(tokenId)) {
                  Logger.warn(`Invalid token ID: ${token.id}`);
                  return;
                }
                
                // Safely serialize objects for onclick handlers
                let tokenJson, sheetJson;
                try {
                  tokenJson = JSON.stringify(token);
                  sheetJson = JSON.stringify(tokenSheet);
                } catch (serializeError) {
                  Logger.error(`Failed to serialize token data for ${token.id}:`, serializeError);
                  return;
                }
                
                li.innerHTML = `<div class='item-name'>${tokenName}</div><div class='item-details'>ID: ${tokenId} <button style='background:#444; color:white; border:none; border-radius:3px; padding:2px 8px; cursor:pointer; margin-left:8px;' onclick='openTokenSheetModal(${tokenJson}, ${sheetJson})'>Sheet</button><button style='background:#0066cc; color:white; border:none; border-radius:3px; padding:2px 8px; cursor:pointer; margin-left:4px;' onclick='centerOnToken(${tokenId})'>Center</button></div>`;
                list.appendChild(li);
              } catch (tokenError) {
                Logger.error(`Failed to create UI element for token ${token.id}:`, tokenError);
              }
            });
          }
        } catch (uiError) {
          Logger.error('Failed to update tokens UI:', uiError);
          throw new Error('Failed to update user interface');
        }
        
        Logger.info('Tokens and sheets loaded successfully');
        
      } catch (e) { 
        Logger.error('Failed to load tokens or sheets', e);
        
        // Show user-friendly message in the tokens list
        const list = document.getElementById('tokens-list');
        if (list) {
          list.innerHTML = `<li class='item'><div class='item-name' style='color: #dc3545;'>Error loading tokens</div><div class='item-details' style='color: #999; font-size: 11px;'>${escapeHtml(e.message)}</div></li>`;
        }
      } finally {
        isLoadingTokens = false;
      }
    }
    async function openTokenSheetModal(token, sheet) {
      // If no sheet exists, auto-create one based on campaign game rules
      if (!sheet) {
        try {
          Logger.info(`Auto-creating sheet for token ${token.id} (${token.name})`);
          
          const response = await fetch('/api/token-sheets/auto-create', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              map_token_id: token.id,
              token_name: token.name || 'Token'
            })
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.success) {
              Logger.info(`Auto-created sheet with ID ${result.id} for system: ${result.system}`);
              
              // Create a sheet object with the new data
              sheet = {
                id: result.id,
                map_token_id: token.id,
                sheet_json: result.sheet_json,
                system: result.system
              };
              
              // Refresh the tokens list to show the new sheet
              loadActiveTokensAndSheets(); // Debounced call after delete
            } else {
              Logger.error('Failed to auto-create sheet:', result.error);
              alert('Failed to create character sheet: ' + result.error);
              return;
            }
          } else if (response.status === 409) {
            // Sheet already exists, reload and try again
            Logger.info('Sheet already exists, reloading...');
            await loadActiveTokensAndSheets(true); // Force reload
            return;
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          Logger.error('Error auto-creating sheet:', error);
          alert('Failed to create character sheet: ' + error.message);
          return;
        }
      }
      
      document.getElementById('token-sheet-modal').style.display = 'block';
      document.getElementById('token-sheet-modal-title').textContent = sheet ? 'Edit Token Sheet' : 'Create Token Sheet';
      document.getElementById('token-sheet-id').value = sheet ? sheet.id : '';
      document.getElementById('token-sheet-token-id').value = token.id;
      
      // Parse sheet_json if it exists
      let sheetData = {};
      if (sheet && sheet.sheet_json) {
        try {
          sheetData = typeof sheet.sheet_json === 'string' ? JSON.parse(sheet.sheet_json) : sheet.sheet_json;
        } catch (e) {
          Logger.warn('Failed to parse sheet JSON', e);
        }
      }
      
      // Display the sheet in a more user-friendly format
      displayDynamicSheet(sheetData, token, sheet ? sheet.system : null);
      
      document.getElementById('token-sheet-delete-btn').style.display = sheet ? 'inline-block' : 'none';
    }
    function closeTokenSheetModal() {
      document.getElementById('token-sheet-modal').style.display = 'none';
    }
    
    // Custom input dialog to replace prompt()
    function showInputDialog(message, placeholder = '') {
      return new Promise((resolve) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          z-index: 10002;
          display: flex;
          align-items: center;
          justify-content: center;
        `;
        
        // Create modal content
        const modal = document.createElement('div');
        modal.style.cssText = `
          background: #222;
          color: white;
          border-radius: 8px;
          padding: 24px;
          min-width: 300px;
          max-width: 500px;
          box-shadow: 0 4px 24px rgba(0, 0, 0, 0.7);
        `;
        
        modal.innerHTML = `
          <h3 style="margin: 0 0 16px 0; font-size: 18px;">${message}</h3>
          <input type="text" id="input-dialog-field" placeholder="${placeholder}" style="
            width: 100%;
            padding: 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 14px;
          ">
          <div style="display: flex; gap: 8px; justify-content: flex-end;">
            <button id="input-dialog-cancel" style="
              background: #666;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
            ">Cancel</button>
            <button id="input-dialog-ok" style="
              background: #0066cc;
              color: white;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
            ">OK</button>
          </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const inputField = document.getElementById('input-dialog-field');
        const okButton = document.getElementById('input-dialog-ok');
        const cancelButton = document.getElementById('input-dialog-cancel');
        
        // Focus the input field
        inputField.focus();
        
        // Handle OK button
        const handleOk = () => {
          const value = inputField.value.trim();
          document.body.removeChild(overlay);
          resolve(value || null);
        };
        
        // Handle Cancel button
        const handleCancel = () => {
          document.body.removeChild(overlay);
          resolve(null);
        };
        
        // Event listeners
        okButton.addEventListener('click', handleOk);
        cancelButton.addEventListener('click', handleCancel);
        
        // Handle Enter key
        inputField.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            handleOk();
          } else if (e.key === 'Escape') {
            handleCancel();
          }
        });
        
        // Handle clicking outside modal
        overlay.addEventListener('click', (e) => {
          if (e.target === overlay) {
            handleCancel();
          }
        });
      });
    }
    async function saveTokenSheet(e) {
      e.preventDefault();
      const id = document.getElementById('token-sheet-id').value;
      const token_id = document.getElementById('token-sheet-token-id').value;
      const name = document.getElementById('token-sheet-name').value;
      const map_id = MapState.getCurrentMapId();
      
      // Collect data from dynamic form fields
      const sheetJson = { name: name };
      
      // Check if we have dynamic fields (system-specific sheet)
      const dynamicContainer = document.querySelector('.dynamic-sheet-content');
      if (dynamicContainer) {
        // Collect all data-field inputs
        const fieldInputs = dynamicContainer.querySelectorAll('[data-field]');
        
        fieldInputs.forEach(input => {
          const fieldPath = input.getAttribute('data-field');
          const value = input.type === 'number' ? (parseFloat(input.value) || 0) : input.value;
          
          // Set nested object properties (e.g., "attributes.strength")
          const pathParts = fieldPath.split('.');
          let current = sheetJson;
          
          for (let i = 0; i < pathParts.length - 1; i++) {
            if (!current[pathParts[i]]) {
              current[pathParts[i]] = {};
            }
            current = current[pathParts[i]];
          }
          
          current[pathParts[pathParts.length - 1]] = value;
        });
      } else {
        // Fallback to content field for generic sheets
        const contentField = document.getElementById('token-sheet-content');
        if (contentField) {
          sheetJson.content = contentField.value;
        }
      }
      
      try {
        if (id) {
          await fetch(`/api/token-sheets/${id}`, {method:'PUT', headers:{'Content-Type':'application/json'}, body:JSON.stringify({sheet_json: sheetJson, actor_id: null})});
        } else {
          await fetch(`/api/token-sheets`, {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({map_token_id: token_id, actor_id: null, sheet_json: sheetJson})});
        }
        closeTokenSheetModal();
        loadActiveTokensAndSheets(); // Debounced call after save
      } catch (e) { Logger.error('Failed to save token sheet', e); }
    }
    async function deleteTokenSheet() {
      const id = document.getElementById('token-sheet-id').value;
      if (!id) return;
      if (!confirm('Delete this token sheet?')) return;
      try {
        await fetch(`/api/token-sheets/${id}`, {method:'DELETE'});
        closeTokenSheetModal();
        loadActiveTokensAndSheets();
      } catch (e) { Logger.error('Failed to delete token sheet', e); }
    }
    function escapeHtml(str) {
      return String(str).replace(/[&<>\"]/g, function(s) { return ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'})[s]; });
    }
    
    function displayDynamicSheet(sheetData, token, system) {
      const nameField = document.getElementById('token-sheet-name');
      const contentField = document.getElementById('token-sheet-content');
      
      // Set the character name
      nameField.value = sheetData.name || token.name || 'Token';
      
      // Create dynamic form based on system
      const formContainer = document.getElementById('token-sheet-form');
      
      // Remove existing dynamic content (keep hidden fields and name field)
      const existingDynamic = formContainer.querySelector('.dynamic-sheet-content');
      if (existingDynamic) {
        existingDynamic.remove();
      }
      
      // Create dynamic content container
      const dynamicContainer = document.createElement('div');
      dynamicContainer.className = 'dynamic-sheet-content';
      
      if (system && sheetData.attributes) {
        // Display system-specific fields
        dynamicContainer.innerHTML = createSystemSpecificForm(sheetData, system);
      } else {
        // Fallback to generic content field
        dynamicContainer.innerHTML = `
          <div class="input-group">
            <label for="token-sheet-content">Content</label>
            <textarea id="token-sheet-content" rows="8" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px;">${escapeHtml(sheetData.content || '')}</textarea>
          </div>
        `;
      }
      
      // Insert dynamic content after the name field
      const nameGroup = nameField.closest('.input-group');
      nameGroup.parentNode.insertBefore(dynamicContainer, nameGroup.nextSibling);
    }
    
    function createSystemSpecificForm(sheetData, system) {
      let html = '';
      
      // Add system indicator
      html += `<div style="margin-bottom: 12px; padding: 6px; background: #444; border-radius: 3px; font-size: 12px; color: #ccc;">System: ${escapeHtml(system)}</div>`;
      
      if (sheetData.attributes) {
        // Core attributes section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Attributes</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">';
        
        Object.entries(sheetData.attributes).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1);
          html += `
            <div class="input-group" style="margin-bottom: 4px;">
              <label style="font-size: 12px; color: #ccc;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="attributes.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:4px; font-size: 12px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      if (sheetData.skills && Object.keys(sheetData.skills).length > 0) {
        // Skills section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Skills</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">';
        
        Object.entries(sheetData.skills).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
          html += `
            <div style="display: flex; align-items: center; gap: 4px;">
              <label style="font-size: 11px; color: #ccc; flex: 1;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="skills.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:50px; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:2px; font-size: 11px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      if (sheetData.combat) {
        // Combat stats section
        html += '<div style="margin-bottom: 16px;"><h4 style="margin: 0 0 8px 0; color: #fff; font-size: 14px;">Combat</h4>';
        html += '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">';
        
        Object.entries(sheetData.combat).forEach(([key, value]) => {
          const displayName = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
          html += `
            <div class="input-group" style="margin-bottom: 4px;">
              <label style="font-size: 12px; color: #ccc;">${escapeHtml(displayName)}</label>
              <input type="number" data-field="combat.${escapeHtml(key)}" value="${escapeHtml(value)}" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:4px; font-size: 12px;">
            </div>
          `;
        });
        
        html += '</div></div>';
      }
      
      // Notes section
      html += `
        <div class="input-group">
          <label style="font-size: 12px; color: #ccc;">Notes</label>
          <textarea data-field="notes" rows="4" style="width:100%; background:#333; color:white; border:1px solid #555; border-radius:3px; padding:6px; font-size: 12px;">${escapeHtml(sheetData.notes || '')}</textarea>
        </div>
      `;
      
      return html;
    }

    
    // Global state management with validation
    const MapState = {
      campaignId: null,
      currentMapId: null,
      currentTool: 'select',
      currentLayer: 'tokens',
      zoom: 1,
      pan: { x: 0, y: 0 },
      isDragging: false,
      lastMouse: { x: 0, y: 0 },
      gridSize: 50,
      assets: [],
      campaignSettings: {},
      
      // Validation methods
      isValidCampaignId(id) {
        return id && typeof id === 'string' && id.trim().length > 0;
      },
      
      isValidCoordinates(x, y) {
        return typeof x === 'number' && typeof y === 'number' && 
               !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y);
      },
      
      isValidZoom(zoom) {
        return typeof zoom === 'number' && zoom >= 0.1 && zoom <= 5;
      },
      
      // Safe getters with fallbacks
      getCampaignId() {
        if (!this.campaignId) {
          this.campaignId = sessionStorage.getItem('current_campaign_id') || 
                           new URLSearchParams(window.location.search).get('campaign_id');
        }
        return this.campaignId;
      },
      
      getCurrentMapId() {
        if (!this.currentMapId) {
          this.currentMapId = sessionStorage.getItem('current_map_id');
        }
        return this.currentMapId;
      }
    };
    
    // Enhanced error handling and logging
    const Logger = {
      error(message, error = null) {
        console.error(`[PFVTT Map Error] ${message}`, error);
        this.showUserError(message);
      },
      
      warn(message) {
        console.warn(`[PFVTT Map Warning] ${message}`);
      },
      
      info(message) {
        console.info(`[PFVTT Map Info] ${message}`);
      },
      
      debug(message, data = null) {
        if (window.DEBUG_MODE) {
          console.log(`[PFVTT Map Debug] ${message}`, data);
        }
      },
      
      showUserError(message) {
        // Create a non-blocking error notification
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed; top: 20px; right: 20px; z-index: 10000;
          background: #dc3545; color: white; padding: 12px 16px;
          border-radius: 4px; max-width: 300px; font-size: 14px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.parentNode.removeChild(errorDiv);
          }
        }, 5000);
      }
    };
    
    // Initialize and validate campaign
    function initializeCampaign() {
      try {
        const campaignId = MapState.getCampaignId();
        
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('No valid campaign selected');
          window.location.href = '/campaigns';
          return false;
        }
        
        Logger.info(`Initializing campaign: ${campaignId}`);
        return true;
      } catch (error) {
        Logger.error('Failed to initialize campaign', error);
        return false;
      }
    }
    
    // Initialize campaign on load
    if (!initializeCampaign()) {
      // Stop execution if campaign initialization fails
      throw new Error('Campaign initialization failed');
    }
    
    // Tab switching for sidebar
    document.querySelectorAll('.sidebar-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Remove active class from all tabs and sections
        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.content-section').forEach(s => s.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding section
        this.classList.add('active');
        document.getElementById(this.dataset.tab + '-section').classList.add('active');
      });
    });
    
    // Tab switching for right panel
    document.querySelectorAll('.panel-tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Remove active class from all tabs and sections
        document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel-section').forEach(s => s.classList.remove('active'));
        
        // Add active class to clicked tab and corresponding section
        this.classList.add('active');
        document.getElementById(this.dataset.panel + '-panel').classList.add('active');
      });
    });
    
    // ===== ENHANCED TOOL MANAGEMENT SYSTEM =====
    
    const ToolManager = {
      currentTool: 'select',
      validTools: ['select', 'move', 'measure', 'draw', 'erase', 'token'],
      zoomTools: ['zoom-in', 'zoom-out', 'zoom-fit'],
      toolCursors: {
        'select': 'grab',
        'move': 'move',
        'measure': 'crosshair',
        'draw': 'crosshair',
        'erase': 'crosshair',
        'token': 'pointer'
      },
      
      isValidTool(tool) {
        return this.validTools.includes(tool) || this.zoomTools.includes(tool);
      },
      
      isZoomTool(tool) {
        return this.zoomTools.includes(tool);
      },
      
      selectTool(tool) {
        try {
          if (!this.isValidTool(tool)) {
            Logger.warn(`Invalid tool: ${tool}`);
            return false;
          }
          
          // Handle zoom tools separately
          if (this.isZoomTool(tool)) {
            this.handleZoomTool(tool);
            return true;
          }
          
          // Remove active class from all tools
          document.querySelectorAll('.tool-btn').forEach(btn => {
            try {
              btn.classList.remove('active');
            } catch (error) {
              Logger.warn('Error removing active class from tool button', error);
            }
          });
          
          // Add active class to selected tool
          const selectedTool = document.querySelector(`[data-tool="${tool}"]`);
          if (selectedTool) {
            selectedTool.classList.add('active');
          }
          
          // Update current tool in all places for compatibility
          this.currentTool = tool;
          MapState.currentTool = tool;
          window.currentTool = tool; // Legacy compatibility
          
          // Update cursor
          this.updateCursor();
          
          // Tool-specific initialization
          this.onToolChange(tool);
          
          // Save current tool in session
          try {
            sessionStorage.setItem('current_map_tool', tool);
          } catch (error) {
            Logger.warn('Failed to save tool to session storage', error);
          }
          
          Logger.debug(`Selected tool: ${tool}`);
          return true;
          
        } catch (error) {
          Logger.error(`Failed to select tool: ${tool}`, error);
          return false;
        }
      },
      
      handleZoomTool(tool) {
        try {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            Logger.error('Map viewport not found');
            return false;
          }
          
          const rect = viewport.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          handleZoom(tool, centerX, centerY);
          return true;
        } catch (error) {
          Logger.error(`Failed to handle zoom tool: ${tool}`, error);
          return false;
        }
      },
      
      updateCursor() {
        try {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            Logger.warn('Map viewport not found for cursor update');
            return;
          }
          
          const cursor = this.toolCursors[this.currentTool] || 'grab';
          viewport.style.cursor = cursor;
        } catch (error) {
          Logger.warn('Failed to update cursor', error);
        }
      },
      
      onToolChange(tool) {
        // Tool-specific logic
        switch(tool) {
          case 'measure':
            this.initializeMeasureTool();
            break;
          case 'draw':
            this.initializeDrawTool();
            break;
          case 'erase':
            this.initializeEraseTool();
            break;
          case 'token':
            this.initializeTokenTool();
            break;
        }
      },
      
      initializeMeasureTool() {
        Logger.debug('Initializing measure tool');
        // Clear any existing measurements
        this.clearMeasurements();
      },
      
      initializeDrawTool() {
        Logger.debug('Initializing draw tool');
        // Set up drawing context
      },
      
      initializeEraseTool() {
        Logger.debug('Initializing erase tool');
        // Set up erase mode
      },
      
      initializeTokenTool() {
        Logger.debug('Initializing token tool');
        // Set up token placement mode
      },
      
      clearMeasurements() {
        try {
          // Remove any existing measurement overlays
          document.querySelectorAll('.measurement-line').forEach(line => {
            line.remove();
          });
        } catch (error) {
          Logger.warn('Failed to clear measurements', error);
        }
      },
      
      // Load saved tool from session
      loadSavedTool() {
        try {
          const savedTool = sessionStorage.getItem('current_map_tool');
          if (savedTool && this.isValidTool(savedTool) && !this.isZoomTool(savedTool)) {
            this.selectTool(savedTool);
          } else {
            this.selectTool('select'); // Default tool
          }
        } catch (error) {
          Logger.warn('Failed to load saved tool, using default', error);
          this.selectTool('select');
        }
      }
    };
    
    // Enhanced tool selection event listeners
    document.querySelectorAll('.tool-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const tool = this.dataset.tool;
        ToolManager.selectTool(tool);
      });
    });
    
    // Legacy function wrapper for backward compatibility
    function updateCursor() {
      ToolManager.updateCursor();
    }
    
    // ===== ENHANCED MAP NAVIGATION SYSTEM =====
    
    // Enhanced map state with validation
    const MapNavigation = {
      currentZoom: 1,
      panX: 0,
      panY: 0,
      isDragging: false,
      lastMouseX: 0,
      lastMouseY: 0,
      minZoom: 0.1,
      maxZoom: 5,
      zoomStep: 1.2,
      
      // Validation methods
      isValidZoom(zoom) {
        return typeof zoom === 'number' && zoom >= this.minZoom && zoom <= this.maxZoom && !isNaN(zoom) && isFinite(zoom);
      },
      
      isValidPan(x, y) {
        return typeof x === 'number' && typeof y === 'number' && !isNaN(x) && !isNaN(y) && isFinite(x) && isFinite(y);
      },
      
      // Safe setters with validation
      setZoom(zoom) {
        if (this.isValidZoom(zoom)) {
          this.currentZoom = zoom;
          MapState.zoom = zoom;
          return true;
        }
        Logger.warn(`Invalid zoom value: ${zoom}`);
        return false;
      },
      
      setPan(x, y) {
        if (this.isValidPan(x, y)) {
          this.panX = x;
          this.panY = y;
          MapState.pan.x = x;
          MapState.pan.y = y;
          return true;
        }
        Logger.warn(`Invalid pan values: (${x}, ${y})`);
        return false;
      },
      
      // Enhanced zoom handling with error checking
      handleZoom(action, mouseX = null, mouseY = null) {
        try {
          const mapGrid = document.getElementById('map-grid');
          const viewport = document.getElementById('map-viewport');
          
          if (!mapGrid || !viewport) {
            Logger.error('Map elements not found for zoom operation');
            return false;
          }
          
          const oldZoom = this.currentZoom;
          let newZoom = oldZoom;
          
          switch(action) {
            case 'zoom-in':
              newZoom = Math.min(oldZoom * this.zoomStep, this.maxZoom);
              break;
            case 'zoom-out':
              newZoom = Math.max(oldZoom / this.zoomStep, this.minZoom);
              break;
            case 'zoom-fit':
              newZoom = 1;
              this.setPan(0, 0);
              break;
            default:
              Logger.warn(`Unknown zoom action: ${action}`);
              return false;
          }
          
          if (!this.setZoom(newZoom)) {
            return false;
          }
          
          // Zoom towards mouse position if provided
          if (mouseX !== null && mouseY !== null && action !== 'zoom-fit') {
            try {
              const rect = viewport.getBoundingClientRect();
              const centerX = rect.width / 2;
              const centerY = rect.height / 2;
              
              const zoomFactor = newZoom / oldZoom;
              const newPanX = (this.panX - (mouseX - centerX)) * zoomFactor + (mouseX - centerX);
              const newPanY = (this.panY - (mouseY - centerY)) * zoomFactor + (mouseY - centerY);
              
              this.setPan(newPanX, newPanY);
            } catch (error) {
              Logger.warn('Failed to calculate zoom-to-point, using center zoom', error);
            }
          }
          
          this.updateMapTransform();
          Logger.debug(`Zoom changed from ${oldZoom.toFixed(2)} to ${newZoom.toFixed(2)}`);
          return true;
          
        } catch (error) {
          Logger.error(`Failed to handle zoom: ${action}`, error);
          return false;
        }
      },
      
      // Enhanced transform update with error handling
      updateMapTransform() {
        try {
          const mapGrid = document.getElementById('map-grid');
          if (!mapGrid) {
            Logger.error('Map grid not found for transform update');
            return false;
          }
          
          // Validate current values before applying
          if (!this.isValidZoom(this.currentZoom) || !this.isValidPan(this.panX, this.panY)) {
            Logger.error('Invalid transform values, resetting to defaults');
            this.currentZoom = 1;
            this.panX = 0;
            this.panY = 0;
          }
          
          mapGrid.style.transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.currentZoom})`;
          
          // Update zoom indicator
          this.updateZoomIndicator();
          
          // Update coordinates indicator if mouse is over viewport
          this.updateCoordinatesIndicator();
          
          return true;
          
        } catch (error) {
          Logger.error('Failed to update map transform', error);
          return false;
        }
      },
      
      updateZoomIndicator() {
        try {
          const zoomIndicator = document.getElementById('zoom-indicator');
          if (zoomIndicator) {
            zoomIndicator.textContent = Math.round(this.currentZoom * 100) + '%';
          }
        } catch (error) {
          Logger.warn('Failed to update zoom indicator', error);
        }
      },
      
      updateCoordinatesIndicator() {
        try {
          const coordsIndicator = document.getElementById('coordinates-indicator');
          if (coordsIndicator && coordsIndicator.dataset.lastMouseX) {
            const mouseX = parseFloat(coordsIndicator.dataset.lastMouseX);
            const mouseY = parseFloat(coordsIndicator.dataset.lastMouseY);
            
            if (!isNaN(mouseX) && !isNaN(mouseY)) {
              const mapCoords = screenToMapCoordinates(mouseX, mouseY);
              const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
              
              coordsIndicator.textContent = `Map: ${Math.round(mapCoords.x)}, ${Math.round(mapCoords.y)} | Grid: ${gridCoords.x}, ${gridCoords.y}`;
            }
          }
        } catch (error) {
          Logger.warn('Failed to update coordinates indicator', error);
        }
      },
      
      // Pan handling with validation
      startDrag(mouseX, mouseY) {
        if (this.isValidPan(mouseX, mouseY)) {
          this.isDragging = true;
          this.lastMouseX = mouseX;
          this.lastMouseY = mouseY;
          MapState.isDragging = true;
          MapState.lastMouse.x = mouseX;
          MapState.lastMouse.y = mouseY;
          return true;
        }
        return false;
      },
      
      updateDrag(mouseX, mouseY) {
        if (!this.isDragging || !this.isValidPan(mouseX, mouseY)) {
          return false;
        }
        
        try {
          const deltaX = mouseX - this.lastMouseX;
          const deltaY = mouseY - this.lastMouseY;
          
          const newPanX = this.panX + deltaX;
          const newPanY = this.panY + deltaY;
          
          if (this.setPan(newPanX, newPanY)) {
            this.updateMapTransform();
            this.lastMouseX = mouseX;
            this.lastMouseY = mouseY;
            return true;
          }
        } catch (error) {
          Logger.warn('Failed to update drag', error);
        }
        
        return false;
      },
      
      endDrag() {
        this.isDragging = false;
        MapState.isDragging = false;
      },
      
      // Reset to default state
      reset() {
        this.setZoom(1);
        this.setPan(0, 0);
        this.endDrag();
        this.updateMapTransform();
        Logger.info('Map navigation reset to default state');
      }
    };
    
    // Legacy variables for backward compatibility
    let currentZoom = 1;
    let panX = 0;
    let panY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let currentTool = 'select';
    let currentMapId = sessionStorage.getItem('current_map_id') || null;
    
    // Legacy function wrappers for backward compatibility
    function handleZoom(action, mouseX = null, mouseY = null) {
      const result = MapNavigation.handleZoom(action, mouseX, mouseY);
      // Update legacy variables
      currentZoom = MapNavigation.currentZoom;
      panX = MapNavigation.panX;
      panY = MapNavigation.panY;
      return result;
    }
    
    function updateMapTransform() {
      const result = MapNavigation.updateMapTransform();
      // Update legacy variables
      currentZoom = MapNavigation.currentZoom;
      panX = MapNavigation.panX;
      panY = MapNavigation.panY;
      return result;
    }
    
    // ===== ENHANCED COORDINATE SYSTEM - ROLL20 INSPIRED =====
    
    const CoordinateSystem = {
      defaultGridSize: 50,
      
      // Validation methods
      isValidCoordinate(value) {
        return typeof value === 'number' && !isNaN(value) && isFinite(value);
      },
      
      isValidCoordinates(x, y) {
        return this.isValidCoordinate(x) && this.isValidCoordinate(y);
      },
      
      isValidGridSize(size) {
        return typeof size === 'number' && size > 0 && size <= 200 && !isNaN(size) && isFinite(size);
      },
      
      // Safe grid size getter
      getGridSize() {
        try {
          const size = MapState.campaignSettings?.gridSize || 
                      window.campaignSettings?.gridSize || 
                      this.defaultGridSize;
          
          return this.isValidGridSize(size) ? size : this.defaultGridSize;
        } catch (error) {
          Logger.warn('Failed to get grid size, using default', error);
          return this.defaultGridSize;
        }
      },
      
      // Enhanced transformation matrix with validation
      getGridTransformMatrix() {
        try {
          // Get current transformation values with fallbacks
          const scale = MapNavigation.currentZoom || currentZoom || 1;
          const translateX = MapNavigation.panX || panX || 0;
          const translateY = MapNavigation.panY || panY || 0;
          
          // Validate transformation values
          if (!this.isValidCoordinate(scale) || !this.isValidCoordinates(translateX, translateY)) {
            Logger.warn('Invalid transformation values, using defaults');
            return {
              scale: 1,
              translateX: 0,
              translateY: 0
            };
          }
          
          return {
            scale: scale,
            translateX: translateX,
            translateY: translateY
          };
        } catch (error) {
          Logger.error('Failed to get transform matrix', error);
          return {
            scale: 1,
            translateX: 0,
            translateY: 0
          };
        }
      },
      
      // Enhanced screen to map coordinate conversion
      screenToMapCoordinates(screenX, screenY) {
        try {
          if (!this.isValidCoordinates(screenX, screenY)) {
            Logger.warn(`Invalid screen coordinates: (${screenX}, ${screenY})`);
            return { x: 0, y: 0 };
          }
          
          const viewport = document.getElementById('map-viewport');
          const mapGrid = document.getElementById('map-grid');
          if (!viewport || !mapGrid) {
            Logger.error('Map viewport or grid not found for coordinate conversion');
            return { x: 0, y: 0 };
          }
          
          // Get transformation matrix
          const transform = this.getGridTransformMatrix();
          
          // Account for map-grid positioning:
          // map-grid is positioned at 50% of viewport with -1000px margin offset
          const viewportRect = viewport.getBoundingClientRect();
          const mapGridRect = mapGrid.getBoundingClientRect();
          
          // Calculate the actual offset of map-grid relative to viewport
          const gridOffsetX = mapGridRect.left - viewportRect.left;
          const gridOffsetY = mapGridRect.top - viewportRect.top;
          
          // Adjust screen coordinates to account for grid offset
          const adjustedScreenX = screenX - gridOffsetX;
          const adjustedScreenY = screenY - gridOffsetY;
          
          Logger.debug('Screen to map coordinate conversion:', {
            screenCoords: { x: screenX, y: screenY },
            viewportRect: { left: viewportRect.left, top: viewportRect.top },
            mapGridRect: { left: mapGridRect.left, top: mapGridRect.top },
            gridOffset: { x: gridOffsetX, y: gridOffsetY },
            adjustedScreen: { x: adjustedScreenX, y: adjustedScreenY }
          });
          
          // Reverse the transformation to get map coordinates
          // Since map-grid has transform-origin: 0 0, we need to account for this
          const mapX = (adjustedScreenX - transform.translateX) / transform.scale;
          const mapY = (adjustedScreenY - transform.translateY) / transform.scale;
          
          if (!this.isValidCoordinates(mapX, mapY)) {
            Logger.warn(`Invalid calculated map coordinates: (${mapX}, ${mapY})`);
            return { x: 0, y: 0 };
          }
          
          return { x: mapX, y: mapY };
        } catch (error) {
          Logger.error('Failed to convert screen to map coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced map to grid coordinate conversion
      mapToGridCoordinates(mapX, mapY) {
        try {
          if (!this.isValidCoordinates(mapX, mapY)) {
            Logger.warn(`Invalid map coordinates: (${mapX}, ${mapY})`);
            return { x: 0, y: 0 };
          }
          
          const gridSize = this.getGridSize();
          
          // Convert map coordinates to grid cell coordinates
          // Use Math.floor for consistent snapping behavior
          const gridX = Math.floor(mapX / gridSize);
          const gridY = Math.floor(mapY / gridSize);
          
          return { x: gridX, y: gridY };
        } catch (error) {
          Logger.error('Failed to convert map to grid coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced grid to map coordinate conversion
      gridToMapCoordinates(gridX, gridY) {
        try {
          if (!this.isValidCoordinates(gridX, gridY)) {
            Logger.warn(`Invalid grid coordinates: (${gridX}, ${gridY})`);
            return { x: 0, y: 0 };
          }
          
          const gridSize = this.getGridSize();
          
          // Convert grid coordinates to map coordinates (center of cell)
          const mapX = gridX * gridSize + gridSize / 2;
          const mapY = gridY * gridSize + gridSize / 2;
          
          return { x: mapX, y: mapY };
        } catch (error) {
          Logger.error('Failed to convert grid to map coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced screen to grid coordinate conversion
      screenToGridCoordinates(screenX, screenY) {
        try {
          // Convert screen to map, then map to grid
          const mapCoords = this.screenToMapCoordinates(screenX, screenY);
          return this.mapToGridCoordinates(mapCoords.x, mapCoords.y);
        } catch (error) {
          Logger.error('Failed to convert screen to grid coordinates', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Enhanced grid cell to pixel center conversion
      gridCellToPixelCenter(gridCellX, gridCellY) {
        try {
          // This returns the map coordinate (pixel position within the map-grid)
          return this.gridToMapCoordinates(gridCellX, gridCellY);
        } catch (error) {
          Logger.error('Failed to convert grid cell to pixel center', error);
          return { x: 0, y: 0 };
        }
      },
      
      // Snap coordinates to grid
      snapToGrid(mapX, mapY) {
        try {
          const gridCoords = this.mapToGridCoordinates(mapX, mapY);
          return this.gridToMapCoordinates(gridCoords.x, gridCoords.y);
        } catch (error) {
          Logger.error('Failed to snap to grid', error);
          return { x: mapX, y: mapY };
        }
      },
      
      // Distance calculation between two points
      calculateDistance(x1, y1, x2, y2) {
        try {
          if (!this.isValidCoordinates(x1, y1) || !this.isValidCoordinates(x2, y2)) {
            Logger.warn('Invalid coordinates for distance calculation');
            return 0;
          }
          
          const dx = x2 - x1;
          const dy = y2 - y1;
          return Math.sqrt(dx * dx + dy * dy);
        } catch (error) {
          Logger.error('Failed to calculate distance', error);
          return 0;
        }
      },
      
      // Grid distance calculation (in grid units)
      calculateGridDistance(gridX1, gridY1, gridX2, gridY2) {
        try {
          if (!this.isValidCoordinates(gridX1, gridY1) || !this.isValidCoordinates(gridX2, gridY2)) {
            Logger.warn('Invalid grid coordinates for distance calculation');
            return 0;
          }
          
          const dx = Math.abs(gridX2 - gridX1);
          const dy = Math.abs(gridY2 - gridY1);
          
          // Use Chebyshev distance for grid-based movement (D&D style)
          return Math.max(dx, dy);
        } catch (error) {
          Logger.error('Failed to calculate grid distance', error);
          return 0;
        }
      }
    };
    
    // Legacy function wrappers for backward compatibility
    function getGridTransformMatrix() {
      return CoordinateSystem.getGridTransformMatrix();
    }
    
    function screenToMapCoordinates(screenX, screenY) {
      return CoordinateSystem.screenToMapCoordinates(screenX, screenY);
    }
    
    function mapToGridCoordinates(mapX, mapY) {
      return CoordinateSystem.mapToGridCoordinates(mapX, mapY);
    }
    
    function gridToMapCoordinates(gridX, gridY) {
      return CoordinateSystem.gridToMapCoordinates(gridX, gridY);
    }
    
    function screenToGridCoordinates(screenX, screenY) {
      return CoordinateSystem.screenToGridCoordinates(screenX, screenY);
    }
    
    function gridCellToPixelCenter(gridCellX, gridCellY) {
      return CoordinateSystem.gridCellToPixelCenter(gridCellX, gridCellY);
    }
    
    // Initialize map navigation
    function initializeMapNavigation() {
      const viewport = document.getElementById('map-viewport');
      const mapGrid = document.getElementById('map-grid');
      
      // ===== ENHANCED WHEEL AND CLICK HANDLERS =====
      
      // Enhanced mouse wheel zoom with validation
      viewport.addEventListener('wheel', function(e) {
        try {
          e.preventDefault();
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for zoom');
            return;
          }
          
          // Determine zoom direction with validation
          if (typeof e.deltaY !== 'number' || isNaN(e.deltaY)) {
            Logger.warn('Invalid deltaY value for zoom');
            return;
          }
          
          const zoomAction = e.deltaY < 0 ? 'zoom-in' : 'zoom-out';
          
          if (MapNavigation.handleZoom(zoomAction, mouseX, mouseY)) {
            Logger.debug(`Mouse wheel zoom: ${zoomAction} at (${mouseX}, ${mouseY})`);
          }
          
        } catch (error) {
          Logger.error('Failed to handle wheel event', error);
        }
      });
      
      // ===== ENHANCED CLICK HANDLERS =====
      
      // Enhanced click handler for coordinate debugging
      viewport.addEventListener('click', function(e) {
        try {
          // Skip if clicking on a token or other interactive element
          if (e.target.classList.contains('map-asset') || e.target.closest('.map-asset')) {
            return;
          }
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for click debug');
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          const pixelCenter = CoordinateSystem.gridCellToPixelCenter(gridCoords.x, gridCoords.y);
          
          // Validate calculated coordinates
          if (!CoordinateSystem.isValidCoordinates(mapCoords.x, mapCoords.y) ||
              !CoordinateSystem.isValidCoordinates(gridCoords.x, gridCoords.y) ||
              !CoordinateSystem.isValidCoordinates(pixelCenter.x, pixelCenter.y)) {
            Logger.warn('Invalid calculated coordinates for click debug');
            return;
          }
          
          // Enhanced debug output
          const debugInfo = {
            mouse: { x: mouseX, y: mouseY },
            pan: { x: MapNavigation.panX, y: MapNavigation.panY },
            zoom: MapNavigation.currentZoom,
            map: { x: Math.round(mapCoords.x), y: Math.round(mapCoords.y) },
            grid: { x: gridCoords.x, y: gridCoords.y },
            pixelCenter: { x: pixelCenter.x, y: pixelCenter.y },
            transform: CoordinateSystem.getGridTransformMatrix()
          };
          
          Logger.debug('=== VIEWPORT CLICK DEBUG ===', debugInfo);
          
          // Add debug message to chat if function exists
          if (typeof addDebugMessageToChat === 'function') {
            addDebugMessageToChat(`Clicked grid coordinates: (${gridCoords.x}, ${gridCoords.y})`);
          }
          
        } catch (error) {
          Logger.error('Failed to handle viewport click event', error);
        }
      });
      
      // Enhanced click handler for map grid
      mapGrid.addEventListener('click', function(e) {
        try {
          // Skip if clicking on a token or other interactive element
          if (e.target.classList.contains('map-asset') || e.target.closest('.map-asset')) {
            return;
          }
          
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            Logger.warn('Invalid mouse coordinates for map grid click debug');
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          const pixelCenter = CoordinateSystem.gridCellToPixelCenter(gridCoords.x, gridCoords.y);
          
          // Enhanced debug output
          const debugInfo = {
            mouse: { x: mouseX, y: mouseY },
            pan: { x: MapNavigation.panX, y: MapNavigation.panY },
            zoom: MapNavigation.currentZoom,
            map: { x: Math.round(mapCoords.x), y: Math.round(mapCoords.y) },
            grid: { x: gridCoords.x, y: gridCoords.y },
            pixelCenter: { x: pixelCenter.x, y: pixelCenter.y }
          };
          
          Logger.debug('=== MAP GRID CLICK DEBUG ===', debugInfo);
          
        } catch (error) {
          Logger.error('Failed to handle map grid click event', error);
        }
      });
      
      // ===== ENHANCED MOUSE EVENT HANDLERS =====
      
      // Enhanced mouse drag for panning (Roll20 style - right click drag)
      viewport.addEventListener('mousedown', function(e) {
        try {
          if (e.button === 2) { // Right mouse button
            e.preventDefault();
            
            if (MapNavigation.startDrag(e.clientX, e.clientY)) {
              viewport.style.cursor = 'grabbing';
              
              // Update legacy variables for compatibility
              isDragging = true;
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
              
              Logger.debug('Started map panning');
            }
          } else if (e.button === 0) { // Left mouse button
            // Check if clicking on a token
            const clickedToken = e.target.closest('[data-selectable="true"]');
            if (!clickedToken) {
              // Start selection box if not clicking on a token
              startSelectionBox(e);
            }
          }
        } catch (error) {
          Logger.error('Failed to handle mousedown event', error);
        }
      });
      
      // Enhanced mouse move handler
      viewport.addEventListener('mousemove', function(e) {
        try {
          // Handle dragging
          if (MapNavigation.isDragging) {
            if (MapNavigation.updateDrag(e.clientX, e.clientY)) {
              // Update legacy variables for compatibility
              const deltaX = e.clientX - lastMouseX;
              const deltaY = e.clientY - lastMouseY;
              panX += deltaX;
              panY += deltaY;
              lastMouseX = e.clientX;
              lastMouseY = e.clientY;
            }
          }
          
          // Update coordinates indicator
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Validate mouse coordinates
          if (!CoordinateSystem.isValidCoordinates(mouseX, mouseY)) {
            return;
          }
          
          // Use enhanced coordinate system
          const mapCoords = CoordinateSystem.screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = CoordinateSystem.mapToGridCoordinates(mapCoords.x, mapCoords.y);
          
          // Update coordinates indicator
          const coordsIndicator = document.getElementById('coordinates-indicator');
          if (coordsIndicator) {
            coordsIndicator.textContent = `Map: ${Math.round(mapCoords.x)}, ${Math.round(mapCoords.y)} | Grid: ${gridCoords.x}, ${gridCoords.y}`;
            
            // Store last mouse position for potential use
            coordsIndicator.dataset.lastMouseX = mouseX.toString();
            coordsIndicator.dataset.lastMouseY = mouseY.toString();
          }
          
        } catch (error) {
          Logger.warn('Failed to handle mousemove event', error);
        }
      });
      
      // Enhanced mouse move handler
      viewport.addEventListener('mousemove', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.updateDrag(e.clientX, e.clientY);
          } else if (isSelecting) {
            // Update selection box
            updateSelectionBox(e);
          }
        } catch (error) {
          Logger.error('Failed to handle mousemove event', error);
        }
      });
      
      // Enhanced mouse up handler
      viewport.addEventListener('mouseup', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.endDrag();
            ToolManager.updateCursor(); // Return to appropriate cursor
            
            // Update legacy variables for compatibility
            isDragging = false;
            
            Logger.debug('Ended map panning');
          } else if (isSelecting) {
            // End selection box
            endSelectionBox(e);
          }
        } catch (error) {
          Logger.error('Failed to handle mouseup event', error);
        }
      });
      
      // Enhanced mouse leave handler
      viewport.addEventListener('mouseleave', function(e) {
        try {
          if (MapNavigation.isDragging) {
            MapNavigation.endDrag();
            ToolManager.updateCursor(); // Return to appropriate cursor
            
            // Update legacy variables for compatibility
            isDragging = false;
            
            Logger.debug('Map panning interrupted by mouse leave');
          }
        } catch (error) {
          Logger.error('Failed to handle mouseleave event', error);
        }
      });
      
      // Prevent context menu on right click
      viewport.addEventListener('contextmenu', function(e) {
        e.preventDefault();
      });
      
      // Update cursor based on current tool
      viewport.addEventListener('mouseenter', function() {
        updateCursor();
      });
      
      // ===== ENHANCED KEYBOARD SHORTCUTS =====
      
      // Enhanced keyboard shortcuts with validation and error handling
      document.addEventListener('keydown', function(e) {
        try {
          // Only handle shortcuts when not typing in an input field
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
            return;
          }
          
          // Validate event object
          if (!e || !e.key) {
            Logger.warn('Invalid keyboard event object');
            return;
          }
          
          const key = e.key.toLowerCase();
          
          switch(key) {
            case '+':
            case '=':
              e.preventDefault();
              try {
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Validate viewport dimensions
                if (!CoordinateSystem.isValidCoordinates(centerX, centerY)) {
                  Logger.warn('Invalid viewport center coordinates for zoom in');
                  return;
                }
                
                MapNavigation.handleZoom(1.2, centerX, centerY);
                Logger.debug('Keyboard zoom in triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom in shortcut', error);
              }
              break;
              
            case '-':
              e.preventDefault();
              try {
                const rect = viewport.getBoundingClientRect();
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;
                
                // Validate viewport dimensions
                if (!CoordinateSystem.isValidCoordinates(centerX, centerY)) {
                  Logger.warn('Invalid viewport center coordinates for zoom out');
                  return;
                }
                
                MapNavigation.handleZoom(0.8, centerX, centerY);
                Logger.debug('Keyboard zoom out triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom out shortcut', error);
              }
              break;
              
            case '0':
              e.preventDefault();
              try {
                ToolManager.selectTool('zoom-fit');
                Logger.debug('Keyboard zoom-fit triggered');
              } catch (error) {
                Logger.error('Failed to handle zoom-fit shortcut', error);
              }
              break;
              
            case ' ':
              e.preventDefault();
              try {
                // Select tool (Roll20 style - space for select)
                ToolManager.selectTool('select');
                Logger.debug('Keyboard select tool triggered');
              } catch (error) {
                Logger.error('Failed to handle select tool shortcut', error);
              }
              break;
              
            case '1':
              e.preventDefault();
              try {
                ToolManager.selectTool('select');
                Logger.debug('Keyboard select tool (1) triggered');
              } catch (error) {
                Logger.error('Failed to handle select tool (1) shortcut', error);
              }
              break;
              
            case '2':
              e.preventDefault();
              try {
                ToolManager.selectTool('measure');
                Logger.debug('Keyboard measure tool triggered');
              } catch (error) {
                Logger.error('Failed to handle measure tool shortcut', error);
              }
              break;
              
            case '3':
              e.preventDefault();
              try {
                ToolManager.selectTool('draw');
                Logger.debug('Keyboard draw tool triggered');
              } catch (error) {
                Logger.error('Failed to handle draw tool shortcut', error);
              }
              break;
              
            case '4':
              e.preventDefault();
              try {
                ToolManager.selectTool('erase');
                Logger.debug('Keyboard erase tool triggered');
              } catch (error) {
                Logger.error('Failed to handle erase tool shortcut', error);
              }
              break;
              
            case '5':
              e.preventDefault();
              try {
                ToolManager.selectTool('token');
                Logger.debug('Keyboard token tool triggered');
              } catch (error) {
                Logger.error('Failed to handle token tool shortcut', error);
              }
              break;
              
            case 'escape':
              e.preventDefault();
              try {
                // Clear token selection first, then return to select tool
                if (selectedTokens.size > 0) {
                  clearTokenSelection();
                  Logger.debug('Keyboard escape - cleared token selection');
                } else {
                  // Cancel current operation or return to select tool
                  ToolManager.selectTool('select');
                  Logger.debug('Keyboard escape - returning to select tool');
                }
              } catch (error) {
                Logger.error('Failed to handle escape shortcut', error);
              }
              break;
              
            case 'arrowup':
            case 'arrowdown':
            case 'arrowleft':
            case 'arrowright':
              e.preventDefault();
              try {
                if (selectedTokens.size > 0) {
                  moveSelectedTokens(key);
                  Logger.debug('Moving selected tokens:', key);
                }
              } catch (error) {
                Logger.error('Failed to handle arrow key movement', error);
              }
              break;
              
            default:
              // No action for other keys
              break;
          }
          
        } catch (error) {
          Logger.error('Failed to handle keyboard shortcut', error);
        }
      });
    }
    
    // ===== ENHANCED CURSOR MANAGEMENT =====
    
    // Enhanced cursor management with validation and error handling
    function updateCursor() {
      try {
        const viewport = document.getElementById('map-viewport');
        if (!viewport) {
          Logger.warn('Viewport element not found for cursor update');
          return;
        }
        
        // Use ToolManager for cursor management if available
        if (typeof ToolManager !== 'undefined' && ToolManager.updateCursor) {
          ToolManager.updateCursor();
          return;
        }
        
        // Fallback to legacy cursor management
        const tool = currentTool || 'select';
        
        switch(tool) {
          case 'draw':
            viewport.style.cursor = 'crosshair';
            break;
          case 'measure':
            viewport.style.cursor = 'crosshair';
            break;
          case 'token':
            viewport.style.cursor = 'pointer';
            break;
          case 'erase':
            viewport.style.cursor = 'crosshair';
            break;
          case 'zoom-in':
            viewport.style.cursor = 'zoom-in';
            break;
          case 'zoom-out':
            viewport.style.cursor = 'zoom-out';
            break;
          default:
            viewport.style.cursor = 'grab'; // Roll20 style - always ready to pan
        }
        
        Logger.debug(`Cursor updated to: ${viewport.style.cursor} for tool: ${tool}`);
        
      } catch (error) {
        Logger.error('Failed to update cursor', error);
      }
    }
    
    // ===== ENHANCED CAMPAIGN MANAGEMENT =====
    
    // Enhanced campaign info loading with validation and error handling
    async function loadCampaignInfo() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('Invalid campaign ID for loading campaign info', { campaignId });
          return;
        }
        
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        if (!user) {
          Logger.error('No user found in storage for campaign info loading');
          return;
        }
        
        Logger.debug('Loading campaign info', { campaignId, user });
        
        const response = await fetch(`/api/campaigns?username=${encodeURIComponent(user)}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !data.success) {
          throw new Error('Invalid response format or request failed');
        }
        
        if (!Array.isArray(data.campaigns)) {
          Logger.warn('No campaigns array in response');
          return;
        }
        
        const campaign = data.campaigns.find(c => c && c.id == campaignId);
        if (!campaign) {
          Logger.warn('Campaign not found in user campaigns', { campaignId });
          return;
        }
        
        // Update UI elements with validation
        const campaignNameEl = document.getElementById('campaign-name');
        const campaignSystemEl = document.getElementById('campaign-system');
        
        if (campaignNameEl) {
          campaignNameEl.textContent = campaign.name || 'Unnamed Campaign';
        } else {
          Logger.warn('Campaign name element not found');
        }
        
        if (campaignSystemEl) {
          campaignSystemEl.textContent = campaign.system || 'No system selected';
        } else {
          Logger.warn('Campaign system element not found');
        }
        
        Logger.debug('Campaign info loaded successfully', { campaign });
        
      } catch (error) {
        Logger.error('Failed to load campaign info', error);
      }
    }
    
    // Enhanced maps loading with validation and error handling
    async function loadMaps() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!MapState.isValidCampaignId(campaignId)) {
          Logger.error('Invalid campaign ID for loading maps', { campaignId });
          return;
        }
        
        Logger.debug('Loading maps for campaign', { campaignId });
        
        const response = await fetch(`/api/maps?campaign_id=${campaignId}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data || !data.success) {
          throw new Error('Invalid response format or request failed');
        }
        
        if (!Array.isArray(data.maps)) {
          Logger.warn('No maps array in response');
          return;
        }
        
        const mapsList = document.getElementById('maps-list');
        if (!mapsList) {
          Logger.error('Maps list element not found');
          return;
        }
        
        // Clear existing maps
        mapsList.innerHTML = '';
        
        // Validate and create map items
        const validMaps = data.maps.filter(map => {
          if (!map || !map.id || !map.name) {
            Logger.warn('Invalid map data found', { map });
            return false;
          }
          return true;
        });
        
        if (validMaps.length === 0) {
          Logger.info('No valid maps found for campaign');
          const noMapsItem = document.createElement('li');
          noMapsItem.className = 'item no-maps';
          noMapsItem.innerHTML = '<div class="item-name">No maps available</div>';
          mapsList.appendChild(noMapsItem);
          return;
        }
        
        // Create map items
        validMaps.forEach(map => {
          try {
            const mapItem = document.createElement('li');
            mapItem.className = 'item';
            mapItem.innerHTML = `
              <div class="item-name">${escapeHtml(map.name)}</div>
              <div class="item-details">Map ID: ${map.id}</div>
            `;
            
            mapItem.addEventListener('click', () => {
              try {
                loadMap(map.id);
              } catch (error) {
                Logger.error('Failed to load map from click', error);
              }
            });
            
            mapsList.appendChild(mapItem);
            
          } catch (error) {
            Logger.error('Failed to create map item', error, { map });
          }
        });
        
        // Auto-load map based on URL parameters, session storage, or first available
        if (validMaps.length > 0 && !currentMapId) {
          try {
            const urlParams = new URLSearchParams(window.location.search);
            const urlMapId = urlParams.get('map_id') || urlParams.get('id');
            const savedMapId = sessionStorage.getItem('current_map_id');
            let mapToLoad = null;
            
            // Try to find the URL map first
            if (urlMapId) {
              mapToLoad = validMaps.find(map => map.id == urlMapId);
              if (mapToLoad) {
                Logger.debug('Found URL map to load', { mapId: urlMapId });
              } else {
                Logger.warn('URL map ID not found in available maps', { urlMapId, availableMaps: validMaps.map(m => m.id) });
              }
            }
            
            // Try to find the saved map if URL map not found
            if (!mapToLoad && savedMapId) {
              mapToLoad = validMaps.find(map => map.id == savedMapId);
              if (mapToLoad) {
                Logger.debug('Found saved map to load', { mapId: savedMapId });
              }
            }
            
            // If neither URL nor saved map found, use first map
            if (!mapToLoad) {
              mapToLoad = validMaps[0];
              Logger.debug('Using first available map', { mapId: mapToLoad.id });
            }
            
            await loadMap(mapToLoad.id);
            
            // Mark the loaded map as selected
            const mapItems = mapsList.querySelectorAll('.item');
            mapItems.forEach(item => {
              try {
                const detailsEl = item.querySelector('.item-details');
                if (detailsEl) {
                  const mapId = detailsEl.textContent.split(': ')[1];
                  if (mapId == mapToLoad.id) {
                    item.classList.add('selected');
                  }
                }
              } catch (error) {
                Logger.warn('Failed to mark map as selected', error);
              }
            });
            
          } catch (error) {
            Logger.error('Failed to auto-load map', error);
          }
        }
        
        Logger.debug('Maps loaded successfully', { count: validMaps.length });
        
      } catch (error) {
        Logger.error('Failed to load maps', error);
      }
    }
    
    // Helper function to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Enhanced map loading with validation and error handling
    // ===== MAP LOADING STATE MANAGEMENT =====
    let isLoadingMap = false;
    let currentLoadingMapId = null;
    
    async function loadMap(mapId) {
      try {
        // Validate map ID
        if (!mapId || (typeof mapId !== 'string' && typeof mapId !== 'number')) {
          Logger.error('Invalid map ID provided', { mapId });
          showMapLoadError('ID mappa non valido');
          return false;
        }
        
        // Prevent concurrent map loading
        if (isLoadingMap) {
          Logger.warn('Map loading already in progress, ignoring request', { 
            currentMapId: currentLoadingMapId, 
            requestedMapId: mapId 
          });
          return false;
        }
        
        isLoadingMap = true;
        currentLoadingMapId = mapId;
        
        Logger.debug('Loading map', { mapId });
        
        // Show loading indicator
        showMapLoadingIndicator(true);
        
        try {
          // ===== ENHANCED STATE CLEANUP =====
          // Clear all previous map state before loading new map
          resetMapState();
          
          // Remove selection from all maps
          const mapItems = document.querySelectorAll('#maps-list .item');
          mapItems.forEach(item => {
            try {
              item.classList.remove('selected');
            } catch (error) {
              Logger.warn('Failed to remove selection from map item', error);
            }
          });
          
          // Add selection to clicked map (only if called from click event)
          if (typeof event !== 'undefined' && event && event.target) {
            try {
              const itemEl = event.target.closest('.item');
              if (itemEl) {
                itemEl.classList.add('selected');
              }
            } catch (error) {
              Logger.warn('Failed to add selection to clicked map', error);
            }
          }
          
          // Update current map ID
          currentMapId = mapId;
          if (MapState) {
            MapState.currentMapId = mapId;
          }
          
          // Save selected map ID to session storage
          try {
            sessionStorage.setItem('current_map_id', mapId.toString());
          } catch (error) {
            Logger.warn('Failed to save map ID to session storage', error);
          }
          
          // Clear existing assets from all layers
          clearAllLayers();
          
          // Load positioned assets for this map
          const assetsLoaded = await loadMapAssets(mapId);
          if (!assetsLoaded) {
            Logger.warn('Some assets failed to load for map', { mapId });
          }
          
          // Update active tokens list for the selected map
          try {
            loadActiveTokensAndSheets(true); // Force immediate reload for new map
          } catch (error) {
            Logger.error('Failed to load active tokens and sheets', error);
          }
          
          Logger.debug('Map loaded successfully', { mapId });
          return true;
          
        } finally {
          // Always hide loading indicator and reset loading state
          showMapLoadingIndicator(false);
          isLoadingMap = false;
          currentLoadingMapId = null;
        }
        
      } catch (error) {
        Logger.error('Failed to load map', error, { mapId });
        showMapLoadError('Errore durante il caricamento della mappa');
        showMapLoadingIndicator(false);
        isLoadingMap = false;
        currentLoadingMapId = null;
        return false;
      }
    }
    
    // ===== MAP LOADING UI HELPERS =====
    function showMapLoadingIndicator(show) {
      try {
        let indicator = document.getElementById('map-loading-indicator');
        if (show) {
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'map-loading-indicator';
            indicator.innerHTML = '<div class="loading-spinner"></div><span>Caricamento mappa...</span>';
            indicator.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: rgba(0, 0, 0, 0.8);
              color: white;
              padding: 20px;
              border-radius: 8px;
              z-index: 10000;
              display: flex;
              align-items: center;
              gap: 10px;
            `;
            document.body.appendChild(indicator);
          }
          indicator.style.display = 'flex';
        } else if (indicator) {
          indicator.style.display = 'none';
        }
      } catch (error) {
        Logger.warn('Failed to show/hide loading indicator', error);
      }
    }
    
    function showMapLoadError(message) {
      try {
        // Remove any existing error messages
        const existingErrors = document.querySelectorAll('.map-load-error');
        existingErrors.forEach(error => error.remove());
        
        const errorDiv = document.createElement('div');
        errorDiv.className = 'map-load-error';
        errorDiv.textContent = message;
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc3545;
          color: white;
          padding: 12px 20px;
          border-radius: 4px;
          z-index: 10001;
          max-width: 300px;
        `;
        
        document.body.appendChild(errorDiv);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
          if (errorDiv.parentNode) {
            errorDiv.remove();
          }
        }, 5000);
        
      } catch (error) {
        Logger.warn('Failed to show error message', error);
      }
    }
    
    // ===== ENHANCED MAP STATE RESET FUNCTION =====
    function resetMapState() {
      try {
        Logger.debug('Resetting map state for new map load');
        
        // Clear token selections
        clearTokenSelection();
        
        // Reset navigation state
        if (MapNavigation && MapNavigation.isDragging) {
          if (MapNavigation.endDrag) {
            MapNavigation.endDrag();
          } else {
            MapNavigation.isDragging = false;
          }
        }
        
        // Reset tool state
        if (ToolManager && ToolManager.selectTool) {
          ToolManager.selectTool('select');
        }
        
        // Clear any active measurements
        if (ToolManager && ToolManager.clearMeasurements) {
          ToolManager.clearMeasurements();
        }
        
        // Clear selection box if active
        if (typeof isSelecting !== 'undefined' && isSelecting && selectionBox) {
          try {
            selectionBox.remove();
            selectionBox = null;
            isSelecting = false;
          } catch (error) {
            Logger.warn('Failed to clear selection box', error);
          }
        }
        
        // Reset zoom and pan to default for new map
        if (MapNavigation) {
          MapNavigation.currentZoom = 1;
          MapNavigation.panX = 0;
          MapNavigation.panY = 0;
          if (MapNavigation.updateMapTransform) {
            MapNavigation.updateMapTransform();
          }
        }
        
        // Clear any drag states
        if (typeof isDragging !== 'undefined') {
          isDragging = false;
        }
        if (MapState && typeof MapState.isDragging !== 'undefined') {
          MapState.isDragging = false;
        }
        
        // Clear any context menus
        const contextMenus = document.querySelectorAll('.context-menu');
        contextMenus.forEach(menu => {
          try {
            menu.remove();
          } catch (error) {
            Logger.warn('Failed to remove context menu', error);
          }
        });
        
        // Clear any temporary UI elements
        const tempElements = document.querySelectorAll('.temp-ui-element, .measurement-line, .grid-highlight');
        tempElements.forEach(element => {
          try {
            element.remove();
          } catch (error) {
            Logger.warn('Failed to remove temporary UI element', error);
          }
        });
        
        // Clean up any orphaned event listeners
        cleanupOrphanedEventListeners();
        
        Logger.debug('Map state reset completed');
        
      } catch (error) {
        Logger.error('Failed to reset map state', error);
      }
    }

    // ===== CLEANUP ORPHANED EVENT LISTENERS =====
    function cleanupOrphanedEventListeners() {
      try {
        Logger.debug('Cleaning up orphaned event listeners');
        
        // Remove any dangling drag event listeners
        const dragElements = document.querySelectorAll('[draggable="true"]');
        dragElements.forEach(element => {
          if (!element.parentNode || !document.contains(element)) {
            try {
              // Element is orphaned, clean it up
              element.draggable = false;
              element.removeAttribute('draggable');
            } catch (error) {
              Logger.warn('Failed to clean orphaned drag element', error);
            }
          }
        });
        
        // Clean up any audio instances that might be playing
        const audioElements = document.querySelectorAll('audio');
        audioElements.forEach(audio => {
          try {
            if (!document.contains(audio)) {
              audio.pause();
              audio.src = '';
              audio.remove();
            }
          } catch (error) {
            Logger.warn('Failed to clean orphaned audio element', error);
          }
        });
        
        // Force garbage collection hint (if available)
        if (window.gc && typeof window.gc === 'function') {
          try {
            window.gc();
            Logger.debug('Manual garbage collection triggered');
          } catch (gcError) {
            Logger.debug('Manual garbage collection not available');
          }
        }
        
        Logger.debug('Orphaned event listeners cleanup completed');
        
      } catch (error) {
        Logger.error('Failed to cleanup orphaned event listeners', error);
      }
    }

    // Enhanced layer clearing with validation and error handling
    function clearAllLayers() {
      try {
        const layers = ['tokens', 'map', 'audio', 'props'];
        
        Logger.debug('Clearing all map layers', { layers });
        
        layers.forEach(layerName => {
          try {
            const layer = document.getElementById(`${layerName}-layer`);
            if (layer) {
              // Remove all child elements and their event listeners properly
              Array.from(layer.children).forEach(child => {
                try {
                  // Remove specific event listeners to prevent memory leaks
                  if (child.removeEventListener) {
                    // Clone and replace to remove all event listeners
                    const newChild = child.cloneNode(true);
                    child.parentNode.replaceChild(newChild, child);
                  }
                  
                  // Clean up any audio instances
                  if (child.audioInstance) {
                    try {
                      child.audioInstance.pause();
                      child.audioInstance.src = '';
                      child.audioInstance = null;
                    } catch (audioError) {
                      Logger.warn('Failed to clean up audio instance', audioError);
                    }
                  }
                  
                } catch (childError) {
                  Logger.warn('Failed to clean up child element', childError);
                }
              });
              
              // Clear all children
              layer.innerHTML = '';
              Logger.debug(`Cleared layer: ${layerName}`);
            } else {
              Logger.warn(`Layer element not found: ${layerName}-layer`);
            }
          } catch (error) {
            Logger.error(`Failed to clear layer: ${layerName}`, error);
          }
        });
        
        Logger.debug('All layers cleared successfully');
        
      } catch (error) {
        Logger.error('Failed to clear all layers', error);
      }
    }
    
    // Enhanced map assets loading with validation and error handling
    async function loadMapAssets(mapId) {
      try {
        // Validate map ID
        if (!mapId || (typeof mapId !== 'string' && typeof mapId !== 'number')) {
          Logger.error('Invalid map ID for loading assets', { mapId });
          return;
        }
        
        Logger.debug('Loading map assets', { mapId });
        
        // Ensure assets are loaded first
        if (!Array.isArray(assets) || assets.length === 0) {
          Logger.debug('Assets array is empty, loading assets first');
          try {
            await loadAssets();
          } catch (error) {
            Logger.error('Failed to load assets before loading map assets', error);
            return;
          }
        }
        
        Logger.debug('Assets available', { count: assets.length });
        
        // Define asset types to load
        const assetTypes = [
          { name: 'tokens', endpoint: '/api/map-tokens', layer: 'tokens', dataKey: 'tokens' },
          { name: 'backgrounds', endpoint: '/api/map-backgrounds', layer: 'map', dataKey: 'backgrounds' },
          { name: 'audio', endpoint: '/api/map-audio', layer: 'audio', dataKey: 'audio' },
          { name: 'props', endpoint: '/api/map-props', layer: 'props', dataKey: 'props' }
        ];
        
        // Load each asset type
        for (const assetType of assetTypes) {
          try {
            Logger.debug(`Loading ${assetType.name} for map`, { mapId });
            
            const response = await fetch(`${assetType.endpoint}?map_id=${mapId}`);
            
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data || !data.success) {
              Logger.warn(`Failed to load ${assetType.name}`, { mapId, data });
              continue;
            }
            
            const items = data[assetType.dataKey];
            if (!Array.isArray(items)) {
              Logger.warn(`No ${assetType.name} array in response`, { mapId });
              continue;
            }
            
            if (items.length === 0) {
              Logger.debug(`No ${assetType.name} found for map`, { mapId });
              continue;
            }
            
            Logger.debug(`Found ${items.length} ${assetType.name} to display`, { mapId });
            
            // Process each item
            items.forEach((item, index) => {
              try {
                // Validate item data
                if (!item || !item.asset_id || 
                    !CoordinateSystem.isValidCoordinates(item.grid_x, item.grid_y)) {
                  Logger.warn(`Invalid ${assetType.name} data`, { item, index });
                  return;
                }
                
                const assetData = {
                  assetId: item.asset_id,
                  assetType: assetType.name === 'backgrounds' ? 'background' : assetType.name.slice(0, -1), // Remove 's' from plural
                  assetName: item.name || assetType.name.slice(0, -1) // Remove 's' from plural
                };
                
                // Add token-specific data
                if (assetType.name === 'tokens' && item.id) {
                  assetData.tokenId = item.id;
                }
                
                Logger.debug(`Creating visual element for ${assetType.name}`, { assetData, coordinates: { x: item.grid_x, y: item.grid_y } });
                
                // Create visual element with enhanced coordinate system
                createVisualAssetElement(assetData, item.grid_x, item.grid_y, assetType.layer);
                
              } catch (error) {
                Logger.error(`Failed to process ${assetType.name} item`, error, { item, index });
              }
            });
            
            Logger.debug(`Successfully loaded ${items.length} ${assetType.name}`, { mapId });
            
          } catch (error) {
            Logger.error(`Failed to load ${assetType.name}`, error, { mapId });
          }
        }
        
        // Ensure map transform is applied after assets are loaded
        if (MapNavigation && MapNavigation.updateMapTransform) {
          MapNavigation.updateMapTransform();
        }
        
        Logger.debug('Map assets loading completed', { mapId });
        return true;
        
      } catch (error) {
        Logger.error('Failed to load map assets', error, { mapId });
        return false;
      }
    }
    
    // Create new map
    async function createNewMap() {
      const mapName = await showInputDialog('Enter map name:', 'Map Name');
      if (!mapName) return;
      
      try {
        const campaignId = MapState.getCampaignId();
        if (!campaignId) {
          alert('Error: Campaign ID not found. Please reload the page.');
          return;
        }
        
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        const response = await fetch('/api/maps', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            campaign_id: campaignId,
            name: mapName,
            data: {},
            username: user
          })
        });
        
        const data = await response.json();
        if (data.success) {
          loadMaps(); // Reload maps list
        } else {
          alert('Failed to create map: ' + (data.error || 'Unknown error'));
        }
      } catch (error) {
        console.error('Failed to create map:', error);
        alert('Failed to create map');
      }
    }
    

    

    

    
    // Asset management
    let assets = [];
    
    async function loadAssets() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || isNaN(parseInt(campaignId))) {
          Logger.error('Invalid campaign ID for loading assets:', campaignId);
          return false;
        }
        
        const numericCampaignId = parseInt(campaignId);
        Logger.info('Loading assets for campaign:', numericCampaignId);
        
        // Retry logic for loading assets
        let lastError;
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            Logger.debug(`Load assets attempt ${attempt}/3 for campaign ${numericCampaignId}`);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(`/api/assets?campaign_id=${numericCampaignId}`, {
              signal: controller.signal,
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              }
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              if (response.status >= 500) {
                throw new Error(`Server error: ${response.status} ${response.statusText}`);
              } else if (response.status === 404) {
                Logger.warn('Assets endpoint not found, using empty assets');
                assets = [];
                displayAssets();
                return true;
              } else {
                throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
              }
            }
            
            let data;
            try {
              const responseText = await response.text();
              if (!responseText || responseText.trim() === '') {
                Logger.warn('Empty response from assets API, using empty assets');
                assets = [];
                displayAssets();
                return true;
              }
              
              data = JSON.parse(responseText);
            } catch (parseError) {
              Logger.error('Failed to parse assets response:', parseError);
              throw new Error('Invalid JSON response from assets API');
            }
            
            // Validate response structure
            if (!data || typeof data !== 'object') {
              Logger.warn('Invalid assets response data structure:', data);
              assets = [];
              displayAssets();
              return true;
            }
            
            if (typeof data.success !== 'boolean') {
              Logger.warn('Missing success field in assets response, assuming success');
              data.success = true;
            }
            
            if (data.success) {
              // Validate and filter assets
              if (!Array.isArray(data.assets)) {
                Logger.warn('Assets data is not an array:', data.assets);
                assets = [];
              } else {
                assets = data.assets.filter(asset => {
                  if (!asset || typeof asset !== 'object') {
                    Logger.warn('Invalid asset object filtered out:', asset);
                    return false;
                  }
                  if (typeof asset.id === 'undefined' || asset.id === null) {
                    Logger.warn('Asset missing ID filtered out:', asset);
                    return false;
                  }
                  if (!asset.name || typeof asset.name !== 'string') {
                    Logger.warn('Asset missing or invalid name filtered out:', asset);
                    return false;
                  }
                  return true;
                });
              }
              
              Logger.info(`Loaded ${assets.length}/${data.assets?.length || 0} valid assets`);
              
              try {
                displayAssets();
              } catch (displayError) {
                Logger.error('Failed to display assets:', displayError);
                // Don't fail the entire operation if display fails
              }
              
              return true;
            } else {
              const errorMsg = data.error || 'Unknown error from assets API';
              Logger.error('Assets API returned error:', errorMsg);
              throw new Error(errorMsg);
            }
            
          } catch (error) {
            lastError = error;
            
            if (error.name === 'AbortError') {
              Logger.error(`Assets load request timeout on attempt ${attempt}`);
            } else if (error.message.includes('fetch') || error.message.includes('network')) {
              Logger.error(`Network error on assets load attempt ${attempt}:`, error.message);
            } else {
              Logger.error(`Assets load attempt ${attempt} failed:`, error.message);
            }
            
            // Don't retry on certain errors
            if (error.message.includes('Invalid campaign ID') || 
                error.message.includes('403') ||
                error.message.includes('Invalid JSON')) {
              throw error;
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
              Logger.debug(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        // All attempts failed
        Logger.error('All attempts to load assets failed:', lastError);
        
        // Fallback to empty assets to prevent UI breakage
        assets = [];
        try {
          displayAssets();
        } catch (displayError) {
          Logger.error('Failed to display empty assets fallback:', displayError);
        }
        
        return false;
        
      } catch (error) {
        Logger.error('Exception during assets loading:', error);
        
        // Fallback to empty assets
        assets = [];
        try {
          displayAssets();
        } catch (displayError) {
          Logger.error('Failed to display assets in error fallback:', displayError);
        }
        
        return false;
      }
    }
    
    function displayAssets() {
      try {
        const assetsList = document.querySelector('#assets-section .item-list');
        const categorySelect = document.getElementById('asset-category-select');
        
        if (!assetsList) {
          Logger.error('Assets list element not found');
          return false;
        }
        
        if (!categorySelect) {
          Logger.error('Asset category select element not found');
          return false;
        }
        
        const selectedCategory = categorySelect.value;
        Logger.info('Displaying assets for category:', selectedCategory);
        
        assetsList.innerHTML = '';
        
        // Validate assets array
        if (!Array.isArray(assets)) {
          Logger.warn('Assets is not an array:', assets);
          return false;
        }
        
        // Filter assets based on selected category
        const filteredAssets = selectedCategory === 'all' 
          ? assets 
          : assets.filter(asset => {
              try {
                if (!asset || !asset.category) {
                  Logger.warn('Asset missing category:', asset);
                  return false;
                }
                
                if (selectedCategory === 'background') {
                  // Backgrounds are stored as 'backgrounds' category
                  return asset.category === 'backgrounds';
                } else {
                  return asset.category === selectedCategory;
                }
              } catch (filterError) {
                Logger.error('Error filtering asset:', filterError, asset);
                return false;
              }
            });
        
        Logger.info(`Displaying ${filteredAssets.length} filtered assets`);
        
        filteredAssets.forEach(asset => {
          try {
            if (!asset || typeof asset.id === 'undefined' || !asset.name) {
              Logger.warn('Invalid asset data for display:', asset);
              return;
            }
            
            const li = document.createElement('li');
            li.className = 'item';
            li.draggable = true;
            li.dataset.assetId = asset.id;
            li.dataset.assetType = asset.category || 'unknown';
            li.dataset.assetName = asset.name;
            
            const fileSize = (asset.file_size !== null && asset.file_size !== undefined && asset.file_size !== '') ? formatFileSize(asset.file_size) : 'Unknown size';
            const category = asset.category || 'Unknown';
            
            li.innerHTML = `
              <div class="item-name">${escapeHtml(asset.name)}</div>
              <div class="item-details">${escapeHtml(category)} - ${fileSize}</div>
              <div class="item-actions">
                <button onclick="editAsset(${asset.id})" title="Edit">✏️</button>
                <button onclick="deleteAsset(${asset.id})" title="Delete">🗑️</button>
              </div>
            `;
            
            // Add drag event listeners with error handling
            li.addEventListener('dragstart', function(e) {
              try {
                const dragData = {
                  assetId: asset.id,
                  assetType: asset.category || 'unknown',
                  assetName: asset.name
                };
                e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
                e.dataTransfer.effectAllowed = 'copy';
                Logger.info('Drag started for asset:', asset.name);
              } catch (dragError) {
                Logger.error('Error setting drag data:', dragError);
              }
            });
            
            assetsList.appendChild(li);
          } catch (itemError) {
            Logger.error('Error creating asset item:', itemError, asset);
          }
        });
        
        return true;
        
      } catch (error) {
        Logger.error('Exception during assets display:', error);
        return false;
      }
    }
    
    function uploadAsset() {
      try {
        // Get selected category
        const categorySelect = document.getElementById('asset-category-select');
        
        if (!categorySelect) {
          Logger.error('Asset category select element not found');
          alert('Error: Category selector not found. Please reload the page.');
          return;
        }
        
        const selectedCategory = categorySelect.value;
        
        // Validate category selection
        if (!selectedCategory || selectedCategory === 'all') {
          alert('Please select a specific category before uploading assets.');
          return;
        }
        
        // Validate required IDs
        const campaignId = MapState.getCampaignId();
        if (!userId || !campaignId) {
          Logger.error('Missing required IDs for upload:', { userId, campaignId });
          alert('Error: Missing user or campaign information. Please reload the page.');
          return;
        }
        
        Logger.info('Starting asset upload for category:', selectedCategory);
        
        // For tokens, show the editor; for other assets, use the standard upload
        if (selectedCategory === 'tokens') {
          showTokenEditor();
        } else {
          standardAssetUpload(selectedCategory, campaignId);
        }
        
      } catch (error) {
        Logger.error('Exception in uploadAsset function:', error);
        alert('Error starting upload: ' + (error.message || 'Unknown error'));
      }
    }
    
    function standardAssetUpload(selectedCategory, campaignId) {
      const input = document.createElement('input');
      input.type = 'file';
      
      // Set file filter based on selected category
      const acceptTypes = {
        'background': '.jpg,.jpeg,.png',
        'props': '.png',
        'audio': '.mp3,.wav,.ogg,.m4a,.aac'
      };
      
      input.accept = acceptTypes[selectedCategory] || 'image/*,audio/*';
      
      input.onchange = async function(e) {
        try {
          const file = e.target.files[0];
          if (!file) {
            Logger.warn('No file selected for upload');
            return;
          }
          
          // Validate file size (max 50MB)
          const maxSize = 50 * 1024 * 1024; // 50MB
          if (file.size > maxSize) {
            alert('File size too large. Maximum allowed size is 50MB.');
            return;
          }
          
          // Validate file type
          const allowedTypes = {
            'background': ['image/jpeg', 'image/jpg', 'image/png'],
            'props': ['image/png'],
            'audio': ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/mp4', 'audio/aac']
          };
          
          const categoryTypes = allowedTypes[selectedCategory];
          if (categoryTypes && !categoryTypes.includes(file.type)) {
            alert(`Invalid file type for ${selectedCategory}. Allowed types: ${categoryTypes.join(', ')}`);
            return;
          }
          
          Logger.info('Uploading file:', file.name, 'Size:', file.size, 'Type:', file.type);
          
          await processAssetUpload(file, selectedCategory, campaignId);
          
        } catch (error) {
          Logger.error('Exception during asset upload:', error);
          alert('Failed to upload asset: ' + (error.message || 'Network error'));
        }
      };
      
      input.click();
    }
    
    async function processAssetUpload(file, selectedCategory, campaignId) {
      try {
        // Validate inputs
        if (!file || !selectedCategory || !campaignId) {
          throw new Error('Missing required parameters for asset upload');
        }
        
        if (!userId) {
          throw new Error('User ID not available for upload');
        }
        
        const numericCampaignId = parseInt(campaignId);
        if (isNaN(numericCampaignId)) {
          throw new Error('Invalid campaign ID for upload');
        }
        
        Logger.info(`Starting asset upload: ${file.name} (${file.size} bytes) for category ${selectedCategory}`);
        
        // Step 1: Upload file with retry logic
        let uploadData;
        let lastUploadError;
        
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            Logger.debug(`File upload attempt ${attempt}/3`);
            
            const uploadFormData = new FormData();
            uploadFormData.append('file', file);
            uploadFormData.append('user_id', userId.toString());
            uploadFormData.append('campaign_id', numericCampaignId.toString());
            uploadFormData.append('upload_type', selectedCategory);
            
            const uploadController = new AbortController();
            const uploadTimeoutId = setTimeout(() => uploadController.abort(), 60000); // 60 second timeout for file upload
            
            const uploadResponse = await fetch('/api/upload', {
              method: 'POST',
              body: uploadFormData,
              signal: uploadController.signal
            });
            
            clearTimeout(uploadTimeoutId);
            
            if (!uploadResponse.ok) {
              if (uploadResponse.status >= 500) {
                throw new Error(`Server error during upload: ${uploadResponse.status} ${uploadResponse.statusText}`);
              } else if (uploadResponse.status === 413) {
                throw new Error('File too large for upload');
              } else if (uploadResponse.status === 415) {
                throw new Error('Unsupported file type');
              } else {
                throw new Error(`Upload HTTP error: ${uploadResponse.status} ${uploadResponse.statusText}`);
              }
            }
            
            let responseText;
            try {
              responseText = await uploadResponse.text();
              if (!responseText || responseText.trim() === '') {
                throw new Error('Empty response from upload API');
              }
              
              uploadData = JSON.parse(responseText);
            } catch (parseError) {
              Logger.error('Failed to parse upload response:', parseError);
              throw new Error('Invalid JSON response from upload API');
            }
            
            if (!uploadData || typeof uploadData !== 'object') {
              throw new Error('Invalid upload response structure');
            }
            
            if (!uploadData.success) {
              const errorMsg = uploadData.error || 'Unknown upload error';
              throw new Error(`Upload failed: ${errorMsg}`);
            }
            
            if (!uploadData.url) {
              throw new Error('Upload response missing file URL');
            }
            
            Logger.info('File uploaded successfully:', uploadData.url);
            break; // Success, exit retry loop
            
          } catch (error) {
            lastUploadError = error;
            
            if (error.name === 'AbortError') {
              Logger.error(`Upload request timeout on attempt ${attempt}`);
            } else if (error.message.includes('File too large') || 
                       error.message.includes('Unsupported file type') ||
                       error.message.includes('413') ||
                       error.message.includes('415')) {
              // Don't retry these errors
              throw error;
            } else {
              Logger.error(`Upload attempt ${attempt} failed:`, error.message);
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
              Logger.debug(`Waiting ${delay}ms before upload retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        if (!uploadData) {
          throw lastUploadError || new Error('All upload attempts failed');
        }
        
        // Step 2: Create asset record with retry logic
        let lastAssetError;
        
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            Logger.debug(`Asset creation attempt ${attempt}/3`);
            
            const assetData = {
              campaign_id: numericCampaignId,
              name: file.name || 'Unnamed Asset',
              category: selectedCategory,
              file_url: uploadData.url,
              file_size: uploadData.size || file.size || 0,
              mime_type: file.type || 'application/octet-stream',
              description: '',
              tags: ''
            };
            
            // Validate asset data
            if (!assetData.name || !assetData.file_url) {
              throw new Error('Invalid asset data: missing name or file URL');
            }
            
            const assetController = new AbortController();
            const assetTimeoutId = setTimeout(() => assetController.abort(), 30000); // 30 second timeout
            
            const assetResponse = await fetch('/api/assets', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              },
              body: JSON.stringify(assetData),
              signal: assetController.signal
            });
            
            clearTimeout(assetTimeoutId);
            
            if (!assetResponse.ok) {
              if (assetResponse.status >= 500) {
                throw new Error(`Server error during asset creation: ${assetResponse.status} ${assetResponse.statusText}`);
              } else if (assetResponse.status === 409) {
                throw new Error('Asset with this name already exists');
              } else {
                throw new Error(`Asset creation HTTP error: ${assetResponse.status} ${assetResponse.statusText}`);
              }
            }
            
            let assetResponseText;
            try {
              assetResponseText = await assetResponse.text();
              if (!assetResponseText || assetResponseText.trim() === '') {
                throw new Error('Empty response from asset creation API');
              }
              
              const assetResult = JSON.parse(assetResponseText);
              
              if (!assetResult || typeof assetResult !== 'object') {
                throw new Error('Invalid asset creation response structure');
              }
              
              if (assetResult.success) {
                Logger.info('Asset created successfully:', file.name);
                
                // Reload assets to show the new one
                try {
                  await loadAssets();
                } catch (reloadError) {
                  Logger.warn('Failed to reload assets after upload:', reloadError);
                  // Don't fail the entire operation if reload fails
                }
                
                alert('Asset uploaded successfully!');
                return; // Success
                
              } else {
                const errorMsg = assetResult.error || 'Unknown asset creation error';
                throw new Error(`Asset creation failed: ${errorMsg}`);
              }
              
            } catch (parseError) {
              Logger.error('Failed to parse asset creation response:', parseError);
              throw new Error('Invalid JSON response from asset creation API');
            }
            
          } catch (error) {
            lastAssetError = error;
            
            if (error.name === 'AbortError') {
              Logger.error(`Asset creation request timeout on attempt ${attempt}`);
            } else if (error.message.includes('Asset with this name already exists') ||
                       error.message.includes('409')) {
              // Don't retry conflicts
              throw error;
            } else {
              Logger.error(`Asset creation attempt ${attempt} failed:`, error.message);
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
              Logger.debug(`Waiting ${delay}ms before asset creation retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        // All asset creation attempts failed
        throw lastAssetError || new Error('All asset creation attempts failed');
        
      } catch (error) {
        Logger.error('Exception during asset upload process:', error);
        alert('Failed to upload asset: ' + (error.message || 'Unknown error'));
        throw error;
      }
    }
     
     function showTokenEditor() {
       // Create modal overlay
       const overlay = document.createElement('div');
       overlay.id = 'token-editor-overlay';
       overlay.style.cssText = `
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background: rgba(0, 0, 0, 0.8);
         z-index: 10000;
         display: flex;
         justify-content: center;
         align-items: center;
       `;
       
       // Create modal content
       const modal = document.createElement('div');
       modal.style.cssText = `
         background: white;
         padding: 20px;
         border-radius: 10px;
         max-width: 90%;
         max-height: 90%;
         overflow: auto;
         text-align: center;
       `;
       
       modal.innerHTML = `
         <h2>Editor Token con Ritaglio</h2>
         
         <div style="margin: 10px 0;">
           <label for="token-background-image">Livello 1: Immagine di sfondo</label><br>
           <input type="file" id="token-background-image" accept="image/png,image/jpg,image/jpeg" style="margin: 5px;">
         </div>
         
         <div style="margin: 10px 0;">
           <label>Livello 2: Seleziona Token Border</label><br>
           <div id="token-border-selector" style="display: flex; overflow-x: auto; gap: 10px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; max-width: 100%; white-space: nowrap;">
             <!-- Token borders will be loaded here -->
           </div>
         </div>
         
         <div style="margin: 10px 0;">
           <label for="token-layer-select">Seleziona cosa modificare:</label><br>
           <select id="token-layer-select" style="margin: 5px;">
             <option value="background">Livello 1 (Sfondo)</option>
             <option value="circle">Livello 3 (Cerchio di ritaglio)</option>
           </select>
         </div>
         
         <div style="display: flex; align-items: center; margin: 10px 0; gap: 10px;">
           <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
             <button id="token-zoom-in" style="width: 30px; height: 30px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 16px; font-weight: bold;">+</button>
             <input type="range" id="token-zoom-slider" min="10" max="500" value="100" orient="vertical" style="writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 20px; height: 100px; background: #ddd; outline: none;">
             <button id="token-zoom-out" style="width: 30px; height: 30px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 16px; font-weight: bold;">-</button>
             <span id="token-zoom-display" style="font-size: 12px; color: #666;">100%</span>
           </div>
           <canvas id="token-result-canvas" style="border: 1px solid #000; max-width: calc(100% - 80px);"></canvas>
         </div>
         
         <div style="margin: 10px 0;">
           <button id="token-finalize-button" style="margin: 5px; padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Genera e Carica Token</button>
           <button id="token-cancel-button" style="margin: 5px; padding: 10px 20px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">Annulla</button>
         </div>
         
         <div style="margin: 10px 0; font-size: 12px; color: #666;">
           <p>Istruzioni:</p>
           <p>• Trascina con il mouse per spostare il livello selezionato</p>
           <p>• Usa la rotella del mouse, i pulsanti +/- o la barra di zoom per ridimensionare</p>
           <p>• Il cerchio rosso mostra l'area di ritaglio</p>
         </div>
       `;
       
       overlay.appendChild(modal);
       document.body.appendChild(overlay);
       
       // Initialize token editor
       initTokenEditor(overlay);
     }
     
     function initTokenEditor(overlay) {
       const backgroundInput = document.getElementById('token-background-image');
       const borderSelector = document.getElementById('token-border-selector');
       const layerSelect = document.getElementById('token-layer-select');
       const finalizeButton = document.getElementById('token-finalize-button');
       const cancelButton = document.getElementById('token-cancel-button');
       const canvas = document.getElementById('token-result-canvas');
       const ctx = canvas.getContext('2d');
       
       let backgroundImage = null;
       let crownImage = null;
       let currentLayer = 'background';
       let layers = {
         background: { x: 0, y: 0, scale: 1 },
         circle: { x: 150, y: 150, radius: 50 }
       };
       
       // Load background image
       backgroundInput.addEventListener('change', (event) => {
         const file = event.target.files[0];
         if (!file) return;
         
         const reader = new FileReader();
         reader.onload = () => {
           const img = new Image();
           img.src = reader.result;
           img.onload = () => {
             backgroundImage = img;
             drawTokenCanvas();
           };
         };
         reader.readAsDataURL(file);
       });
       
       // Load available token borders
       async function loadTokenBorders() {
         try {
           const response = await fetch('/api/token-borders');
           if (!response.ok) {
             throw new Error('Failed to load token borders');
           }
           const data = await response.json();
           
           if (!data.success || !Array.isArray(data.borders)) {
             throw new Error('Invalid response format from token borders API');
           }
           
           const borders = data.borders;
           borderSelector.innerHTML = '';
           borders.forEach(border => {
             const borderItem = document.createElement('div');
             borderItem.style.cssText = `
               flex-shrink: 0;
               width: 60px;
               height: 60px;
               border: 2px solid transparent;
               border-radius: 5px;
               cursor: pointer;
               background-size: contain;
               background-repeat: no-repeat;
               background-position: center;
               background-image: url('${border.url}');
               transition: border-color 0.2s;
             `;
             
             borderItem.addEventListener('click', () => {
               // Remove selection from other borders
               borderSelector.querySelectorAll('div').forEach(item => {
                 item.style.borderColor = 'transparent';
               });
               
               // Select this border
               borderItem.style.borderColor = '#007bff';
               
               // Load the border image
               const img = new Image();
               img.src = border.url;
               img.onload = () => {
                 crownImage = img;
                 drawTokenCanvas();
               };
             });
             
             borderSelector.appendChild(borderItem);
           });
         } catch (error) {
           console.error('Error loading token borders:', error);
           borderSelector.innerHTML = '<div style="color: red; padding: 10px;">Errore nel caricamento dei token border</div>';
         }
       }
       
       // Load token borders on initialization
       loadTokenBorders();
       
       // Draw canvas
       function drawTokenCanvas() {
         if (!backgroundImage) return;
         
         // Imposta dimensioni fisse del canvas
         const CANVAS_SIZE = 400;
         canvas.width = CANVAS_SIZE;
         canvas.height = CANVAS_SIZE;
         
         // Se non c'è ancora la corona, inizializza i layer
         if (!crownImage) {
           // Calcola il fattore di scala per adattare l'immagine al canvas
           const scaleX = CANVAS_SIZE / backgroundImage.width;
           const scaleY = CANVAS_SIZE / backgroundImage.height;
           const initialScale = Math.min(scaleX, scaleY); // Mantiene le proporzioni
           
           // Centra l'immagine nel canvas
           const scaledWidth = backgroundImage.width * initialScale;
           const scaledHeight = backgroundImage.height * initialScale;
           layers.background.x = (CANVAS_SIZE - scaledWidth) / 2;
           layers.background.y = (CANVAS_SIZE - scaledHeight) / 2;
           layers.background.scale = initialScale;
           
           // Centra il cerchio inizialmente
           layers.circle.x = CANVAS_SIZE / 2;
           layers.circle.y = CANVAS_SIZE / 2;
           layers.circle.radius = CANVAS_SIZE / 8;
           
           // Update zoom display after initialization
           updateZoomDisplay();
         }
         
         ctx.clearRect(0, 0, canvas.width, canvas.height);
         
         // Draw background layer
         const bg = layers.background;
         ctx.drawImage(
           backgroundImage,
           bg.x,
           bg.y,
           backgroundImage.width * bg.scale,
           backgroundImage.height * bg.scale
         );
         
         // Draw clipping circle guide solo se c'è l'immagine di sfondo
         if (backgroundImage) {
           const cir = layers.circle;
           ctx.beginPath();
           ctx.arc(cir.x, cir.y, cir.radius, 0, Math.PI * 2);
           ctx.strokeStyle = 'red';
           ctx.lineWidth = 2;
           ctx.stroke();
         }
         
         // Draw crown image solo se presente
         if (crownImage) {
           // Ridimensiona anche la corona per adattarla al canvas fisso
           const crownScale = Math.min(CANVAS_SIZE / crownImage.width, CANVAS_SIZE / crownImage.height);
           const crownWidth = crownImage.width * crownScale;
           const crownHeight = crownImage.height * crownScale;
           const crownX = (CANVAS_SIZE - crownWidth) / 2;
           const crownY = (CANVAS_SIZE - crownHeight) / 2;
           ctx.drawImage(crownImage, crownX, crownY, crownWidth, crownHeight);
         }
       }
       
       // Layer selection
       layerSelect.addEventListener('change', (event) => {
         currentLayer = event.target.value;
         updateZoomDisplay();
       });
       
       // Mouse movement and zoom
       canvas.addEventListener('mousemove', (event) => {
         if (event.buttons === 1) {
           const layer = layers[currentLayer];
           if (currentLayer === 'circle') {
             layer.x += event.movementX;
             layer.y += event.movementY;
           } else if (currentLayer === 'background') {
             layer.x += event.movementX;
             layer.y += event.movementY;
           }
           drawTokenCanvas();
         }
       });
       
       canvas.addEventListener('wheel', (event) => {
         event.preventDefault();
         const layer = layers[currentLayer];
         if (currentLayer === 'circle') {
           layer.radius += event.deltaY * -0.1;
           layer.radius = Math.max(10, layer.radius);
         } else if (currentLayer === 'background') {
           layer.scale += event.deltaY * -0.001;
           layer.scale = Math.max(0.1, Math.min(layer.scale, 5));
         }
         updateZoomDisplay();
         drawTokenCanvas();
       });
       
       // Zoom controls
       const zoomInBtn = document.getElementById('token-zoom-in');
       const zoomOutBtn = document.getElementById('token-zoom-out');
       const zoomSlider = document.getElementById('token-zoom-slider');
       const zoomDisplay = document.getElementById('token-zoom-display');
       
       function updateZoomDisplay() {
         if (!zoomDisplay || !zoomSlider) return;
         const layer = layers[currentLayer];
         let zoomValue;
         if (currentLayer === 'circle') {
           zoomValue = Math.round((layer.radius / 50) * 100); // 50 is base radius
         } else if (currentLayer === 'background') {
           zoomValue = Math.round(layer.scale * 100);
         }
         zoomDisplay.textContent = zoomValue + '%';
         zoomSlider.value = zoomValue;
       }
       
       function applyZoom(zoomPercent) {
         const layer = layers[currentLayer];
         if (currentLayer === 'circle') {
           layer.radius = Math.max(10, (zoomPercent / 100) * 50); // 50 is base radius
         } else if (currentLayer === 'background') {
           layer.scale = Math.max(0.1, Math.min(zoomPercent / 100, 5));
         }
         updateZoomDisplay();
         drawTokenCanvas();
       }
       
       if (zoomInBtn) {
         zoomInBtn.addEventListener('click', () => {
           const currentZoom = parseInt(zoomSlider.value) || 100;
           const newZoom = Math.min(currentZoom + 10, 500);
           applyZoom(newZoom);
         });
       }
       
       if (zoomOutBtn) {
         zoomOutBtn.addEventListener('click', () => {
           const currentZoom = parseInt(zoomSlider.value) || 100;
           const newZoom = Math.max(currentZoom - 10, 10);
           applyZoom(newZoom);
         });
       }
       
       if (zoomSlider) {
         zoomSlider.addEventListener('input', (event) => {
           applyZoom(parseInt(event.target.value));
         });
       }
       

       
       // Cancel button
       cancelButton.addEventListener('click', () => {
         document.body.removeChild(overlay);
       });
       
       // Finalize and upload
       finalizeButton.addEventListener('click', async () => {
         if (!backgroundImage) {
           alert('Carica almeno l\'immagine di sfondo prima di procedere.');
           return;
         }
         
         try {
           const cir = layers.circle;
           
           // Create output canvas with clipping
           const outputCanvas = document.createElement('canvas');
           const outputCtx = outputCanvas.getContext('2d');
           const CANVAS_SIZE = 400;
           outputCanvas.width = CANVAS_SIZE;
           outputCanvas.height = CANVAS_SIZE;
           
           outputCtx.save();
           outputCtx.beginPath();
           outputCtx.arc(cir.x, cir.y, cir.radius, 0, Math.PI * 2);
           outputCtx.clip();
           
           outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
           const bg = layers.background;
           outputCtx.drawImage(
             backgroundImage,
             bg.x,
             bg.y,
             backgroundImage.width * bg.scale,
             backgroundImage.height * bg.scale
           );
           outputCtx.restore();
           
           // Draw crown on top solo se presente
           if (crownImage) {
             const crownScale = Math.min(CANVAS_SIZE / crownImage.width, CANVAS_SIZE / crownImage.height);
             const crownWidth = crownImage.width * crownScale;
             const crownHeight = crownImage.height * crownScale;
             const crownX = (CANVAS_SIZE - crownWidth) / 2;
             const crownY = (CANVAS_SIZE - crownHeight) / 2;
             outputCtx.drawImage(crownImage, crownX, crownY, crownWidth, crownHeight);
           }
           
           // Convert to blob and upload
           outputCanvas.toBlob(async (blob) => {
             try {
               const file = new File([blob], 'token_edited.png', { type: 'image/png' });
               const campaignId = MapState.getCampaignId();
               
               await processAssetUpload(file, 'tokens', campaignId);
               document.body.removeChild(overlay);
               
             } catch (error) {
               Logger.error('Error uploading edited token:', error);
               alert('Errore durante il caricamento del token: ' + error.message);
             }
           }, 'image/png');
           
         } catch (error) {
           Logger.error('Error generating final token:', error);
           alert('Errore durante la generazione del token: ' + error.message);
         }
       });
       
       // Close on overlay click
       overlay.addEventListener('click', (event) => {
         if (event.target === overlay) {
           document.body.removeChild(overlay);
         }
       });
     }
     
     async function editAsset(assetId) {
      try {
        // Validate asset ID
        if (!assetId || isNaN(parseInt(assetId))) {
          Logger.error('Invalid asset ID for editing:', assetId);
          alert('Error: Invalid asset ID.');
          return;
        }
        
        const numericAssetId = parseInt(assetId);
        
        // Validate assets array
        if (!Array.isArray(assets)) {
          Logger.error('Assets array is not valid:', assets);
          alert('Error: Assets data not loaded. Please reload the page.');
          return;
        }
        
        const asset = assets.find(a => a && a.id == numericAssetId);
        if (!asset) {
          Logger.error('Asset not found for editing:', numericAssetId);
          alert('Error: Asset not found.');
          return;
        }
        
        if (!asset.name || typeof asset.name !== 'string') {
          Logger.error('Asset has invalid name:', asset);
          alert('Error: Asset has invalid name.');
          return;
        }
        
        Logger.info('Editing asset:', asset.name, 'ID:', numericAssetId);
        
        const newName = await showInputDialog('Enter new name:', asset.name);
        if (!newName || typeof newName !== 'string' || newName.trim().length === 0) {
          Logger.warn('Asset edit cancelled or invalid name provided');
          return;
        }
        
        const trimmedName = newName.trim();
        if (trimmedName.length > 255) {
          alert('Error: Asset name too long (maximum 255 characters).');
          return;
        }
        
        if (trimmedName === asset.name) {
          Logger.info('Asset name unchanged, no update needed');
          return;
        }
        
        Logger.info('Updating asset name from', asset.name, 'to', trimmedName);
        
        // Update asset with retry logic
        let lastError;
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            Logger.debug(`Asset update attempt ${attempt}/3 for asset ${numericAssetId}`);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(`/api/assets/${numericAssetId}`, {
              method: 'PUT',
              headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
              },
              body: JSON.stringify({
                name: trimmedName
              }),
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
              if (response.status >= 500) {
                throw new Error(`Server error: ${response.status} ${response.statusText}`);
              } else if (response.status === 404) {
                throw new Error('Asset not found on server');
              } else if (response.status === 409) {
                throw new Error('Asset name already exists');
              } else if (response.status === 403) {
                throw new Error('Permission denied to update asset');
              } else {
                throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
              }
            }
            
            let data;
            try {
              const responseText = await response.text();
              if (!responseText || responseText.trim() === '') {
                throw new Error('Empty response from asset update API');
              }
              
              data = JSON.parse(responseText);
            } catch (parseError) {
              Logger.error('Failed to parse asset update response:', parseError);
              throw new Error('Invalid JSON response from asset update API');
            }
            
            if (!data || typeof data !== 'object') {
              throw new Error('Invalid asset update response structure');
            }
            
            if (data.success) {
              Logger.info('Asset updated successfully:', trimmedName);
              
              // Update local asset data
              asset.name = trimmedName;
              
              // Reload assets to ensure consistency
              try {
                await loadAssets();
              } catch (reloadError) {
                Logger.warn('Failed to reload assets after update:', reloadError);
                // Don't fail the entire operation if reload fails
              }
              
              alert('Asset updated successfully!');
              return; // Success
              
            } else {
              const errorMsg = data.error || 'Unknown error occurred';
              throw new Error(`Asset update failed: ${errorMsg}`);
            }
            
          } catch (error) {
            lastError = error;
            
            if (error.name === 'AbortError') {
              Logger.error(`Asset update request timeout on attempt ${attempt}`);
            } else if (error.message.includes('Asset not found') ||
                       error.message.includes('Asset name already exists') ||
                       error.message.includes('Permission denied') ||
                       error.message.includes('404') ||
                       error.message.includes('409') ||
                       error.message.includes('403')) {
              // Don't retry these errors
              throw error;
            } else {
              Logger.error(`Asset update attempt ${attempt} failed:`, error.message);
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
              Logger.debug(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        // All attempts failed
        throw lastError || new Error('All asset update attempts failed');
        
      } catch (error) {
        Logger.error('Exception during asset editing:', error);
        alert('Failed to update asset: ' + (error.message || 'Network error'));
      }
    }

    async function editTokenName(assetData, assetElement) {
      try {
        // Validate input parameters
        if (!assetData || !assetElement) {
          Logger.error('Invalid parameters for editTokenName:', { assetData, assetElement });
          alert('Error: Invalid token data.');
          return;
        }
        
        if (!assetData.assetId || !assetData.assetName) {
          Logger.error('Missing required asset data:', assetData);
          alert('Error: Missing asset information.');
          return;
        }
        
        const currentName = assetData.assetName || 'Token';
        Logger.info('Editing token name:', currentName, 'Asset ID:', assetData.assetId);
        
        const newName = await showInputDialog('Inserisci il nuovo nome del token:', currentName);
        if (!newName || typeof newName !== 'string' || newName.trim().length === 0) {
          Logger.warn('Token name edit cancelled or invalid name provided');
          return;
        }
        
        const trimmedName = newName.trim();
        if (trimmedName === currentName) {
          Logger.info('Token name unchanged, no update needed');
          return;
        }
        
        let tokenId = assetData.tokenId;
        
        // If tokenId is not available, find it from the map tokens
        if (!tokenId) {
          try {
            const mapId = getCurrentMapId();
            if (!mapId) {
              Logger.error('No current map ID available');
              alert('Error: No map selected.');
              return;
            }
            
            const tokensResponse = await fetch(`/api/map-tokens?map_id=${mapId}`);
            
            if (!tokensResponse.ok) {
              throw new Error(`HTTP error! status: ${tokensResponse.status}`);
            }
            
            const tokensData = await tokensResponse.json();
            
            if (!tokensData || !tokensData.success || !Array.isArray(tokensData.tokens)) {
              Logger.error('Invalid tokens response:', tokensData);
              alert('Errore nel recupero dei token dalla mappa');
              return;
            }
            
            const token = tokensData.tokens.find(t => t && t.asset_id == parseInt(assetData.assetId));
            if (!token) {
              Logger.error('Token not found in map tokens:', assetData.assetId);
              alert('Token non trovato nel database');
              return;
            }
            tokenId = token.id;
          } catch (tokenFetchError) {
            Logger.error('Error fetching map tokens:', tokenFetchError);
            alert('Errore nel recupero dei token dalla mappa');
            return;
          }
        }
        
        Logger.info('Updating token name from', currentName, 'to', trimmedName, 'Token ID:', tokenId);
        
        // Update the asset name in the assets table
        const assetResponse = await fetch(`/api/assets/${assetData.assetId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: trimmedName
          })
        });
        
        if (!assetResponse.ok) {
          throw new Error(`Asset update HTTP error! status: ${assetResponse.status}`);
        }
        
        const assetResult = await assetResponse.json();
        if (!assetResult || !assetResult.success) {
          const errorMsg = assetResult?.error || 'Unknown asset update error';
          Logger.error('Asset update failed:', errorMsg);
          alert('Errore nell\'aggiornamento dell\'asset: ' + errorMsg);
          return;
        }
        
        // Update the token name in map_tokens table
        const tokenResponse = await fetch(`/api/map-tokens/${tokenId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            name: trimmedName
          })
        });
        
        if (!tokenResponse.ok) {
          throw new Error(`Token update HTTP error! status: ${tokenResponse.status}`);
        }
        
        const tokenData = await tokenResponse.json();
        if (tokenData && tokenData.success) {
          // Update the visual element
          try {
            assetData.assetName = trimmedName;
            assetElement.title = `${assetData.assetType}: ${trimmedName}`;
            
            // Update the assets array
            if (Array.isArray(assets)) {
              const asset = assets.find(a => a && a.id == assetData.assetId);
              if (asset) {
                asset.name = trimmedName;
              }
            }
            
            // Refresh the assets display
            await displayAssets();
            
            Logger.info('Token name updated successfully:', trimmedName);
            alert('Nome del token aggiornato con successo!');
          } catch (updateError) {
            Logger.error('Error updating visual elements:', updateError);
            alert('Token aggiornato ma errore nell\'aggiornamento dell\'interfaccia');
          }
        } else {
          const errorMsg = tokenData?.error || 'Unknown token update error';
          Logger.error('Token update failed:', errorMsg);
          alert('Asset aggiornato ma errore nell\'aggiornamento del token sulla mappa: ' + errorMsg);
        }
      } catch (error) {
        Logger.error('Exception during token name editing:', error);
        alert('Errore nell\'aggiornamento del token: ' + (error.message || 'Network error'));
      }
    }
    
    async function deleteAsset(assetId) {
      try {
        // Validate asset ID
        if (!assetId || isNaN(parseInt(assetId))) {
          Logger.error('Invalid asset ID for deletion:', assetId);
          alert('Error: Invalid asset ID.');
          return;
        }
        
        const numericAssetId = parseInt(assetId);
        
        // Find asset for confirmation
        let assetName = 'this asset';
        if (Array.isArray(assets)) {
          const asset = assets.find(a => a && a.id == numericAssetId);
          if (asset && asset.name) {
            assetName = asset.name;
          }
        }
        
        if (!confirm(`Are you sure you want to delete "${assetName}"? This action cannot be undone.`)) {
          Logger.info('Asset deletion cancelled by user');
          return;
        }
        
        Logger.info('Deleting asset:', assetName, 'ID:', numericAssetId);
        
        // Retry logic for delete operation
        let lastError;
        for (let attempt = 1; attempt <= 3; attempt++) {
          try {
            Logger.debug(`Delete attempt ${attempt}/3 for asset ${numericAssetId}`);
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(`/api/assets/${numericAssetId}`, {
              method: 'DELETE',
              signal: controller.signal,
              headers: {
                'Content-Type': 'application/json'
              }
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
              let data;
              try {
                const responseText = await response.text();
                if (responseText && responseText.trim()) {
                  data = JSON.parse(responseText);
                } else {
                  data = { success: true }; // Assume success if empty response
                }
              } catch (parseError) {
                Logger.warn('Failed to parse delete response, assuming success:', parseError);
                data = { success: true };
              }
              
              if (data.success !== false) {
                Logger.info('Asset deleted successfully:', assetName);
                
                // Update local assets array
                if (Array.isArray(assets)) {
                  const index = assets.findIndex(a => a && a.id == numericAssetId);
                  if (index !== -1) {
                    assets.splice(index, 1);
                  }
                }
                
                // Reload assets to ensure consistency
                try {
                  await loadAssets();
                } catch (reloadError) {
                  Logger.warn('Failed to reload assets after deletion:', reloadError);
                }
                
                alert('Asset deleted successfully!');
                return;
              } else {
                throw new Error(data.error || 'Delete operation failed');
              }
            } else if (response.status === 404) {
              Logger.warn('Asset not found, may have been already deleted:', numericAssetId);
              alert('Asset not found. It may have been already deleted.');
              await loadAssets(); // Refresh to sync state
              return;
            } else if (response.status >= 500) {
              throw new Error(`Server error: ${response.status} ${response.statusText}`);
            } else {
              throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
            }
            
          } catch (error) {
            lastError = error;
            
            if (error.name === 'AbortError') {
              Logger.error(`Delete request timeout on attempt ${attempt}`);
            } else if (error.message.includes('fetch')) {
              Logger.error(`Network error on delete attempt ${attempt}:`, error.message);
            } else {
              Logger.error(`Delete attempt ${attempt} failed:`, error.message);
            }
            
            // Don't retry on certain errors
            if (error.message.includes('Invalid asset ID') || 
                error.message.includes('404') ||
                error.message.includes('403')) {
              throw error;
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < 3) {
              const delay = Math.pow(2, attempt) * 1000; // 2s, 4s
              Logger.debug(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        // All attempts failed
        throw lastError || new Error('All delete attempts failed');
        
      } catch (error) {
        Logger.error('Exception during asset deletion:', error);
        
        let errorMessage = 'Failed to delete asset';
        if (error.name === 'AbortError') {
          errorMessage += ': Request timeout';
        } else if (error.message.includes('fetch') || error.message.includes('network')) {
          errorMessage += ': Network error';
        } else {
          errorMessage += ': ' + (error.message || 'Unknown error');
        }
        
        alert(errorMessage);
      }
    }
    
    function formatFileSize(bytes) {
      try {
        // Validate input - handle null, undefined, empty string, and non-numeric values
        if (bytes === null || bytes === undefined || bytes === '' || typeof bytes !== 'number' || isNaN(bytes) || bytes < 0) {
          if (bytes !== null && bytes !== undefined && bytes !== '') {
            Logger.warn('Invalid bytes value for formatFileSize:', bytes);
          }
          return 'Unknown size';
        }
        
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        // Ensure index is within bounds
        const sizeIndex = Math.min(i, sizes.length - 1);
        const formattedSize = parseFloat((bytes / Math.pow(k, sizeIndex)).toFixed(2));
        
        return formattedSize + ' ' + sizes[sizeIndex];
      } catch (error) {
        Logger.error('Error formatting file size:', error, bytes);
        return 'Unknown size';
      }
    }
    
    function addToken() {
      alert('Active token management will be implemented in future updates. Use Assets > Tokens to upload token images.');
    }
    
    function addJournalEntry() {
      alert('Journal system will be implemented in future updates');
    }
    
    // ===== TOKEN SELECTION SYSTEM =====
    let selectedTokens = new Set();
    let isSelecting = false;
    let selectionBox = null;
    let selectionStartX = 0;
    let selectionStartY = 0;
    
    function selectToken(tokenElement, isShiftKey = false) {
      try {
        if (!tokenElement || !tokenElement.dataset.selectable) {
          Logger.warn('Invalid token element for selection:', tokenElement);
          return;
        }
        
        const tokenId = tokenElement.dataset.tokenId;
        if (!tokenId) {
          Logger.warn('Token element missing tokenId:', tokenElement);
          return;
        }
        
        Logger.debug('Selecting token:', tokenId, 'Shift key:', isShiftKey);
        
        if (!isShiftKey) {
          // Clear previous selection if not holding Shift
          clearTokenSelection();
        }
        
        if (selectedTokens.has(tokenId)) {
          // Deselect if already selected and Shift is held
          if (isShiftKey) {
            deselectToken(tokenElement);
          }
        } else {
          // Add to selection
          selectedTokens.add(tokenId);
          tokenElement.classList.add('selected-token');
          tokenElement.style.boxShadow = '0 0 10px 3px rgba(255, 215, 0, 0.8)';
          tokenElement.style.zIndex = '1000';
        }
        
        Logger.info(`Selected tokens: ${selectedTokens.size}`);
        updateSelectionUI();
        
      } catch (error) {
        Logger.error('Error in selectToken:', error);
      }
    }
    
    function deselectToken(tokenElement) {
      try {
        const tokenId = tokenElement.dataset.tokenId;
        if (tokenId && selectedTokens.has(tokenId)) {
          selectedTokens.delete(tokenId);
          tokenElement.classList.remove('selected-token');
          tokenElement.style.boxShadow = '';
          tokenElement.style.zIndex = '';
        }
      } catch (error) {
        Logger.error('Error in deselectToken:', error);
      }
    }
    
    function clearTokenSelection() {
      try {
        const selectedElements = document.querySelectorAll('.selected-token');
        selectedElements.forEach(element => {
          element.classList.remove('selected-token');
          element.style.boxShadow = '';
          element.style.zIndex = '';
        });
        selectedTokens.clear();
        updateSelectionUI();
        
        // Clear any selection box if active
        if (selectionBox) {
          try {
            selectionBox.remove();
            selectionBox = null;
            isSelecting = false;
          } catch (error) {
            Logger.warn('Failed to remove selection box during token selection clear', error);
          }
        }
        
        Logger.debug('Token selection cleared');
      } catch (error) {
        Logger.error('Error in clearTokenSelection:', error);
      }
    }
    
    function updateSelectionUI() {
       try {
         // Update UI to show selection count or selected token info
         const selectionInfo = document.getElementById('selection-info');
         if (selectionInfo) {
           if (selectedTokens.size === 0) {
             selectionInfo.textContent = '';
           } else if (selectedTokens.size === 1) {
             selectionInfo.textContent = '1 token selected';
           } else {
             selectionInfo.textContent = `${selectedTokens.size} tokens selected`;
           }
         }
       } catch (error) {
         Logger.error('Error in updateSelectionUI:', error);
       }
     }
     
     // ===== TOKEN MOVEMENT SYSTEM =====
     function moveSelectedTokens(direction) {
       try {
         if (selectedTokens.size === 0) {
           Logger.warn('No tokens selected for movement');
           return;
         }
         
         // Calculate movement delta based on grid size
         const gridSize = 50; // Default grid size in pixels
         let deltaX = 0;
         let deltaY = 0;
         
         switch(direction) {
           case 'arrowup':
             deltaY = -gridSize;
             break;
           case 'arrowdown':
             deltaY = gridSize;
             break;
           case 'arrowleft':
             deltaX = -gridSize;
             break;
           case 'arrowright':
             deltaX = gridSize;
             break;
           default:
             Logger.warn('Invalid movement direction:', direction);
             return;
         }
         
         // Move each selected token
         selectedTokens.forEach(tokenId => {
           const tokenElement = document.querySelector(`[data-token-id="${tokenId}"]`);
           if (tokenElement) {
             moveTokenElement(tokenElement, deltaX, deltaY);
           }
         });
         
         Logger.info(`Moved ${selectedTokens.size} tokens ${direction}`);
         
       } catch (error) {
         Logger.error('Error in moveSelectedTokens:', error);
       }
     }
     
     function moveTokenElement(tokenElement, deltaX, deltaY) {
       try {
         // Get current position
         const currentLeft = parseInt(tokenElement.style.left) || 0;
         const currentTop = parseInt(tokenElement.style.top) || 0;
         
         // Calculate new position
         const newLeft = currentLeft + deltaX;
         const newTop = currentTop + deltaY;
         
         // Apply new position
         tokenElement.style.left = newLeft + 'px';
         tokenElement.style.top = newTop + 'px';
         
         // Update token position on server
         updateTokenPositionOnServer(tokenElement, newLeft, newTop);
         
         Logger.debug('Token moved:', {
           tokenId: tokenElement.dataset.tokenId,
           from: { x: currentLeft, y: currentTop },
           to: { x: newLeft, y: newTop }
         });
         
       } catch (error) {
         Logger.error('Error in moveTokenElement:', error);
       }
     }
     
     // ===== MODULAR TOKEN POSITION UPDATE SYSTEM =====
     
     // Configuration constants
     const TOKEN_UPDATE_CONFIG = {
       BATCH_DELAY_MS: 300,
       MAX_BATCH_SIZE: 20,
       MAX_RETRY_ATTEMPTS: 3,
       DEBOUNCE_TIMEOUT: 100
     };
     
     // State management
     const tokenUpdateState = {
       pendingUpdates: new Map(),
       batchTimeout: null,
       isProcessing: false,
       retryQueue: new Map()
     };
     
     // ===== COORDINATE CONVERSION UTILITIES =====
     
     function validateTokenElement(tokenElement) {
       if (!tokenElement) {
         throw new Error('Token element is null or undefined');
       }
       
       const tokenId = tokenElement.dataset.tokenId;
       if (!tokenId) {
         throw new Error('Token element missing tokenId');
       }
       
       return tokenId;
     }
     
     function validateCoordinates(x, y) {
       if (typeof x !== 'number' || typeof y !== 'number' || isNaN(x) || isNaN(y)) {
         throw new Error(`Invalid coordinates: x=${x}, y=${y}`);
       }
       return { x, y };
     }
     
     function convertPixelToGridCoordinates(x, y) {
       try {
         const mapCoords = screenToMapCoordinates(x, y);
         const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
         
         Logger.debug('convertPixelToGridCoordinates:', {
           input: { x, y },
           mapCoords: { x: mapCoords.x, y: mapCoords.y },
           gridCoords: { x: gridCoords.x, y: gridCoords.y },
           transform: CoordinateSystem.getGridTransformMatrix(),
           gridSize: CoordinateSystem.getGridSize()
         });
         
         if (isNaN(gridCoords.x) || isNaN(gridCoords.y)) {
           throw new Error('Grid coordinate conversion failed');
         }
         
         return gridCoords;
       } catch (error) {
         Logger.error('Coordinate conversion error:', error);
         throw error;
       }
     }
     
     // Convert grid coordinates back to pixel coordinates
     function gridToPixelCoordinates(gridX, gridY) {
       try {
         // gridToMapCoordinates already returns pixel coordinates within the map
         const pixelCoords = gridToMapCoordinates(gridX, gridY);
         
         if (isNaN(pixelCoords.x) || isNaN(pixelCoords.y)) {
           throw new Error('Pixel coordinate conversion failed');
         }
         
         return pixelCoords;
       } catch (error) {
         Logger.error('Grid to pixel conversion error:', error);
         throw error;
       }
     }
     
     // ===== TOKEN UPDATE QUEUE MANAGEMENT =====
     
     function queueTokenUpdate(tokenId, tokenElement, x, y, gridCoords) {
       const updateData = {
         tokenElement,
         pixelCoords: { x, y },
         gridCoords,
         timestamp: Date.now(),
         originalPosition: {
           left: tokenElement.style.left,
           top: tokenElement.style.top
         }
       };
       
       tokenUpdateState.pendingUpdates.set(tokenId, updateData);
       
       Logger.debug('Token update queued:', {
         tokenId,
         gridCoords,
         queueSize: tokenUpdateState.pendingUpdates.size
       });
       
       return updateData;
     }
     
     function shouldProcessImmediately() {
       return tokenUpdateState.pendingUpdates.size >= TOKEN_UPDATE_CONFIG.MAX_BATCH_SIZE;
     }
     
     function scheduleTokenBatchUpdate() {
       // Clear existing timeout
       if (tokenUpdateState.batchTimeout) {
         clearTimeout(tokenUpdateState.batchTimeout);
         tokenUpdateState.batchTimeout = null;
       }
       
       if (shouldProcessImmediately()) {
         Logger.info('Processing token batch immediately due to size limit');
         processPendingTokenUpdates();
       } else {
         tokenUpdateState.batchTimeout = setTimeout(() => {
           processPendingTokenUpdates();
         }, TOKEN_UPDATE_CONFIG.BATCH_DELAY_MS);
       }
     }
     
     // ===== MAIN TOKEN UPDATE FUNCTION =====
     
     function updateTokenPositionOnServer(tokenElement, x, y) {
       try {
         // Step 1: Validate inputs
         const tokenId = validateTokenElement(tokenElement);
         validateCoordinates(x, y);
         
         const mapId = getCurrentMapId();
         if (!mapId) {
           throw new Error('No current map ID available');
         }
         
         // Step 2: Convert coordinates
         const gridCoords = convertPixelToGridCoordinates(x, y);
         
         // Step 3: Queue the update
         queueTokenUpdate(tokenId, tokenElement, x, y, gridCoords);
         
         // Step 4: Schedule batch processing
         scheduleTokenBatchUpdate();
         
       } catch (error) {
         Logger.error('Error in updateTokenPositionOnServer:', error);
         showNotification('Failed to update token position', 'error');
       }
     }
     
     // ===== BATCH PROCESSING FUNCTIONS =====
     
     function prepareBatchUpdateData() {
       const tokensToUpdate = [];
       const updateMap = new Map();
       
       for (const [tokenId, updateData] of tokenUpdateState.pendingUpdates) {
         const tokenUpdate = {
           id: tokenId,
           grid_x: updateData.gridCoords.x,
           grid_y: updateData.gridCoords.y
         };
         
         tokensToUpdate.push(tokenUpdate);
         updateMap.set(tokenId, updateData);
       }
       
       return { tokensToUpdate, updateMap };
     }
     
     function clearBatchTimeout() {
       if (tokenUpdateState.batchTimeout) {
         clearTimeout(tokenUpdateState.batchTimeout);
         tokenUpdateState.batchTimeout = null;
       }
     }
     
     function resetBatchState() {
       tokenUpdateState.pendingUpdates.clear();
       tokenUpdateState.isProcessing = false;
       clearBatchTimeout();
     }
     
     async function executeBatchUpdate(tokensToUpdate, updateMap) {
       try {
         Logger.info(`Executing batch update for ${tokensToUpdate.length} tokens`);
         
         const success = await sendBatchUpdateWithRetry(tokensToUpdate, updateMap);
         
         if (success) {
           Logger.info('Batch update completed successfully');
           // Update visual positions to match server state
           updateTokenVisualPositions(updateMap);
           showNotification(`${tokensToUpdate.length} tokens updated successfully`, 'success');
         } else {
           Logger.error('Batch update failed after all retries');
           await handleBatchUpdateFailure(updateMap);
         }
         
         return success;
       } catch (error) {
         Logger.error('Critical error during batch update:', error);
         await handleBatchUpdateFailure(updateMap);
         return false;
       }
     }
     
     // Update visual positions after successful batch update
     function updateTokenVisualPositions(updateMap) {
       try {
         Logger.debug('Updating visual positions after successful batch update');
         
         for (const [tokenId, updateData] of updateMap) {
           const tokenElement = updateData.tokenElement;
           if (tokenElement) {
             // Convert grid coordinates back to pixel coordinates for visual update
             const pixelCoords = gridToPixelCoordinates(updateData.gridCoords.x, updateData.gridCoords.y);
             
             // Update the visual position to match the server state
             tokenElement.style.left = pixelCoords.x + 'px';
             tokenElement.style.top = pixelCoords.y + 'px';
             
             // Update any stored position data
             tokenElement.dataset.gridX = updateData.gridCoords.x.toString();
             tokenElement.dataset.gridY = updateData.gridCoords.y.toString();
             
             Logger.debug(`Updated visual position for token ${tokenId}:`, {
               gridCoords: updateData.gridCoords,
               pixelCoords: pixelCoords
             });
           }
         }
       } catch (error) {
         Logger.error('Error updating visual positions:', error);
       }
     }
     
     async function handleBatchUpdateFailure(updateMap) {
       Logger.warn('Handling batch update failure - rolling back visual changes');
       
       for (const [tokenId, updateData] of updateMap) {
         try {
           const tokenElement = updateData.tokenElement;
           if (tokenElement && updateData.originalPosition) {
             tokenElement.style.left = updateData.originalPosition.left;
             tokenElement.style.top = updateData.originalPosition.top;
           }
         } catch (rollbackError) {
           Logger.error(`Failed to rollback token ${tokenId}:`, rollbackError);
         }
       }
       
       showNotification('Token update failed - positions restored', 'error');
     }
     
     // Main batch processing function
     async function processPendingTokenUpdates() {
       // Prevent concurrent processing
       if (tokenUpdateState.isProcessing || tokenUpdateState.pendingUpdates.size === 0) {
         return;
       }
       
       tokenUpdateState.isProcessing = true;
       
       try {
         // Step 1: Clear timeout and prepare data
         clearBatchTimeout();
         const { tokensToUpdate, updateMap } = prepareBatchUpdateData();
         
         // Step 2: Clear pending updates immediately
         tokenUpdateState.pendingUpdates.clear();
         
         // Step 3: Execute the batch update
         await executeBatchUpdate(tokensToUpdate, updateMap);
         
       } catch (error) {
         Logger.error('Critical error in processPendingTokenUpdates:', error);
         showNotification('Failed to process token updates', 'error');
       } finally {
         tokenUpdateState.isProcessing = false;
       }
     }
     
     // Send batch update with retry logic
     async function sendBatchUpdateWithRetry(tokensToUpdate, updateMap, attempt = 1) {
       try {
         const response = await fetch('/api/map-tokens/batch', {
           method: 'PUT',
           headers: {
             'Content-Type': 'application/json'
           },
           body: JSON.stringify({
             tokens: tokensToUpdate
           }),
           signal: AbortSignal.timeout(15000) // 15 second timeout
         });
         
         if (!response.ok) {
           throw new Error(`HTTP error! status: ${response.status}`);
         }
         
         const data = await response.json();
         
         if (!data.success) {
           throw new Error('Server reported batch update failure');
         }
         
         Logger.info('Batch update successful:', {
           totalTokens: data.total_tokens,
           successful: data.successful_updates,
           failed: data.failed_updates
         });
         
         // Log any individual failures
         if (data.errors && data.errors.length > 0) {
           Logger.warn('Some tokens failed to update:', data.errors);
         }
         
         return true;
         
       } catch (error) {
         Logger.error(`Batch update attempt ${attempt} failed:`, error);
         
         // Retry logic
         if (attempt < TOKEN_UPDATE_CONFIG.MAX_RETRY_ATTEMPTS) {
           const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
           Logger.info(`Retrying batch update in ${delay}ms (attempt ${attempt + 1}/${TOKEN_UPDATE_CONFIG.MAX_RETRY_ATTEMPTS})`);
           
           await new Promise(resolve => setTimeout(resolve, delay));
           return sendBatchUpdateWithRetry(tokensToUpdate, updateMap, attempt + 1);
         }
         
         return false;
       }
     }
     
     // Rollback visual changes for failed updates
     function rollbackFailedUpdates(updateMap) {
       try {
         Logger.warn('Rolling back visual changes for failed token updates');
         
         for (const [tokenId, updateData] of updateMap) {
           const tokenElement = updateData.tokenElement;
           if (tokenElement && updateData.originalPosition) {
             tokenElement.style.left = updateData.originalPosition.left;
             tokenElement.style.top = updateData.originalPosition.top;
             
             // Add visual indication of failure
             tokenElement.style.border = '2px solid red';
             setTimeout(() => {
               tokenElement.style.border = '';
             }, 2000);
           }
         }
         
         // Show user notification
         showNotification('Some token positions could not be saved. Changes have been reverted.', 'error');
         
       } catch (error) {
         Logger.error('Error in rollbackFailedUpdates:', error);
       }
     }
     
     // Force process any pending updates (called on page unload, etc.)
     function flushPendingTokenUpdates() {
       if (tokenUpdateState.pendingUpdates.size > 0) {
         Logger.info('Flushing pending token updates');
         processPendingTokenUpdates();
       }
     }
     
     // Enhanced notification system
     function showNotification(message, type = 'info') {
       try {
         // Create notification element
         const notification = document.createElement('div');
         notification.className = `notification notification-${type}`;
         notification.style.cssText = `
           position: fixed;
           top: 20px;
           right: 20px;
           padding: 12px 20px;
           border-radius: 4px;
           color: white;
           font-weight: bold;
           z-index: 10000;
           max-width: 300px;
           word-wrap: break-word;
           ${type === 'error' ? 'background-color: #dc3545;' : ''}
           ${type === 'success' ? 'background-color: #28a745;' : ''}
           ${type === 'warning' ? 'background-color: #ffc107; color: black;' : ''}
           ${type === 'info' ? 'background-color: #17a2b8;' : ''}
         `;
         notification.textContent = message;
         
         document.body.appendChild(notification);
         
         // Auto-remove after 5 seconds
         setTimeout(() => {
           if (notification.parentNode) {
             notification.parentNode.removeChild(notification);
           }
         }, 5000);
         
       } catch (error) {
         Logger.error('Error showing notification:', error);
         // Fallback to console
         console.log(`[${type.toUpperCase()}] ${message}`);
       }
     }
      
      // ===== MULTI-TOKEN DROP SYSTEM =====
      
      function validateMultiTokenDropInputs(e, dragData) {
        if (!e || !dragData) {
          throw new Error('Invalid parameters for multi-token drop');
        }
        
        if (!dragData.tokens || !Array.isArray(dragData.tokens) || dragData.tokens.length === 0) {
          throw new Error('Invalid or empty tokens array in drag data');
        }
        
        if (typeof dragData.dragStartX !== 'number' || typeof dragData.dragStartY !== 'number') {
          throw new Error('Invalid drag start coordinates');
        }
        
        return true;
      }
      
      function calculateDropDelta(e, dragData) {
        const mapGrid = document.getElementById('map-grid');
        if (!mapGrid) {
          throw new Error('Map grid not found');
        }
        
        const rect = mapGrid.getBoundingClientRect();
        const dropX = e.clientX - rect.left;
        const dropY = e.clientY - rect.top;
        
        if (isNaN(dropX) || isNaN(dropY)) {
          throw new Error(`Invalid drop coordinates: x=${dropX}, y=${dropY}`);
        }
        
        // dragData.dragStartX and dragData.dragStartY are already absolute screen coordinates
        // Convert them to map-grid-relative coordinates
        const dragStartX = dragData.dragStartX - rect.left;
        const dragStartY = dragData.dragStartY - rect.top;
        
        const deltaX = dropX - dragStartX;
        const deltaY = dropY - dragStartY;
        
        // DEBUG: Informazioni dettagliate sul rilascio del token
        console.log('=== DEBUG RILASCIO TOKEN ===');
        console.log('Posizione mouse assoluta:', { x: e.clientX, y: e.clientY });
        console.log('Rettangolo map-grid:', { left: rect.left, top: rect.top, width: rect.width, height: rect.height });
        console.log('Posizione rilascio relativa a map-grid:', { x: dropX, y: dropY });
        console.log('Posizione inizio drag relativa a map-grid:', { x: dragStartX, y: dragStartY });
        console.log('Delta movimento:', { x: deltaX, y: deltaY });
        console.log('Posizione inizio drag assoluta:', { x: dragData.dragStartX, y: dragData.dragStartY });
        
        // VERIFICA: Controllo se le coordinate di inizio drag sono corrette
        const transform = CoordinateSystem.getGridTransformMatrix();
        console.log('Trasformazione griglia:', transform);
        
        // Converti le coordinate di inizio drag in coordinate mappa per verifica
        const dragStartMapCoords = screenToMapCoordinates(dragData.dragStartX, dragData.dragStartY);
        const dragStartGridCoords = mapToGridCoordinates(dragStartMapCoords.x, dragStartMapCoords.y);
        console.log('Coordinate mappa inizio drag:', dragStartMapCoords);
        console.log('Coordinate griglia inizio drag:', dragStartGridCoords);
        
        // Converti le coordinate di rilascio in coordinate della mappa
        const absoluteDropX = e.clientX;
        const absoluteDropY = e.clientY;
        const mapDropCoords = screenToMapCoordinates(absoluteDropX, absoluteDropY);
        const gridDropCoords = mapToGridCoordinates(mapDropCoords.x, mapDropCoords.y);
        
        console.log('Coordinate mappa del punto di rilascio:', mapDropCoords);
        console.log('Coordinate griglia del punto di rilascio:', gridDropCoords);
        console.log('===============================');
        
        Logger.debug('Multi-token drop delta calculated:', {
          dropPosition: { x: dropX, y: dropY },
          dragStart: { x: dragStartX, y: dragStartY },
          delta: { x: deltaX, y: deltaY },
          absoluteDragStart: { x: dragData.dragStartX, y: dragData.dragStartY },
          mapGridRect: { left: rect.left, top: rect.top },
          mousePosition: { x: e.clientX, y: e.clientY },
          mapDropCoords: mapDropCoords,
          gridDropCoords: gridDropCoords
        });
        
        return { deltaX, deltaY };
      }
      
      function validateAndProcessTokens(dragData, deltaX, deltaY) {
        const validTokens = [];
        const invalidTokens = [];
        
        dragData.tokens.forEach((tokenData, index) => {
          try {
            // Validate token data structure
            if (!tokenData || typeof tokenData !== 'object') {
              invalidTokens.push({ index, reason: 'Invalid token data structure' });
              return;
            }
            
            if (!tokenData.assetId) {
              invalidTokens.push({ index, reason: 'Missing asset ID' });
              return;
            }
            
            if (typeof tokenData.currentX !== 'number' || typeof tokenData.currentY !== 'number') {
              invalidTokens.push({ index, reason: 'Invalid current position coordinates' });
              return;
            }
            
            const tokenElement = document.querySelector(`[data-token-id="${tokenData.assetId}"]`);
            if (!tokenElement) {
              invalidTokens.push({ index, reason: 'Token element not found in DOM' });
              return;
            }
            
            // CORREZIONE: tokenData.currentX e currentY sono coordinate relative al map-grid, non assolute
            // Dobbiamo convertirle in coordinate mappa direttamente
            const transform = CoordinateSystem.getGridTransformMatrix();
            const currentMapCoords = {
              x: tokenData.currentX / transform.scale,
              y: tokenData.currentY / transform.scale
            };
            
            // Apply delta in map coordinate space
            // deltaX/deltaY sono già in coordinate relative al map-grid, quindi li convertiamo in spazio mappa
            const mapDeltaX = deltaX / transform.scale;
            const mapDeltaY = deltaY / transform.scale;
            
            // Calculate new map coordinates
            const newMapX = currentMapCoords.x + mapDeltaX;
            const newMapY = currentMapCoords.y + mapDeltaY;
            
            if (isNaN(newMapX) || isNaN(newMapY)) {
              invalidTokens.push({ index, reason: 'Invalid calculated map position' });
              return;
            }
            
            // Convert to grid coordinates
            const gridCoords = mapToGridCoordinates(newMapX, newMapY);
            
            // DEBUG: Informazioni dettagliate sulla conversione coordinate del token
            console.log('=== DEBUG CONVERSIONE COORDINATE TOKEN ===');
            console.log('Token ID:', tokenData.assetId);
            console.log('Posizione corrente (assoluta):', { x: tokenData.currentX, y: tokenData.currentY });
            console.log('Coordinate mappa correnti:', { x: currentMapCoords.x, y: currentMapCoords.y });
            
            // Verifica: calcola le coordinate griglia correnti del token
            const currentGridCoords = mapToGridCoordinates(currentMapCoords.x, currentMapCoords.y);
            console.log('Coordinate griglia correnti del token:', { x: currentGridCoords.x, y: currentGridCoords.y });
            
            console.log('Delta schermo:', { x: deltaX, y: deltaY });
            console.log('Delta mappa (scalato):', { x: mapDeltaX, y: mapDeltaY });
            console.log('Scala trasformazione:', transform.scale);
            console.log('Nuove coordinate mappa:', { x: newMapX, y: newMapY });
            console.log('Coordinate griglia finali:', { x: gridCoords.x, y: gridCoords.y });
            
            // Calcola il delta effettivo in coordinate griglia
            const gridDeltaX = gridCoords.x - currentGridCoords.x;
            const gridDeltaY = gridCoords.y - currentGridCoords.y;
            console.log('Delta griglia effettivo:', { x: gridDeltaX, y: gridDeltaY });
            
            const pixelCenterPreview = gridCellToPixelCenter(gridCoords.x, gridCoords.y);
            console.log('Centro pixel finale:', { x: pixelCenterPreview.x, y: pixelCenterPreview.y });
            console.log('==========================================');
            
            Logger.debug('Token coordinate conversion:', {
              tokenId: tokenData.assetId,
              currentPositionAbsolute: { x: tokenData.currentX, y: tokenData.currentY },
              currentMapCoords: { x: currentMapCoords.x, y: currentMapCoords.y },
              deltaScreen: { x: deltaX, y: deltaY },
              deltaMap: { x: mapDeltaX, y: mapDeltaY },
              transformScale: transform.scale,
              newMapCoords: { x: newMapX, y: newMapY },
              gridCoords: { x: gridCoords.x, y: gridCoords.y },
              pixelCenter: { x: pixelCenterPreview.x, y: pixelCenterPreview.y }
            });
            
            if (isNaN(gridCoords.x) || isNaN(gridCoords.y)) {
              invalidTokens.push({ index, reason: 'Invalid grid coordinates' });
              return;
            }
            
            const pixelCenter = gridCellToPixelCenter(gridCoords.x, gridCoords.y);
            
            if (isNaN(pixelCenter.x) || isNaN(pixelCenter.y)) {
              invalidTokens.push({ index, reason: 'Invalid pixel center calculation' });
              return;
            }
            
            validTokens.push({
              tokenData,
              tokenElement,
              newMapX,
              newMapY,
              gridCoords,
              pixelCenter
            });
            
          } catch (tokenError) {
            Logger.error(`Error processing token at index ${index}:`, tokenError);
            invalidTokens.push({ index, reason: `Processing error: ${tokenError.message}` });
          }
        });
        
        return { validTokens, invalidTokens };
      }
      
      function executeMultiTokenMove(validTokens) {
        let successfulMoves = 0;
        
        validTokens.forEach(({ tokenData, tokenElement, pixelCenter, gridCoords }) => {
          try {
            // Update token visual position
            tokenElement.style.left = pixelCenter.x + 'px';
            tokenElement.style.top = pixelCenter.y + 'px';
            
            // Add visual feedback during update
            tokenElement.style.opacity = '0.7';
            setTimeout(() => {
              if (tokenElement.style.opacity === '0.7') {
                tokenElement.style.opacity = '1';
              }
            }, 1000);
            
            // Queue server update (will be batched automatically)
            updateTokenPositionOnServer(tokenElement, pixelCenter.x, pixelCenter.y);
            
            successfulMoves++;
            
            Logger.debug('Token moved in multi-drop:', {
              tokenId: tokenData.assetId,
              from: { x: tokenData.currentX, y: tokenData.currentY },
              to: { x: pixelCenter.x, y: pixelCenter.y },
              grid: { x: gridCoords.x, y: gridCoords.y }
            });
            
          } catch (moveError) {
            Logger.error(`Error moving token ${tokenData.assetId}:`, moveError);
          }
        });
        
        return successfulMoves;
      }
      
      // Main multi-token drop handler
      function handleMultiTokenDrop(e, dragData) {
        try {
          // Step 1: Validate inputs
          validateMultiTokenDropInputs(e, dragData);
          
          // Step 2: Calculate movement delta
          const { deltaX, deltaY } = calculateDropDelta(e, dragData);
          
          // Step 3: Validate and process tokens
          const { validTokens, invalidTokens } = validateAndProcessTokens(dragData, deltaX, deltaY);
          
          // Step 4: Log validation results
          if (invalidTokens.length > 0) {
            Logger.warn(`${invalidTokens.length} tokens failed validation:`, invalidTokens);
            showNotification(`${invalidTokens.length} tokens could not be moved due to validation errors.`, 'warning');
          }
          
          if (validTokens.length === 0) {
            Logger.error('No valid tokens to move');
            showNotification('No tokens could be moved. Please try again.', 'error');
            return;
          }
          
          Logger.info(`Moving ${validTokens.length} valid tokens (${invalidTokens.length} invalid)`);
          
          // Step 5: Execute the move
          const successfulMoves = executeMultiTokenMove(validTokens);
          
          // Step 6: Show success notification
          if (successfulMoves > 0) {
            const message = successfulMoves === 1 
              ? 'Token moved successfully' 
              : `${successfulMoves} tokens moved successfully`;
            showNotification(message, 'success');
          }
          
          Logger.info(`Multi-token drop completed: ${successfulMoves} successful moves`);
          
        } catch (error) {
           Logger.error('Critical error in handleMultiTokenDrop:', error);
           showNotification('An error occurred while moving tokens. Please try again.', 'error');
         }
       }
     
     // ===== SELECTION BOX SYSTEM =====
     function startSelectionBox(e) {
       try {
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         selectionStartX = e.clientX - rect.left;
         selectionStartY = e.clientY - rect.top;
         
         isSelecting = true;
         
         // Create selection box element
         selectionBox = document.createElement('div');
         selectionBox.className = 'selection-box';
         selectionBox.style.position = 'absolute';
         selectionBox.style.border = '2px dashed #007bff';
         selectionBox.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
         selectionBox.style.pointerEvents = 'none';
         selectionBox.style.zIndex = '9999';
         selectionBox.style.left = selectionStartX + 'px';
         selectionBox.style.top = selectionStartY + 'px';
         selectionBox.style.width = '0px';
         selectionBox.style.height = '0px';
         
         viewport.appendChild(selectionBox);
         
         // Clear previous selection if not holding Shift
         if (!e.shiftKey) {
           clearTokenSelection();
         }
         
         Logger.debug('Started selection box at:', selectionStartX, selectionStartY);
         
       } catch (error) {
         Logger.error('Error in startSelectionBox:', error);
       }
     }
     
     function updateSelectionBox(e) {
       try {
         if (!isSelecting || !selectionBox) return;
         
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         const currentX = e.clientX - rect.left;
         const currentY = e.clientY - rect.top;
         
         const left = Math.min(selectionStartX, currentX);
         const top = Math.min(selectionStartY, currentY);
         const width = Math.abs(currentX - selectionStartX);
         const height = Math.abs(currentY - selectionStartY);
         
         selectionBox.style.left = left + 'px';
         selectionBox.style.top = top + 'px';
         selectionBox.style.width = width + 'px';
         selectionBox.style.height = height + 'px';
         
       } catch (error) {
         Logger.error('Error in updateSelectionBox:', error);
       }
     }
     
     function endSelectionBox(e) {
       try {
         if (!isSelecting || !selectionBox) return;
         
         const viewport = document.getElementById('map-viewport');
         if (!viewport) return;
         
         const rect = viewport.getBoundingClientRect();
         const currentX = e.clientX - rect.left;
         const currentY = e.clientY - rect.top;
         
         const left = Math.min(selectionStartX, currentX);
         const top = Math.min(selectionStartY, currentY);
         const right = Math.max(selectionStartX, currentX);
         const bottom = Math.max(selectionStartY, currentY);
         
         // Find tokens within selection box
         const tokens = document.querySelectorAll('[data-selectable="true"]');
         const tokensToSelect = [];
         
         Logger.debug('Selection box coordinates:', { left, top, right, bottom });
         Logger.debug('Found tokens to check:', tokens.length);
         
         // Get viewport rect for coordinate conversion
         const viewportRect = viewport.getBoundingClientRect();
         
         tokens.forEach(token => {
           try {
             // Get token position in screen coordinates
             const tokenRect = token.getBoundingClientRect();
             
             // Convert token screen coordinates to viewport-relative coordinates
             const tokenScreenLeft = tokenRect.left - viewportRect.left;
             const tokenScreenTop = tokenRect.top - viewportRect.top;
             const tokenScreenRight = tokenScreenLeft + tokenRect.width;
             const tokenScreenBottom = tokenScreenTop + tokenRect.height;
             
             // Check intersection with selection box (both in viewport coordinates)
             const intersects = tokenScreenLeft < right && tokenScreenRight > left && 
                               tokenScreenTop < bottom && tokenScreenBottom > top;
             
             Logger.debug('Token check:', {
               tokenId: token.dataset.tokenId,
               tokenScreenBounds: { 
                 left: tokenScreenLeft, 
                 top: tokenScreenTop, 
                 right: tokenScreenRight, 
                 bottom: tokenScreenBottom 
               },
               selectionBounds: { left, top, right, bottom },
               intersects
             });
             
             if (intersects) {
               tokensToSelect.push(token);
             }
           } catch (error) {
             Logger.warn('Error checking token intersection:', error, token);
           }
         });
         
         Logger.debug('Tokens to select:', tokensToSelect.length);
         
         // Select all tokens found in the selection box
         tokensToSelect.forEach((token, index) => {
           // For drag selection, treat as additive (like holding Shift)
           // Only clear selection for the first token if Shift is not held
           const shouldClearFirst = index === 0 && !e.shiftKey;
           if (shouldClearFirst) {
             selectToken(token, false); // This will clear previous selection
           } else {
             selectToken(token, true); // This will add to selection
           }
         });
         
         // Clean up
         viewport.removeChild(selectionBox);
         selectionBox = null;
         isSelecting = false;
         
         Logger.debug('Ended selection box, selected tokens:', selectedTokens.size);
         
       } catch (error) {
         Logger.error('Error in endSelectionBox:', error);
         // Clean up on error
         if (selectionBox && selectionBox.parentNode) {
           selectionBox.parentNode.removeChild(selectionBox);
         }
         selectionBox = null;
         isSelecting = false;
       }
     }
    
    function sendChatMessage() {
      try {
        const input = document.getElementById('chat-input');
        
        if (!input) {
          Logger.warn('Chat input element not found');
          return;
        }
        
        const message = input.value.trim();
        if (!message) {
          Logger.debug('Empty chat message, ignoring');
          return;
        }
        
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) {
          Logger.warn('Chat messages container not found');
          return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = 'margin-bottom: 10px; padding: 5px; background: #4a4a2a; border-radius: 3px;';
        messageDiv.innerHTML = `<strong>You:</strong> ${escapeHtml(message)}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        input.value = '';
        Logger.debug('Chat message sent:', message);
      } catch (error) {
        Logger.error('Error sending chat message:', error);
      }
    }
    
    function addDebugMessageToChat(message) {
      try {
        if (!message || typeof message !== 'string') {
          Logger.warn('Invalid debug message:', message);
          return;
        }
        
        const chatMessages = document.getElementById('chat-messages');
        if (!chatMessages) {
          Logger.warn('Chat messages container not found for debug message');
          return;
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.style.cssText = 'margin-bottom: 10px; padding: 5px; background: #2a4a4a; border-radius: 3px; border-left: 3px solid #00ff00;';
        messageDiv.innerHTML = `<strong style="color: #00ff00;">[DEBUG]:</strong> ${escapeHtml(message)}`;
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        
        Logger.debug('Debug message added to chat:', message);
      } catch (error) {
        Logger.error('Error adding debug message to chat:', error);
      }
    }
    
    // Campaign settings management
    let campaignSettings = {
      gridSize: 50,
      gridColor: '#ffffff',
      gridOpacity: 10
    };
    
    async function loadCampaignSettings() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || typeof campaignId !== 'string') {
          Logger.error('Invalid campaign ID for loading settings:', campaignId);
          return;
        }
        
        // TODO: Implement /api/campaigns/${campaignId}/settings endpoint in backend
        // const response = await fetch(`/api/campaigns/${campaignId}/settings`);
        // 
        // if (!response.ok) {
        //   throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        // }
        // 
        // const data = await response.json();
        // 
        // if (data && data.success && data.settings) {
        //   // Validate settings data
        //   const validatedSettings = {
        //     gridSize: typeof data.settings.gridSize === 'number' ? data.settings.gridSize : campaignSettings.gridSize,
        //     gridColor: typeof data.settings.gridColor === 'string' ? data.settings.gridColor : campaignSettings.gridColor,
        //     gridOpacity: typeof data.settings.gridOpacity === 'number' ? data.settings.gridOpacity : campaignSettings.gridOpacity
        //   };
        //   
        //   campaignSettings = { ...campaignSettings, ...validatedSettings };
        //   applySettings();
        //   Logger.info('Campaign settings loaded successfully');
        // } else {
        //   Logger.warn('No valid settings data received:', data);
        // }
        
        // For now, use default settings
        applySettings();
        Logger.info('Using default campaign settings (endpoint not implemented)');
      } catch (error) {
        Logger.error('Failed to load campaign settings:', error);
      }
    }
    
    function applySettings() {
      try {
        // Validate settings object
        if (!campaignSettings || typeof campaignSettings !== 'object') {
          Logger.error('Invalid campaign settings object:', campaignSettings);
          return;
        }
        
        // Update UI controls with error handling
        const gridSizeElement = document.getElementById('grid-size');
        const gridColorElement = document.getElementById('grid-color');
        const gridOpacityElement = document.getElementById('grid-opacity');
        
        if (gridSizeElement) {
          gridSizeElement.value = campaignSettings.gridSize || 50;
        }
        if (gridColorElement) {
          gridColorElement.value = campaignSettings.gridColor || '#ffffff';
        }
        if (gridOpacityElement) {
          gridOpacityElement.value = campaignSettings.gridOpacity || 10;
        }
        
        // Apply to map grid
        const mapGrid = document.getElementById('map-grid');
        if (!mapGrid) {
          Logger.warn('Map grid element not found');
          return;
        }
        
        const gridSize = campaignSettings.gridSize || 50;
        mapGrid.style.backgroundSize = `${gridSize}px ${gridSize}px`;
        
        const opacity = (campaignSettings.gridOpacity || 10) / 100;
        const rgb = hexToRgb(campaignSettings.gridColor || '#ffffff');
        
        if (rgb) {
          mapGrid.style.backgroundImage = `
            linear-gradient(rgba(${rgb.r},${rgb.g},${rgb.b},${opacity}) 1px, transparent 1px),
            linear-gradient(90deg, rgba(${rgb.r},${rgb.g},${rgb.b},${opacity}) 1px, transparent 1px)
          `;
        } else {
          Logger.error('Failed to convert grid color to RGB:', campaignSettings.gridColor);
        }
        
        Logger.debug('Settings applied successfully');
      } catch (error) {
        Logger.error('Error applying settings:', error);
      }
    }
    
    async function saveSettings() {
      try {
        // Validate campaign ID
        const campaignId = MapState.getCampaignId();
        if (!campaignId || typeof campaignId !== 'string') {
          Logger.error('Invalid campaign ID for saving settings:', campaignId);
          alert('Invalid campaign ID');
          return;
        }
        
        // Get and validate UI elements
        const gridSizeElement = document.getElementById('grid-size');
        const gridColorElement = document.getElementById('grid-color');
        const gridOpacityElement = document.getElementById('grid-opacity');
        
        if (!gridSizeElement || !gridColorElement || !gridOpacityElement) {
          Logger.error('Settings UI elements not found');
          alert('Settings form not available');
          return;
        }
        
        // Parse and validate values
        const gridSize = parseInt(gridSizeElement.value);
        const gridColor = gridColorElement.value;
        const gridOpacity = parseInt(gridOpacityElement.value);
        
        if (isNaN(gridSize) || gridSize < 10 || gridSize > 200) {
          alert('Grid size must be between 10 and 200 pixels');
          return;
        }
        
        if (!gridColor || !/^#[0-9A-F]{6}$/i.test(gridColor)) {
          alert('Please select a valid grid color');
          return;
        }
        
        if (isNaN(gridOpacity) || gridOpacity < 0 || gridOpacity > 100) {
          alert('Grid opacity must be between 0 and 100');
          return;
        }
        
        const settings = {
          gridSize,
          gridColor,
          gridOpacity
        };
        
        // TODO: Implement /api/campaigns/${campaignId}/settings endpoint in backend
        // const response = await fetch(`/api/campaigns/${campaignId}/settings`, {
        //   method: 'PUT',
        //   headers: {
        //     'Content-Type': 'application/json'
        //   },
        //   body: JSON.stringify({ settings })
        // });
        // 
        // if (!response.ok) {
        //   throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        // }
        // 
        // const data = await response.json();
        // 
        // if (data && data.success) {
        //   campaignSettings = settings;
        //   applySettings();
        //   Logger.info('Settings saved successfully');
        //   alert('Settings saved successfully!');
        // } else {
        //   const errorMsg = data?.error || 'Unknown error occurred';
        //   Logger.error('Failed to save settings:', errorMsg);
        //   alert('Failed to save settings: ' + errorMsg);
        // }
        
        // For now, apply settings locally only
        campaignSettings = settings;
        applySettings();
        Logger.info('Settings applied locally (endpoint not implemented)');
        alert('Settings applied locally (backend endpoint not implemented)');
      } catch (error) {
        Logger.error('Exception during settings save:', error);
        alert('Failed to save settings: ' + (error.message || 'Network error'));
      }
    }
    
    function hexToRgb(hex) {
      try {
        // Validate input
        if (!hex || typeof hex !== 'string') {
          Logger.warn('Invalid hex color input:', hex);
          return null;
        }
        
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        
        if (!result) {
          Logger.warn('Invalid hex color format:', hex);
          return null;
        }
        
        return {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        };
      } catch (error) {
        Logger.error('Error converting hex to RGB:', error, hex);
        return null;
      }
    }
    
    // Help panel toggle
    function toggleHelp() {
      try {
        const helpPanel = document.getElementById('help-panel');
        
        if (!helpPanel) {
          Logger.warn('Help panel element not found');
          return;
        }
        
        if (helpPanel.style.display === 'none' || helpPanel.style.display === '') {
          helpPanel.style.display = 'block';
          Logger.debug('Help panel opened');
        } else {
          helpPanel.style.display = 'none';
          Logger.debug('Help panel closed');
        }
      } catch (error) {
        Logger.error('Error toggling help panel:', error);
      }
    }
    
    // Chat input enter key support
    document.getElementById('chat-input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendChatMessage();
      }
    });
    
    // Global userId variable
    let userId;
    
    // Layer Management System
    let currentLayer = 'tokens';
    let layerVisibility = {
      'map': true,
      'walls': true,
      'tokens': true,
      'gm': true,
      'audio': true,
      'props': true
    };

    function initializeLayerSystem() {
      try {
        const layerButtons = document.querySelectorAll('.layer-btn');
        
        if (!layerButtons || layerButtons.length === 0) {
          Logger.warn('No layer buttons found for initialization');
          return;
        }
        
        layerButtons.forEach(button => {
          if (!button.dataset.target) {
            Logger.warn('Layer button missing target dataset:', button);
            return;
          }
          
          button.addEventListener('click', function() {
            try {
              const targetLayer = this.dataset.target;
              const layerName = targetLayer.replace('-layer', '');
              
              // Set as active layer (exclusive selection)
              setActiveLayer(layerName);
            } catch (error) {
              Logger.error('Error handling layer button click:', error);
            }
          });
          
          // Right click to toggle visibility
          button.addEventListener('contextmenu', function(e) {
            try {
              e.preventDefault();
              const targetLayer = this.dataset.target;
              const layerName = targetLayer.replace('-layer', '');
              
              if (this.classList.contains('hidden')) {
                showLayer(layerName);
                this.classList.remove('hidden');
                Logger.debug('Layer shown:', layerName);
              } else {
                hideLayer(layerName);
                this.classList.add('hidden');
                Logger.debug('Layer hidden:', layerName);
              }
            } catch (error) {
              Logger.error('Error handling layer context menu:', error);
            }
          });
        });
        
        Logger.info('Layer system initialized with', layerButtons.length, 'buttons');
      } catch (error) {
        Logger.error('Error initializing layer system:', error);
      }
      
      // Keyboard navigation for layers
      document.addEventListener('keydown', function(e) {
        try {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return; // Don't interfere with text input
          }
          
          switch(e.key) {
            case '1':
              setActiveLayer('map');
              break;
            case '2':
              setActiveLayer('walls');
              break;
            case '3':
              setActiveLayer('tokens');
              break;
            case '4':
              setActiveLayer('gm');
              break;
            case '5':
              setActiveLayer('audio');
              break;
            case '6':
              setActiveLayer('props');
              break;
          }
        } catch (error) {
          Logger.error('Error handling layer keyboard navigation:', error);
        }
      });
      
      // Set tokens layer as default active
      try {
        setActiveLayer('tokens');
      } catch (error) {
        Logger.error('Error setting default active layer:', error);
      }
      
      // Initialize drag and drop for layers
      try {
        initializeLayerDropZones();
      } catch (error) {
        Logger.error('Error initializing layer drop zones:', error);
      }
    }
    
    function initializeLayerDropZones() {
      try {
        const mapViewport = document.getElementById('map-viewport');
        
        if (!mapViewport) {
          Logger.error('Map viewport element not found for drop zone initialization');
          return;
        }
        
        mapViewport.addEventListener('dragover', function(e) {
          try {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            mapViewport.classList.add('drag-over');
          } catch (error) {
            Logger.error('Error handling dragover event:', error);
          }
        });
        
        mapViewport.addEventListener('dragleave', function(e) {
          try {
            // Only remove drag-over if we're leaving the viewport entirely
            if (!mapViewport.contains(e.relatedTarget)) {
              mapViewport.classList.remove('drag-over');
            }
          } catch (error) {
            Logger.error('Error handling dragleave event:', error);
          }
        });
      
        // ===== MAIN DROP SYSTEM =====
        
        function parseDropData(dataText) {
          if (!dataText) {
            throw new Error('No data found in drop event');
          }
          
          try {
            return JSON.parse(dataText);
          } catch (parseError) {
            // Only ignore if it looks like a URL or other non-JSON content
            if (dataText.startsWith('http') || dataText.startsWith('www.') || !dataText.includes('{')) {
              Logger.debug('Drop data appears to be URL or non-JSON content, ignoring:', dataText.substring(0, 50) + '...');
              return null;
            }
            // If it looks like it should be JSON but failed to parse, log the error
            Logger.error('Failed to parse drop data as JSON:', parseError, 'Data:', dataText.substring(0, 100));
            throw parseError;
          }
        }
        
        function validateDropEnvironment() {
          const viewport = document.getElementById('map-viewport');
          if (!viewport) {
            throw new Error('Map viewport not found during drop');
          }
          
          // Validate coordinate functions
          if (typeof screenToMapCoordinates !== 'function' || 
              typeof mapToGridCoordinates !== 'function' || 
              typeof gridCellToPixelCenter !== 'function') {
            throw new Error('Required coordinate conversion functions not available');
          }
          
          return viewport;
        }
        
        function calculateDropCoordinates(e, viewport) {
          const rect = viewport.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Use Roll20-inspired coordinate system
          const mapCoords = screenToMapCoordinates(mouseX, mouseY);
          const gridCoords = mapToGridCoordinates(mapCoords.x, mapCoords.y);
          const pixelCenter = gridCellToPixelCenter(gridCoords.x, gridCoords.y);
          
          const coordinates = {
            screen: { x: mouseX, y: mouseY },
            map: mapCoords,
            grid: gridCoords,
            pixel: pixelCenter
          };
          
          Logger.debug('=== DROP COORDINATES DEBUG ===');
          Logger.debug(`Target cell: Grid (${coordinates.grid.x}, ${coordinates.grid.y})`);
          Logger.debug(`Screen coordinates: (${coordinates.screen.x}, ${coordinates.screen.y})`);
          Logger.debug(`Map coordinates: (${coordinates.map.x.toFixed(2)}, ${coordinates.map.y.toFixed(2)})`);
          Logger.debug(`Calculated pixels: (${coordinates.pixel.x}, ${coordinates.pixel.y})`);
          Logger.debug('===============================');
          
          return coordinates;
        }
        
        function determineTargetLayer(assetType) {
          switch(assetType.toLowerCase()) {
            case 'token':
              // Tokens can only be dropped on 'tokens' or 'gm' layers
              if (currentLayer === 'tokens' || currentLayer === 'gm') {
                return currentLayer;
              } else {
                // Show warning and prevent drop on invalid layers
                Logger.warn(`Tokens can only be dropped on 'Tokens' or 'GM' layers. Current layer: ${currentLayer}`);
                alert('I token possono essere posizionati solo sui layer "Tokens" o "GM". Seleziona uno di questi layer prima di trascinare il token.');
                return null;
              }
            case 'background':
              return 'map';
            case 'audio':
              // Audio can only be dropped on 'audio' layer
              if (currentLayer === 'audio') {
                return 'audio';
              } else {
                // Show warning and prevent drop on invalid layers
                Logger.warn(`Audio can only be dropped on 'Audio' layer. Current layer: ${currentLayer}`);
                alert('Gli audio possono essere posizionati solo sul layer "Audio". Seleziona il layer Audio prima di trascinare l\'audio.');
                return null;
              }
            case 'props':
              return 'props';
            default:
              return currentLayer || 'tokens'; // Use current active layer as fallback
          }
        }
        
        function handleSingleAssetDrop(e, data) {
          // Validate asset data
          if (!data || !data.assetId || !data.assetType) {
            Logger.error('Invalid asset data in drop event:', data);
            return;
          }
          
          // Validate environment
          const viewport = validateDropEnvironment();
          
          // Calculate coordinates
          const coordinates = calculateDropCoordinates(e, viewport);
          
          // Determine target layer
          const targetLayer = determineTargetLayer(data.assetType);
          if (!targetLayer) {
            return; // Layer validation failed, user was already notified
          }
          
          // Create asset on the appropriate layer
          createAssetOnLayer(
            data, 
            coordinates.grid.x, 
            coordinates.grid.y, 
            coordinates.pixel.x, 
            coordinates.pixel.y, 
            targetLayer
          );
        }
        
        // Main drop event handler
        mapViewport.addEventListener('drop', function(e) {
          try {
            e.preventDefault();
            mapViewport.classList.remove('drag-over');
            
            // Step 1: Parse drop data
            const dataText = e.dataTransfer.getData('text/plain');
            const data = parseDropData(dataText);
            
            if (!data) {
              return; // Parsing failed or data was ignored
            }
            
            // Step 2: Route to appropriate handler
            if (data.type === 'multitoken' && data.tokens) {
              // Handle multi-token movement
              handleMultiTokenDrop(e, data);
            } else {
              // Handle single asset drop (new assets from library)
              handleSingleAssetDrop(e, data);
            }
            
          } catch (error) {
            Logger.error('Error handling drop event:', error);
            showNotification('An error occurred while dropping the item. Please try again.', 'error');
          }
        });
        
        Logger.info('Layer drop zones initialized successfully');
      } catch (error) {
        Logger.error('Error initializing layer drop zones:', error);
      }
    }
    
    function createAssetOnLayer(assetData, gridX, gridY, pixelX, pixelY, targetLayer) {
      try {
        // Validate input parameters
        if (!assetData || !assetData.assetId) {
          Logger.error('Invalid asset data for layer creation:', assetData);
          return;
        }
        
        if (typeof gridX !== 'number' || typeof gridY !== 'number') {
          Logger.error('Invalid grid coordinates:', { gridX, gridY });
          return;
        }
        
        if (!targetLayer || typeof targetLayer !== 'string') {
          Logger.error('Invalid target layer:', targetLayer);
          return;
        }
        
        const mapId = getCurrentMapId();
        if (!mapId) {
          Logger.error('No current map ID available for asset creation');
          return;
        }
        
        // Prepare data for API call with grid coordinates
        const payload = {
          map_id: mapId,
          asset_id: parseInt(assetData.assetId), // Convert string ID to number
          grid_x: gridX,
          grid_y: gridY,
          grid_z: 0,
          scale_x: 1.0,
          scale_y: 1.0,
          rotation: 0.0,
          visible: true,
          locked: false,
          properties: {}
        };
      
        // Add name for tokens (both tokens and gm layers)
        if (targetLayer === 'tokens' || targetLayer === 'gm') {
          payload.name = assetData.assetName || 'Unnamed Token';
        }
        
        // Add specific properties based on asset type
        if (targetLayer === 'map') {
          // Background-specific properties
          payload.opacity = 1.0;
          payload.blend_mode = 'normal';
          payload.grid_width = 1;
          payload.grid_height = 1;
        } else if (targetLayer === 'audio') {
          // Audio-specific properties
          payload.volume = 1.0;
          payload.loop = false;
          payload.radius_grid = 2; // Default audio radius in grid units
        } else if (targetLayer === 'props') {
          // Props-specific properties
          payload.interactive = true;
          payload.grid_width = 1;
          payload.grid_height = 1;
        }
        
        // Determine API endpoint based on target layer
        let apiEndpoint;
        switch(targetLayer) {
          case 'tokens':
          case 'gm':
            apiEndpoint = '/api/map-tokens';
            break;
          case 'map':
            apiEndpoint = '/api/map-backgrounds';
            break;
          case 'audio':
            apiEndpoint = '/api/map-audio';
            break;
          case 'props':
            apiEndpoint = '/api/map-props';
            break;
          default:
            Logger.error('Unknown target layer:', targetLayer);
            return;
        }
      
        // Make API call to create asset on layer
        fetch(apiEndpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          return response.json();
        })
        .then(data => {
          if (data && data.success) {
            Logger.info(`Asset placed on ${targetLayer} layer:`, data);
            // Optionally refresh the layer or add visual feedback
            if (typeof createVisualAssetElement === 'function') {
              createVisualAssetElement(assetData, gridX, gridY, targetLayer);
            } else {
              Logger.warn('createVisualAssetElement function not available');
            }
            // Update active tokens list if a token was added
            if (targetLayer === 'tokens' || targetLayer === 'gm') {
              loadActiveTokensAndSheets(); // Debounced call after token placement
            }
          } else {
            const errorMsg = data?.error || 'Unknown error occurred';
            Logger.error(`Failed to place asset on ${targetLayer} layer:`, errorMsg);
          }
        })
        .catch(error => {
          Logger.error(`Exception during asset placement on ${targetLayer} layer:`, error);
        });
        
      } catch (error) {
        Logger.error('Error in createAssetOnLayer:', error);
      }
    }
    
    async function createVisualAssetElement(assetData, gridX, gridY, targetLayer) {
      try {
        // Validate input parameters
        if (!assetData || !assetData.assetId) {
          Logger.error('Invalid asset data for visual element creation:', assetData);
          return;
        }
        
        if (typeof gridX !== 'number' || typeof gridY !== 'number') {
          Logger.error('Invalid grid coordinates for visual element:', { gridX, gridY });
          return;
        }
        
        if (!targetLayer || typeof targetLayer !== 'string') {
          Logger.error('Invalid target layer for visual element:', targetLayer);
          return;
        }
        
        const layerElement = document.getElementById(`${targetLayer}-layer`);
        Logger.debug('Target layer element:', layerElement);
        
        if (!layerElement) {
          Logger.error('Layer element not found for:', targetLayer);
          return;
        }
      
        // Find the asset in our assets array to get the file_url
        const asset = assets ? assets.find(a => a.id == assetData.assetId) : null;
        Logger.debug('Creating visual asset element:', {
          assetData,
          foundAsset: asset,
          totalAssets: assets ? assets.length : 0,
          targetLayer,
          gridPosition: { gridX, gridY }
        });
      
        const assetElement = document.createElement('div');
        assetElement.className = 'map-asset';
        assetElement.style.position = 'absolute';
        
        // Validate coordinate functions
        if (typeof gridCellToPixelCenter !== 'function') {
          Logger.error('gridCellToPixelCenter function not available');
          return;
        }
        
        // Use new coordinate system functions for consistent positioning
        const pixelCenter = gridCellToPixelCenter(gridX, gridY);
        const pixelX = pixelCenter.x;
        const pixelY = pixelCenter.y;
        
        // Position relative to the map grid coordinate system
        assetElement.style.left = pixelX + 'px';
        assetElement.style.top = pixelY + 'px';
        assetElement.style.position = 'absolute';
        
        // Center the token image within its position
        assetElement.style.transform = 'translate(-50%, -50%)';
        assetElement.style.cursor = 'move';
        assetElement.title = `${assetData.assetType}: ${assetData.assetName}`;
        // Ensure the element is positioned relative to the grid coordinate system
        assetElement.style.transformOrigin = 'top left';
        
        // Log the visual positioning for debugging
        Logger.debug('=== VISUAL ASSET CREATION ===');
        Logger.debug(`Asset positioned at: Grid (${gridX}, ${gridY}) -> Pixel (${pixelX}, ${pixelY})`);
        Logger.debug('==============================');

      
      // Create image element if asset has file_url and is an image category (excluding audio)
      if (asset && asset.file_url && ['tokens', 'backgrounds', 'props'].includes(asset.category) && targetLayer !== 'audio') {
        const img = document.createElement('img');
        // Ensure the URL is correctly formatted
        let imageUrl = asset.file_url;
        if (!imageUrl.startsWith('http')) {
          // Remove leading slash if present to avoid double slashes
          const cleanPath = imageUrl.startsWith('/') ? imageUrl.substring(1) : imageUrl;
          imageUrl = `/${cleanPath}`;
        }
        img.src = imageUrl;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        img.style.borderRadius = 'inherit';
        img.onload = function() {
          Logger.debug('Image loaded successfully:', imageUrl);
        };
        img.onerror = function() {
          Logger.error('Failed to load image:', imageUrl);
          // Fallback to text if image fails to load
          assetElement.innerHTML = '';
          assetElement.textContent = assetData.assetName;
          assetElement.style.display = 'flex';
          assetElement.style.alignItems = 'center';
          assetElement.style.justifyContent = 'center';
          assetElement.style.fontSize = '12px';
          assetElement.style.color = '#007bff';
        };
        assetElement.appendChild(img);
      } else {
        // Fallback to text for non-image assets or when asset not found
        assetElement.style.display = 'flex';
        assetElement.style.alignItems = 'center';
        assetElement.style.justifyContent = 'center';
        assetElement.style.fontSize = '12px';
        assetElement.style.color = '#007bff';
        assetElement.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
        
        switch(assetData.assetType.toLowerCase()) {
          case 'token':
            assetElement.textContent = '👤';
            break;
          case 'background':
            assetElement.textContent = '🗺️';
            break;
          case 'audio':
            assetElement.textContent = '🔊';
            break;
          case 'props':
            assetElement.textContent = '🎭';
            break;
          default:
            assetElement.textContent = assetData.assetName;
        }
      }
      
      // Set size and styling based on asset type
      switch(assetData.assetType.toLowerCase()) {
        case 'token':
          assetElement.style.width = '50px';
          assetElement.style.height = '50px';
          assetElement.style.borderRadius = '50%';
          assetElement.style.border = '2px solid #28a745';
          break;
        case 'background':
          assetElement.style.width = '100px';
          assetElement.style.height = '100px';
          assetElement.style.borderRadius = '4px';
          assetElement.style.border = '2px solid #6f42c1';
          break;
        case 'audio':
          assetElement.style.width = '40px';
          assetElement.style.height = '40px';
          assetElement.style.borderRadius = '50%';
          assetElement.style.border = '2px solid #fd7e14';
          break;
        case 'props':
          assetElement.style.width = '60px';
          assetElement.style.height = '60px';
          assetElement.style.borderRadius = '8px';
          assetElement.style.border = '2px solid #20c997';
          break;
        default:
          assetElement.style.width = '50px';
          assetElement.style.height = '50px';
          assetElement.style.borderRadius = '4px';
          assetElement.style.border = '2px solid #007bff';
      }
      
      // Add context menu for tokens to enable editing
      if (assetData.assetType.toLowerCase() === 'token') {
        assetElement.addEventListener('contextmenu', function(e) {
          e.preventDefault();
          editTokenName(assetData, assetElement);
        });
        
        // Add click handler for token selection
        assetElement.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          selectToken(assetElement, e.shiftKey);
        });
        
        // Add modern drag and drop support for existing tokens
        let isDragging = false;
        let dragStartPos = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };
        let draggedTokens = new Map();
        
        // Mouse down - start drag preparation
        assetElement.addEventListener('mousedown', function(e) {
          try {
            // Only handle left mouse button
            if (e.button !== 0) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            // If this token is not selected, select it and clear others
            if (!selectedTokens.has(assetData.assetId)) {
              clearTokenSelection();
              selectToken(assetElement, false);
            }
            
            // Prepare for potential drag
            const rect = assetElement.getBoundingClientRect();
            const mapGrid = document.getElementById('map-grid');
            const mapGridRect = mapGrid.getBoundingClientRect();
            
            dragStartPos = {
              x: e.clientX,
              y: e.clientY
            };
            
            dragOffset = {
              x: e.clientX - rect.left,
              y: e.clientY - rect.top
            };
            
            // Store initial positions of all selected tokens
            draggedTokens.clear();
            selectedTokens.forEach(tokenId => {
              const tokenEl = document.querySelector(`[data-token-id="${tokenId}"]`);
              if (tokenEl) {
                const tokenRect = tokenEl.getBoundingClientRect();
                draggedTokens.set(tokenId, {
                  element: tokenEl,
                  startX: tokenRect.left - mapGridRect.left,
                  startY: tokenRect.top - mapGridRect.top,
                  currentX: tokenRect.left - mapGridRect.left,
                  currentY: tokenRect.top - mapGridRect.top
                });
              }
            });
            
            // Add global mouse event listeners
            document.addEventListener('mousemove', handleTokenMouseMove);
            document.addEventListener('mouseup', handleTokenMouseUp);
            
            Logger.debug('Token drag preparation completed for', draggedTokens.size, 'tokens');
            
          } catch (error) {
            Logger.error('Error in token mousedown:', error);
          }
        });
        
        function handleTokenMouseMove(e) {
          try {
            if (draggedTokens.size === 0) return;
            
            // Calculate movement threshold to start dragging
            const deltaX = e.clientX - dragStartPos.x;
            const deltaY = e.clientY - dragStartPos.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Start dragging if moved more than 5 pixels
            if (!isDragging && distance > 5) {
              isDragging = true;
              
              // Add visual feedback for all selected tokens
              draggedTokens.forEach((tokenData) => {
                tokenData.element.style.opacity = '0.7';
                tokenData.element.style.zIndex = '9999';
                tokenData.element.style.transform = 'scale(1.1)';
                tokenData.element.style.boxShadow = '0 4px 12px rgba(0, 123, 255, 0.5)';
              });
              
              Logger.debug('Token dragging started');
            }
            
            if (isDragging) {
              // Update positions of all dragged tokens
              draggedTokens.forEach((tokenData) => {
                const newX = tokenData.startX + deltaX;
                const newY = tokenData.startY + deltaY;
                
                tokenData.element.style.left = newX + 'px';
                tokenData.element.style.top = newY + 'px';
                tokenData.currentX = newX;
                tokenData.currentY = newY;
              });
              
              // Update cursor
              document.body.style.cursor = 'grabbing';
            }
            
          } catch (error) {
            Logger.error('Error in token mouse move:', error);
          }
        }
        
        function handleTokenMouseUp(e) {
          try {
            // Remove global event listeners
            document.removeEventListener('mousemove', handleTokenMouseMove);
            document.removeEventListener('mouseup', handleTokenMouseUp);
            
            if (isDragging) {
              // Reset visual feedback
              draggedTokens.forEach((tokenData) => {
                tokenData.element.style.opacity = '';
                tokenData.element.style.zIndex = '';
                tokenData.element.style.transform = '';
                tokenData.element.style.boxShadow = '';
              });
              
              // Reset cursor
              document.body.style.cursor = '';
              
              // Save positions using the existing release function
              const tokensToUpdate = [];
              draggedTokens.forEach((tokenData, tokenId) => {
                tokensToUpdate.push({
                  assetId: tokenId,
                  assetType: 'token',
                  assetName: tokenData.element.title || 'Token',
                  currentX: tokenData.currentX,
                  currentY: tokenData.currentY
                });
              });
              
              // Use the existing multi-token drop handler to save positions
              if (tokensToUpdate.length > 0) {
                const mockDropEvent = {
                  preventDefault: () => {},
                  clientX: e.clientX,
                  clientY: e.clientY
                };
                
                const dragData = {
                  type: 'multitoken',
                  tokens: tokensToUpdate,
                  dragStartX: dragStartPos.x,
                  dragStartY: dragStartPos.y
                };
                
                // Call the existing drop handler to save positions
                handleMultiTokenDrop(mockDropEvent, dragData);
              }
              
              Logger.debug('Token drag completed, positions saved for', tokensToUpdate.length, 'tokens');
            }
            
            // Reset drag state
            isDragging = false;
            draggedTokens.clear();
            
          } catch (error) {
            Logger.error('Error in token mouse up:', error);
            // Ensure cleanup even on error
            isDragging = false;
            draggedTokens.clear();
            document.body.style.cursor = '';
          }
        }
        
        // Add data attributes for selection management
        assetElement.dataset.tokenId = assetData.tokenId || assetData.assetId;
        assetElement.dataset.selectable = 'true';
      }
      
      // Add audio playback functionality for audio assets
       if (assetData.assetType.toLowerCase() === 'audio' && asset && asset.file_url) {
         // Store audio instance on the element to track playback state
         let audioInstance = null;
         
         assetElement.addEventListener('click', function(e) {
           e.preventDefault();
           e.stopPropagation();
           
           // Check if audio is already playing
           if (audioInstance && !audioInstance.paused) {
             // Stop current audio
             audioInstance.pause();
             audioInstance.currentTime = 0;
             audioInstance = null;
             
             // Reset visual feedback
             assetElement.style.border = '2px solid #fd7e14';
             assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
             Logger.info('Audio stopped:', assetData.assetName);
             return;
           }
           
           // Create new audio element and play
           audioInstance = new Audio();
           let audioUrl = asset.file_url;
           if (!audioUrl.startsWith('http')) {
             const cleanPath = audioUrl.startsWith('/') ? audioUrl.substring(1) : audioUrl;
             audioUrl = `/${cleanPath}`;
           }
           
           audioInstance.src = audioUrl;
           
           // Add event listener for when audio ends
           audioInstance.addEventListener('ended', function() {
             assetElement.style.border = '2px solid #fd7e14';
             assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
             audioInstance = null;
           });
           
           audioInstance.play().then(() => {
             Logger.info('Audio playing:', assetData.assetName);
             // Visual feedback - change color while playing
             assetElement.style.border = '3px solid #28a745';
             assetElement.title = `Audio: ${assetData.assetName} (In riproduzione - clicca per fermare)`;
           }).catch(error => {
             Logger.error('Failed to play audio:', error);
             alert('Impossibile riprodurre l\'audio: ' + assetData.assetName);
             audioInstance = null;
           });
         });
         
         // Add tooltip with audio info
         assetElement.title = `Audio: ${assetData.assetName} (Clicca per riprodurre)`;
       }

        layerElement.appendChild(assetElement);
        Logger.debug('Visual asset element added to layer:', {
          elementAdded: assetElement,
          layerChildren: layerElement.children.length,
          layerName: targetLayer
        });
        
      } catch (error) {
        Logger.error('Error in createVisualAssetElement:', error);
      }
    }
    
    function getCurrentMapId() {
      try {
        // Return the currently loaded map ID or fallback to URL parameter
        if (currentMapId) {
          return currentMapId;
        }
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('map_id') || urlParams.get('id') || '1'; // Check map_id first, then id, then default to 1
      } catch (error) {
        Logger.error('Error getting current map ID:', error);
        return '1'; // Safe fallback
      }
    }
    
    function setActiveLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for setActiveLayer:', layerName);
          return;
        }
        
        // Remove active class from all layers
        document.querySelectorAll('.map-layer').forEach(layer => {
          layer.classList.remove('active');
        });
        
        // Remove active class from all layer buttons
        document.querySelectorAll('.layer-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // Set new active layer
        const targetLayer = document.getElementById(layerName + '-layer');
        if (targetLayer) {
          targetLayer.classList.add('active');
          currentLayer = layerName;
          
          // Set corresponding button as active
          const targetButton = document.querySelector(`[data-target="${layerName}-layer"]`);
          if (targetButton) {
            targetButton.classList.add('active');
          }
          Logger.debug('Active layer set to:', layerName);
        } else {
          Logger.error('Target layer not found:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in setActiveLayer:', error);
      }
    }
    
    function showLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for showLayer:', layerName);
          return;
        }
        
        const layer = document.getElementById(layerName + '-layer');
        if (layer) {
          layer.classList.remove('layer-hidden');
          layerVisibility[layerName] = true;
          Logger.debug('Layer shown:', layerName);
        } else {
          Logger.error('Layer not found for showing:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in showLayer:', error);
      }
    }
    
    function hideLayer(layerName) {
      try {
        if (!layerName || typeof layerName !== 'string') {
          Logger.error('Invalid layer name for hideLayer:', layerName);
          return;
        }
        
        const layer = document.getElementById(layerName + '-layer');
        if (layer) {
          layer.classList.add('layer-hidden');
          layerVisibility[layerName] = false;
          Logger.debug('Layer hidden:', layerName);
        } else {
          Logger.error('Layer not found for hiding:', layerName + '-layer');
        }
      } catch (error) {
        Logger.error('Error in hideLayer:', error);
      }
    }
    
    function getCurrentLayer() {
      return currentLayer;
    }
    
    function isLayerVisible(layerName) {
      return layerVisibility[layerName];
    }
    
    // Initialize function
    async function initialize() {
      try {
        Logger.info('Starting map initialization...');
        
        // Check login state
        const user = localStorage.getItem('pfvtt_user') || sessionStorage.getItem('pfvtt_user');
        if (!user) {
          Logger.warn('No user found, redirecting to login');
          window.location.href = '/login';
          return;
        }
        
        Logger.debug('User found:', user);
        
        // Get user ID
        try {
          const userIdResponse = await fetch(`/api/user_id?username=${encodeURIComponent(user)}`);
          
          if (!userIdResponse.ok) {
            throw new Error(`HTTP ${userIdResponse.status}: ${userIdResponse.statusText}`);
          }
          
          const userIdData = await userIdResponse.json();
          if (userIdData.success) {
            userId = userIdData.user_id;
            Logger.info('User ID obtained:', userId);
          } else {
            const errorMsg = userIdData.error || 'Unknown error';
            Logger.error('Failed to get user ID:', errorMsg);
            alert('Failed to get user information: ' + errorMsg);
            return;
          }
        } catch (error) {
          Logger.error('Error getting user ID:', error);
          alert('Error getting user information: ' + error.message);
          return;
        }
        
        // Initialize after getting userId
        Logger.debug('Loading campaign data...');
        await Promise.all([
          loadCampaignInfo(),
          loadMaps(),
          loadAssets(),
          loadCampaignSettings()
        ]);
        
        // Add event listener for asset category filter
        const categorySelect = document.getElementById('asset-category-select');
        const assetAddBtn = document.querySelector('#assets-section .add-btn');
        
        if (categorySelect && assetAddBtn) {
          categorySelect.addEventListener('change', function() {
            try {
              displayAssets();
              
              // Disable + button when "All" is selected
              if (this.value === 'all') {
                assetAddBtn.disabled = true;
                assetAddBtn.style.opacity = '0.5';
                assetAddBtn.style.cursor = 'not-allowed';
                assetAddBtn.title = 'Select a specific category to upload assets';
              } else {
                assetAddBtn.disabled = false;
                assetAddBtn.style.opacity = '1';
                assetAddBtn.style.cursor = 'pointer';
                assetAddBtn.title = 'Upload new asset';
              }
            } catch (error) {
              Logger.error('Error in category select change handler:', error);
            }
          });
          
          // Initialize button state
          if (categorySelect.value === 'all') {
            assetAddBtn.disabled = true;
            assetAddBtn.style.opacity = '0.5';
            assetAddBtn.style.cursor = 'not-allowed';
            assetAddBtn.title = 'Select a specific category to upload assets';
          }
        } else {
          Logger.error('Category select or asset add button not found');
        }
        
        // Initialize navigation and layer systems
        initializeMapNavigation();
        initializeLayerSystem();
        
        Logger.info('Map initialization completed successfully');
        
      } catch (error) {
        Logger.error('Critical error during initialization:', error);
        alert('Failed to initialize the map: ' + error.message);
      }
    }
    
    // Function to center the view on a specific token
    async function centerOnToken(tokenId) {
      try {
        // Validate input
        if (!tokenId || (typeof tokenId !== 'string' && typeof tokenId !== 'number')) {
          Logger.error('Invalid token ID provided for centering:', tokenId);
          alert('Errore: ID token non valido.');
          return;
        }
        
        Logger.info(`Centering view on token ID: ${tokenId}`);
        
        const mapId = MapState.getCurrentMapId();
        if (!mapId) {
          Logger.warn('No map ID available for centering on token');
          alert('Errore: Nessuna mappa attiva disponibile.');
          return;
        }
        
        // Show loading indicator
        const loadingMsg = 'Centrando sulla vista del token...';
        Logger.debug(loadingMsg);
        
        // Fetch token data to get its position with timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        let response;
        try {
          response = await fetch(`/api/map-tokens?map_id=${encodeURIComponent(mapId)}`, {
            signal: controller.signal
          });
        } catch (fetchError) {
          clearTimeout(timeoutId);
          if (fetchError.name === 'AbortError') {
            Logger.error('Token fetch request timed out');
            alert('Errore: Timeout durante il recupero dei token. Il server potrebbe essere sovraccarico.');
          } else {
            Logger.error('Network error fetching tokens:', fetchError);
            alert('Errore di rete durante il recupero dei token.');
          }
          return;
        }
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          const errorText = await response.text();
          Logger.error(`Failed to fetch tokens: ${response.status} ${response.statusText}`, errorText);
          alert(`Errore durante il recupero dei token: ${response.status} ${response.statusText}`);
          return;
        }
        
        const tokensData = await response.json();
        
        // Validate response structure
        if (!tokensData || typeof tokensData !== 'object') {
          Logger.error('Invalid tokens data structure received:', tokensData);
          alert('Errore: Dati dei token non validi ricevuti dal server.');
          return;
        }
        
        if (!tokensData.success) {
          const errorMsg = tokensData.error || 'Unknown error';
          Logger.error('Server returned error for tokens:', errorMsg);
          alert(`Errore del server: ${errorMsg}`);
          return;
        }
        
        const tokens = tokensData.tokens || [];
        
        if (!Array.isArray(tokens)) {
          Logger.error('Tokens data is not an array:', tokens);
          alert('Errore: Formato dati dei token non valido.');
          return;
        }
        
        // Find the specific token (convert both to string for comparison)
        const token = tokens.find(t => t.id === String(tokenId) || t.id === Number(tokenId));
        
        if (!token) {
          Logger.warn(`Token with ID ${tokenId} not found in ${tokens.length} available tokens`);
          Logger.debug('Available token IDs:', tokens.map(t => t.id));
          alert(`Token con ID ${tokenId} non trovato. Il token potrebbe essere stato eliminato o spostato su un'altra mappa.`);
          
          // Optionally refresh the token list to update the UI
          if (typeof loadActiveTokensAndSheets === 'function') {
            Logger.debug('Refreshing token list after failed centering attempt');
            loadActiveTokensAndSheets();
          }
          return;
        }
        
        // Validate token data structure
        if (!token.hasOwnProperty('grid_x') || !token.hasOwnProperty('grid_y')) {
          Logger.error(`Token ${tokenId} missing coordinate properties:`, token);
          alert(`Errore: Token ${tokenId} ha dati di posizione mancanti.`);
          return;
        }
        
        // Get token's grid coordinates
        const gridX = token.grid_x;
        const gridY = token.grid_y;
        
        // Validate coordinates
        if (gridX === null || gridX === undefined || gridY === null || gridY === undefined) {
          Logger.warn(`Token ${tokenId} has null/undefined coordinates: grid_x=${gridX}, grid_y=${gridY}`);
          alert(`Errore: Token ${tokenId} ha coordinate non valide (${gridX}, ${gridY}).`);
          return;
        }
        
        if (typeof gridX !== 'number' || typeof gridY !== 'number') {
          Logger.warn(`Token ${tokenId} has non-numeric coordinates: grid_x=${gridX} (${typeof gridX}), grid_y=${gridY} (${typeof gridY})`);
          alert(`Errore: Token ${tokenId} ha coordinate non numeriche.`);
          return;
        }
        
        if (!isFinite(gridX) || !isFinite(gridY)) {
          Logger.warn(`Token ${tokenId} has infinite coordinates: grid_x=${gridX}, grid_y=${gridY}`);
          alert(`Errore: Token ${tokenId} ha coordinate infinite.`);
          return;
        }
        
        Logger.debug(`Token ${tokenId} (${token.name || 'Unnamed'}) is at grid coordinates: (${gridX}, ${gridY})`);
        
        // Validate coordinate system functions
        if (!CoordinateSystem || typeof CoordinateSystem.gridToMapCoordinates !== 'function') {
          Logger.error('CoordinateSystem.gridToMapCoordinates function not available');
          alert('Errore: Sistema di coordinate non disponibile.');
          return;
        }
        
        // Convert grid coordinates to map coordinates (pixel position)
        const mapCoords = CoordinateSystem.gridToMapCoordinates(gridX, gridY);
        
        if (!mapCoords || typeof mapCoords.x !== 'number' || typeof mapCoords.y !== 'number') {
          Logger.error('Invalid map coordinates calculated:', mapCoords);
          alert('Errore: Impossibile calcolare le coordinate della mappa.');
          return;
        }
        
        // Get viewport dimensions to calculate center offset
        const viewport = document.getElementById('map-viewport');
        if (!viewport) {
          Logger.error('Map viewport not found for centering');
          alert('Errore: Viewport della mappa non trovato.');
          return;
        }
        
        const viewportRect = viewport.getBoundingClientRect();
        if (!viewportRect || viewportRect.width <= 0 || viewportRect.height <= 0) {
          Logger.error('Invalid viewport dimensions:', viewportRect);
          alert('Errore: Dimensioni del viewport non valide.');
          return;
        }
        
        const centerX = viewportRect.width / 2;
        const centerY = viewportRect.height / 2;
        
        // Calculate the pan needed to center the token
        // We need to account for the grid offset (50% - 1000px)
        const gridOffsetX = viewport.clientWidth / 2 - 1000;
        const gridOffsetY = viewport.clientHeight / 2 - 1000;
        
        // Calculate new pan values to center the token
        const newPanX = centerX - mapCoords.x - gridOffsetX;
        const newPanY = centerY - mapCoords.y - gridOffsetY;
        
        // Validate pan values
        if (!isFinite(newPanX) || !isFinite(newPanY)) {
          Logger.error('Invalid pan values calculated:', { newPanX, newPanY });
          alert('Errore: Impossibile calcolare la nuova posizione della vista.');
          return;
        }
        
        // Validate MapNavigation functions
        if (!MapNavigation || typeof MapNavigation.setPan !== 'function' || typeof MapNavigation.updateMapTransform !== 'function') {
          Logger.error('MapNavigation functions not available');
          alert('Errore: Sistema di navigazione della mappa non disponibile.');
          return;
        }
        
        // Apply the new pan
        if (MapNavigation.setPan(newPanX, newPanY)) {
          MapNavigation.updateMapTransform();
          Logger.info(`Successfully centered view on token ${tokenId} (${token.name || 'Unnamed'}) at grid (${gridX}, ${gridY})`);
          
          // Optional: Show success feedback
          Logger.debug(`Vista centrata su token "${token.name || 'Unnamed'}" alle coordinate (${gridX}, ${gridY})`);
        } else {
          Logger.warn(`Failed to set pan for centering on token ${tokenId}`);
          alert(`Errore: Impossibile centrare la vista sul token ${tokenId}.`);
        }
        
      } catch (error) {
        Logger.error(`Error centering on token ${tokenId}:`, error);
        alert(`Errore durante il centramento sul token ${tokenId}: ${error.message || 'Errore sconosciuto'}`);
      }
    }
    
    // Function to force reload current map and fix token drag and drop
    function forceReloadCurrentMap() {
      try {
        const currentMapId = MapState.getCurrentMapId();
        if (!currentMapId) {
          Logger.warn('No current map ID available for reload');
          alert('Nessuna mappa attiva da ricaricare.');
          return;
        }
        
        Logger.info('Force reloading current map to fix token attributes', { mapId: currentMapId });
        
        // Clear all layers first
        clearAllLayers();
        
        // Reload map assets
        loadMapAssets(currentMapId).then(() => {
          Logger.info('Map assets reloaded successfully');
          // Also reload the token list
          if (typeof loadActiveTokensAndSheets === 'function') {
            loadActiveTokensAndSheets(true);
          }
        }).catch(error => {
          Logger.error('Failed to reload map assets', error);
          alert('Errore durante il ricaricamento degli asset della mappa.');
        });
        
      } catch (error) {
        Logger.error('Failed to force reload current map', error);
        alert('Errore durante il ricaricamento forzato della mappa.');
      }
    }
    
    // Make the function globally available for debugging
    window.forceReloadCurrentMap = forceReloadCurrentMap;
    
    // Start initialization
    initialize();
  </script>
</body>
</html>